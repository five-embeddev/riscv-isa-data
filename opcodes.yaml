---
opcodes:
  beq:
    opcode:
    - beq
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=0
    - 6..2=0x18
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &1
    - rs1
    - rs2
    - bimm12
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - BEQ and BNE take the branch if registers rs1 and rs2 are equal or unequal
            respectively
  bne:
    opcode:
    - bne
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=1
    - 6..2=0x18
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *1
  blt:
    opcode:
    - blt
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=4
    - 6..2=0x18
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *1
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - BLT and BLTU take the branch if rs1 is less than rs2 , using signed and
            unsigned comparison respectively
          - Note, BGT, BGTU, BLE, and BLEU can be synthesized by reversing the operands
            to BLT, BLTU, BGE, and BGEU, respectively.
  bge:
    opcode:
    - bge
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=5
    - 6..2=0x18
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *1
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - BGE and BGEU take the branch if rs1 is greater than or equal to rs2 ,
            using signed and unsigned comparison respectively
  bltu:
    opcode:
    - bltu
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=6
    - 6..2=0x18
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *1
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Signed array bounds may be checked with a single BLTU instruction, since
            any negative index will compare greater than any nonnegative bound.
  bgeu:
    opcode:
    - bgeu
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=7
    - 6..2=0x18
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *1
  jalr:
    opcode:
    - jalr
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x19
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &3
    - rd
    - rs1
    - imm12
    main_desc: rv32
    main_id: "#unconditional-jumps"
    desc:
      rv32:
        "#unconditional-jumps":
          text:
          - The indirect jump instruction JALR (jump and link register) uses the I-type
            encoding
          - The JALR instruction was defined to enable a two-instruction sequence
            to jump anywhere in a 32-bit absolute address range
          - Note that the JALR instruction does not treat the 12-bit immediate as
            multiples of 2 bytes, unlike the conditional branch instructions
          - In practice, most uses of JALR will have either a zero immediate or be
            paired with a LUI or AUIPC, so the slight reduction in range is not significant.
          - Clearing the least-significant bit when calculating the JALR target address
            both simplifies the hardware slightly and allows the low bit of function
            pointers to be used to store auxiliary information
          - When used with a base rs1 = x0 , JALR can be used to implement a single
            instruction subroutine call to the lowest
          - JALR instructions should push/pop a RAS as shown in the Table&Acirc;&nbsp;
      a:
        "#sec:lrscseq":
          text:
          - "The dynamic code executed between the LR and SC instructions can only
            contain instructions from the base &acirc;\x80\x9CI&acirc;\x80\x9D instruction
            set, excluding loads, stores, backward jumps, taken backward branches,
            JALR, FENCE, and SYSTEM instructions"
      c:
        "#control-transfer-instructions":
          text:
          - C.JALR (jump and link register) performs the same operation as C.JR, but
            additionally writes the address of the instruction following the jump
            ( pc +2) to the link register, x1
          - C.JALR expands to jalr x1, 0(rs1)
          - "C.JALR is only valid when rs1 &acirc;\x80\x84&acirc;\x89&nbsp;&acirc;\x80\x84
            x0 ; the code point with rs1 &acirc;\x80\x84=&acirc;\x80\x84 x0 corresponds
            to the C.EBREAK instruction."
          - Strictly speaking, C.JALR does not expand exactly to a base RVI instruction
            as the value added to the PC to form the link address is 2 rather than
            4 as in the base ISA, but supporting both offsets of 2 and 4 bytes is
            only a very minor change to the base microarchitecture.
  jal:
    opcode:
    - jal
    - rd
    - jimm20
    - 6..2=0x1b
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &24
    - rd
    - jimm20
    main_desc: rv32
    main_id: "#programmers-model-for-base-integer-isa"
    desc:
      rv32:
        "#programmers-model-for-base-integer-isa":
          text:
          - See the descriptions of the JAL and JALR instructions.
        "#integer-register-immediate-instructions":
          text:
          - The current PC can be obtained by setting the U-immediate to 0. Although
            a JAL +4 instruction could also be used to obtain the local PC (of the
            instruction following the JAL), it might cause pipeline breaks in simpler
            microarchitectures or pollute BTB structures in more complex microarchitectures.
        "#unconditional-jumps":
          text:
          - The jump and link (JAL) instruction uses the J-type format, where the
            J-immediate encodes a signed offset in multiples of 2 bytes
          - JAL stores the address of the instruction following the jump ( pc +4)
            into register rd
          - The register x5 Plain unconditional jumps (assembler pseudoinstruction
            J) are encoded as a JAL with rd = x0 .
          - The JAL and JALR instructions will generate an instruction-address-misaligned
            exception if the target address is not aligned to a four-byte boundary.
          - A JAL instruction should push the return address onto a return-address
            stack (RAS) only when rd = x1 / x5
        "#conditional-branches":
          text:
          - Unlike some other architectures, the RISC-V jump (JAL with rd = x0 ) instruction
            should always be used for unconditional branches instead of a conditional
            branch instruction with an always-true condition
  lui:
    opcode:
    - lui
    - rd
    - imm20
    - 6..2=0x0D
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &2
    - rd
    - imm20
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - LUI (load upper immediate) is used to build 32-bit constants and uses
            the U-type format
          - LUI places the U-immediate value in the top 20 bits of the destination
            register rd , filling in the lowest 12 bits with zeros.
        "#unconditional-jumps":
          text:
          - A LUI instruction can first load rs1 with the upper 20 bits of a target
            address, then JALR can add in the lower bits
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - LUI (load upper immediate) uses the same opcode as RV32I
          - "LUI places the 20-bit U-immediate into bits 31&acirc;\x80\x9312 of register
            rd and places zero in the lowest 12 bits"
  auipc:
    opcode:
    - auipc
    - rd
    - imm20
    - 6..2=0x05
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *2
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - AUIPC (add upper immediate to pc ) is used to build pc -relative addresses
            and uses the U-type format
          - AUIPC forms a 32-bit offset from the 20-bit U-immediate, filling in the
            lowest 12 bits with zeros, adds this offset to the address of the AUIPC
            instruction, then places the result in register rd .
          - The AUIPC instruction supports two-instruction sequences to access arbitrary
            offsets from the PC for both control-flow transfers and data accesses
          - The combination of an AUIPC and the 12-bit immediate in a JALR can transfer
            control to any 32-bit PC-relative address, while an AUIPC plus the 12-bit
            immediate offset in regular load or store instructions can access any
            32-bit PC-relative data address.
        "#unconditional-jumps":
          text:
          - Similarly, AUIPC then JALR can jump anywhere in a 32-bit pc -relative
            address range.
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - AUIPC (add upper immediate to pc ) uses the same opcode as RV32I
          - AUIPC is used to build pc -relative addresses and uses the U-type format
          - AUIPC appends 12 low-order zero bits to the 20-bit U-immediate, sign-extends
            the result to 64 bits, adds it to the address of the AUIPC instruction,
            then places the result in register rd .
  addi:
    opcode:
    - addi
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ADDI adds the sign-extended 12-bit immediate to register rs1
          - ADDI rd, rs1, 0 is used to implement the MV rd, rs1 assembler pseudoinstruction.
        "#nop-instruction":
          text:
          - NOP is encoded as ADDI x0, x0, 0 .
          - ADDI was chosen for the NOP encoding as this is most likely to take fewest
            resources to execute across a range of systems (if not optimized away
            in decode)
          - Also, an ADDI functional unit is more likely to be available in a superscalar
            design as adds are the most common operation
          - In particular, address-generation functional units can execute ADDI using
            the same hardware needed for base+offset address calculations, while register-register
            ADD or logical/shift operations require additional hardware.
  slli:
    opcode:
    - slli
    - rd
    - rs1
    - 31..26=0
    - shamt
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &4
    - rd
    - rs1
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - The right shift type is encoded in bit 30. SLLI is a logical left shift
            (zeros are shifted into the lower bits); SRLI is a logical right shift
            (zeros are shifted into the upper bits); and SRAI is an arithmetic right
            shift (the original sign bit is copied into the vacated upper bits).
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - The right shift type is encoded in bit 30. SLLI is a logical left shift
            (zeros are shifted into the lower bits); SRLI is a logical right shift
            (zeros are shifted into the upper bits); and SRAI is an arithmetic right
            shift (the original sign bit is copied into the vacated upper bits).
      rv128:
        "#rv128":
          text:
          - Shifts by an immediate (SLLI/SRLI/SRAI) are now encoded using the low
            7 bits of the I-immediate, and variable shifts (SLL/SRL/SRA) use the low
            7 bits of the shift amount source register.
  slti:
    opcode:
    - slti
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - SLTI (set less than immediate) places the value 1 in register rd rs1 is
            less than the sign-extended immediate when both are treated as signed
            numbers, else 0 is written to rd
  sltiu:
    opcode:
    - sltiu
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - SLTIU is similar but compares the values as unsigned numbers (i.e., the
            immediate is first sign-extended to XLEN bits then treated as an unsigned
            number)
          - Note, SLTIU rd, rs1, 1 sets rd rs1 equals zero, otherwise sets rd to 0
            (assembler pseudoinstruction SEQZ rd, rs ).
  xori:
    opcode:
    - xori
    - rd
    - rs1
    - imm12
    - 14..12=4
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - Note, XORI rd, rs1, -1 rs1 (assembler pseudoinstruction NOT rd, rs ).
  srli:
    opcode:
    - srli
    - rd
    - rs1
    - 31..26=0
    - shamt
    - 14..12=5
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  srai:
    opcode:
    - srai
    - rd
    - rs1
    - 31..26=16
    - shamt
    - 14..12=5
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  ori:
    opcode:
    - ori
    - rd
    - rs1
    - imm12
    - 14..12=6
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
  andi:
    opcode:
    - andi
    - rd
    - rs1
    - imm12
    - 14..12=7
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and
            XOR on register rs1 and the sign-extended 12-bit immediate and place the
            result in rd
  add:
    opcode:
    - add
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=0
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &5
    - rd
    - rs1
    - rs2
    main_desc: rv32
    main_id: "#integer-computational-instructions"
    desc:
      rv32:
        "#integer-computational-instructions":
          text:
          - add t0, t1, t2 slti t3, t2, 0 slt t4, t0, t1 bne t3, t4, overflow In RV64I,
            checks of 32-bit signed additions can be optimized further by comparing
            the results of ADD and ADDW on the operands.
        "#integer-register-register-operations":
          text:
          - ADD performs the addition of rs1 and rs2
        "#sec:rv32i-hints":
          text:
          - For example, ADD is a HINT if the destination register is x0 ; the five-bit
            rs1 and rs2 fields encode arguments to the HINT
          - However, a simple implementation can simply execute the HINT as an ADD
            of rs1 and rs2 that writes x0 , which has no architecturally visible effect.
      rv64:
        "#integer-computational-instructions":
          text:
          - A few new instructions (ADD[I]W/SUBW/SxxW) are required for addition and
            shifts to ensure reasonable performance for 32-bit values.
      rv128:
        "#rv128":
          text:
          - To improve compatibility with RV64, in a reverse of how RV32 to RV64 was
            handled, we might change the decoding around to rename RV64I ADD as a
            64-bit ADDD, and add a 128-bit ADDQ in what was previously the OP-64 major
            opcode (now renamed the OP-128 major opcode).
      c:
        "#sec:rvc-hints":
          text:
          - ADD x0 , x0 , t0 .
  sub:
    opcode:
    - sub
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=0
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - SUB performs the subtraction of rs2 from rs1
  sll:
    opcode:
    - sll
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=1
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - SLL, SRL, and SRA perform logical left, logical right, and arithmetic
            right shifts on the value in register rs1 by the shift amount held in
            the lower 5 bits of register rs2 .
      rv64:
        "#integer-register-register-operations":
          text:
          - SLL, SRL, and SRA perform logical left, logical right, and arithmetic
            right shifts on the value in register rs1 by the shift amount held in
            register rs2
  slt:
    opcode:
    - slt
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=2
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - SLT and SLTU perform signed and unsigned compares respectively, writing
            1 to rd if
      a:
        "#sec:lrsc":
          text:
          - "We reserve a failure code of 1 to mean &acirc;\x80\x9Cunspecified&acirc;\x80\x9D
            so that simple implementations may return this value using the existing
            mux required for the SLT/SLTU instructions"
  sltu:
    opcode:
    - sltu
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=3
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - Note, SLTU rd , x0 , rs2 sets rd to 1 if rs2 is not equal to zero, otherwise
            sets rd to zero (assembler pseudoinstruction SNEZ rd, rs )
      rv64:
        "#integer-computational-instructions":
          text:
          - Existing 64-bit wide SLTU and unsigned branch compares still operate correctly
            on unsigned 32-bit integers under this invariant
  xor:
    opcode:
    - xor
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=4
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - "For FSGNJ, the result&acirc;\x80\x99s sign bit is rs2 &acirc;\x80\x99s
            sign bit; for FSGNJN, the result&acirc;\x80\x99s sign bit is the opposite
            of rs2 &acirc;\x80\x99s sign bit; and for FSGNJX, the sign bit is the
            XOR of the sign bits of rs1 and rs2"
  srl:
    opcode:
    - srl
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=5
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  sra:
    opcode:
    - sra
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=5
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  or:
    opcode:
    - or
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=6
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: hypervisor
    main_id: "#sec:hinterruptregs"
    desc:
      hypervisor:
        "#sec:hinterruptregs":
          text:
          - 'VS-level external interrupts are made pending based on the logical-OR
            of:'
          - When hip is read with a CSR instruction, the value of the VSEIP bit returned
            in the rd destination register is the logical-OR of all the sources listed
            above
      machine:
        "#machine-interrupt-registers-mip-and-mie":
          text:
          - Supervisor-level external interrupts are made pending based on the logical-OR
            of the software-writable SEIP bit and the signal from the external interrupt
            controller
          - When mip is read with a CSR instruction, the value of the SEIP bit returned
            in the rd destination register is the logical-OR of the software-writable
            bit and the interrupt signal from the interrupt controller
      v:
        "#_vector_fixed_point_rounding_mode_register_code_vxrm_code":
          text:
          - 'round-to-odd (OR bits into LSB, aka "jam") !v[d] & v[d-1:0]&ne;0 The
            rounding functions:'
  and:
    opcode:
    - and
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=7
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - AND, OR, and XOR perform bitwise logical operations.
      a:
        "#sec:amo":
          text:
          - The operations supported are swap, integer add, bitwise AND, bitwise OR,
            bitwise XOR, and signed and unsigned integer maximum and minimum
      hypervisor:
        "#sec:hinterruptregs":
          text:
          - SGEIP is read-only in hip , and is 1 if and only if the bitwise logical-AND
            of CSRs hgeip and hgeie is nonzero in any bit
      v:
        "#_vector_integer_comparison_instructions":
          text:
          - Comparisons effectively AND in the mask, e.g,
  addiw:
    opcode:
    - addiw
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x06
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv64
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - ADDIW is an RV64I instruction that adds the sign-extended 12-bit immediate
            to register rs1 and produces the proper sign-extension of a 32-bit result
            in rd
          - Note, ADDIW rd, rs1, 0 writes the sign-extension of the lower 32 bits
            of register rs1 into register rd (assembler pseudoinstruction SEXT.W).
      c:
        "#overview":
          text:
          - In addition, RV32C includes a compressed jump and link instruction to
            compress short-range subroutine calls, where the same opcode is used to
            compress ADDIW for RV64C and RV128C.
        "#integer-register-immediate-operations":
          text:
          - C.ADDIW is an RV64C/RV128C-only instruction that performs the same computation
            but produces a 32-bit result, then sign-extends result to 64 bits
          - C.ADDIW expands into addiw rd, rd, imm[5:0]
          - The immediate can be zero for C.ADDIW, where this corresponds to sext.w
            rd
          - "C.ADDIW is only valid when rd &acirc;\x89&nbsp; x0 ; the code points
            with rd = x0 are reserved."
  slliw:
    opcode:
    - slliw
    - rd
    - rs1
    - 31..25=0
    - shamtw
    - 14..12=1
    - 6..2=0x06
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: rv64
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - SLLIW, SRLIW, and SRAIW are RV64I-only instructions that are analogously
            defined but operate on 32-bit values and produce signed 32-bit results
          - "SLLIW, SRLIW, and SRAIW encodings with i m m [5]&acirc;\x80\x84&acirc;\x89&nbsp;&acirc;\x80\x840"
          - "Previously, SLLIW, SRLIW, and SRAIW with i m m [5]&acirc;\x80\x84&acirc;\x89&nbsp;&acirc;\x80\x840"
  srliw:
    opcode:
    - srliw
    - rd
    - rs1
    - 31..25=0
    - shamtw
    - 14..12=5
    - 6..2=0x06
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  sraiw:
    opcode:
    - sraiw
    - rd
    - rs1
    - 31..25=32
    - shamtw
    - 14..12=5
    - 6..2=0x06
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  addw:
    opcode:
    - addw
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=0
    - 6..2=0x0E
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: rv64
    main_id: "#integer-register-register-operations"
    desc:
      rv64:
        "#integer-register-register-operations":
          text:
          - ADDW and SUBW are RV64I-only instructions that are defined analogously
            to ADD and SUB but operate on 32-bit values and produce signed 32-bit
            results
  subw:
    opcode:
    - subw
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=0
    - 6..2=0x0E
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  sllw:
    opcode:
    - sllw
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=1
    - 6..2=0x0E
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: rv64
    main_id: "#integer-register-register-operations"
    desc:
      rv64:
        "#integer-register-register-operations":
          text:
          - SLLW, SRLW, and SRAW are RV64I-only instructions that are analogously
            defined but operate on 32-bit values and produce signed 32-bit results
  srlw:
    opcode:
    - srlw
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=5
    - 6..2=0x0E
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  sraw:
    opcode:
    - sraw
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=5
    - 6..2=0x0E
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  lb:
    opcode:
    - lb
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x00
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv32
    main_id: "#load-and-store-instructions"
    desc:
      rv32:
        "#load-and-store-instructions":
          text:
          - LB and LBU are defined analogously for 8-bit values
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, or FLQ, the transformed
            instruction has the format shown in Figure&Acirc;&nbsp;
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, or FLQ)
          - In decoding the contents of mtinst or htinst , once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, or FLQ) or basic store (SB, SH, SW,
            SD, FSW, FSD, or FSQ), it is not necessary to confirm also that the immediate
            offset fields (31:25, and 24:20 or 11:7) are zeros
  lh:
    opcode:
    - lh
    - rd
    - rs1
    - imm12
    - 14..12=1
    - 6..2=0x00
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv32
    main_id: "#load-and-store-instructions"
    desc:
      rv32:
        "#load-and-store-instructions":
          text:
          - LH loads a 16-bit value from memory, then sign-extends to 32-bits before
            storing in rd
      rv64:
        "#load-and-store-instructions":
          text:
          - LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values
  lw:
    opcode:
    - lw
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x00
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv32
    main_id: "#load-and-store-instructions"
    desc:
      rv32:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory into rd
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For example, if bits 1:0 are binary 11 and the register value is the encoding
            of a standard LW (load word) instruction, then the trapping instruction
            is LW, and the register value is the transformation of the trapping LW
            instruction.
          - For instance, for RV64, discovering that bits 6:0 of mtinst are 0000011
            and bits 14:12 are 010 is not sufficient to establish that the first case
            applies and the trapping instruction is a standard LW instruction; rather,
            software must also confirm that bits 63:32 of mtinst are all zeros
  ld:
    opcode:
    - ld
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x00
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv64
    main_id: "#load-and-store-instructions"
    desc:
      rv64:
        "#load-and-store-instructions":
          text:
          - The LD instruction loads a 64-bit value from memory into register rd for
            RV64I.
      c:
        "#register-based-loads-and-stores":
          text:
          - "C.LD is an RV64C/RV128C-only instruction that loads a 64-bit value from
            memory into register rd&acirc;\x80\x86 &acirc;\x80&sup2;"
  lbu:
    opcode:
    - lbu
    - rd
    - rs1
    - imm12
    - 14..12=4
    - 6..2=0x00
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
  lhu:
    opcode:
    - lhu
    - rd
    - rs1
    - imm12
    - 14..12=5
    - 6..2=0x00
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv32
    main_id: "#load-and-store-instructions"
    desc:
      rv32:
        "#load-and-store-instructions":
          text:
          - LHU loads a 16-bit value from memory but then zero extends to 32-bits
            before storing in rd
  lwu:
    opcode:
    - lwu
    - rd
    - rs1
    - imm12
    - 14..12=6
    - 6..2=0x00
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: rv64
    main_id: "#load-and-store-instructions"
    desc:
      rv64:
        "#load-and-store-instructions":
          text:
          - The LWU instruction, on the other hand, zero-extends the 32-bit value
            from memory for RV64I
  sb:
    opcode:
    - sb
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=0
    - 6..2=0x08
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &6
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    main_desc: hypervisor
    main_id: "#sec:tinst-vals"
    desc:
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For a standard store instruction that is not a compressed instruction
            and is one of SB, SH, SW, SD, FSW, FSD, or FSQ, the transformed instruction
            has the format shown in Figure&Acirc;&nbsp;
          - Transformed noncompressed store instruction (SB, SH, SW, SD, FSW, FSD,
            or FSQ)
  sh:
    opcode:
    - sh
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=1
    - 6..2=0x08
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *6
  sw:
    opcode:
    - sw
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=2
    - 6..2=0x08
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *6
    main_desc: rv32
    main_id: "#load-and-store-instructions"
    desc:
      rv32:
        "#load-and-store-instructions":
          text:
          - The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values
            from the low bits of register rs2 to memory.
  sd:
    opcode:
    - sd
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=3
    - 6..2=0x08
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *6
    main_desc: rv64
    main_id: "#load-and-store-instructions"
    desc:
      rv64:
        "#load-and-store-instructions":
          text:
          - The SD, SW, SH, and SB instructions store 64-bit, 32-bit, 16-bit, and
            8-bit values from the low bits of register rs2 to memory respectively.
      c:
        "#register-based-loads-and-stores":
          text:
          - "C.SD is an RV64C/RV128C-only instruction that stores a 64-bit value in
            register rs2&acirc;\x80\x86 &acirc;\x80&sup2;"
      hypervisor:
        "#virtual-supervisor-status-register-vsstatus":
          text:
          - Read-only fields SD and XS summarize the extension context status as it
            is visible to VS-mode only
          - For example, the value of the HS-level sstatus .FS does not affect vsstatus
            .SD.
      machine:
        "#machine-status-registers-mstatus-and-mstatush":
          text:
          - ". Bits 30:4 of mstatush generally contain the same fields found in bits
            62:36 of mstatus for RV64. Fields SD, SXL, and UXL do not exist in mstatush
            ."
        "#extension-context-status-in-mstatus-register":
          text:
          - The design anticipates that most context switches will not need to save/restore
            state in either or both of the floating-point unit or other extensions,
            so provides a fast check via the SD bit.
          - The SD bit is a read-only bit that summarizes whether either the FS field
            or XS field signals the presence of some dirty state that will require
            saving extended user context to memory
          - If both XS and FS are hardwired to zero, then SD is also always zero.
          - The SD bit is read-only and is set when either the FS or XS bits encode
            a Dirty state (i.e., SD=((FS==11) OR (XS==11)))
  fence:
    opcode:
    - fence
    - fm
    - pred
    - succ
    - rs1
    - 14..12=0
    - rd
    - 6..2=0x03
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &25
    - rs1
    - rd
    main_desc: rv32
    main_id: "#sec:fence"
    desc:
      rv32:
        "#sec:fence":
          text:
          - The FENCE instruction is used to order device I/O and memory accesses
            as viewed by other RISC-V harts and external devices or coprocessors
          - Informally, no other RISC-V hart or external device can observe any operation
            in the successor set following a FENCE before any operation in the predecessor
            set preceding the FENCE
          - Instruction-set extensions might also describe new I/O instructions that
            will also be ordered using the I and O bits in a FENCE.
          - The fence mode field fm defines the semantics of the FENCE
          - A FENCE with fm =0000 orders all memory operations in its predecessor
            set before all memory operations in its successor set.
          - The optional FENCE.TSO instruction is encoded as a FENCE instruction with
            fm =1000, predecessor =RW, and successor =RW
          - FENCE.TSO orders all load operations in its predecessor set before all
            memory operations in its successor set, and all store operations in its
            predecessor set before all store operations in its successor set
          - "This leaves non-AMO store operations in the FENCE.TSO&acirc;\x80\x99s
            predecessor set unordered with non-AMO loads in its successor set."
          - The FENCE.TSO encoding was added as an optional extension to the original
            base FENCE instruction encoding
          - The base definition requires that implementations ignore any set bits
            and treat the FENCE as global, and so this is a backwards-compatible extension.
          - "The unused fields in the FENCE instructions&acirc;\x80\x94 rs1 and rd
            &acirc;\x80\x94are reserved for finer-grain fences in future extensions"
      a:
        "#specifying-ordering-of-atomic-instructions":
          text:
          - The base RISC-V ISA has a relaxed memory model, with the FENCE instruction
            used to impose additional ordering constraints
          - The address space is divided by the execution environment into memory
            and I/O domains, and the FENCE instruction provides options to order accesses
            to one or both of these two address domains.
          - No ordering constraint is implied to accesses to the other domain, and
            a FENCE instruction should be used to order across both domains.
        "#sec:amo":
          text:
          - Although the FENCE R, RW instruction suffices to implement the acquire
            operation and FENCE RW, W suffices to implement release , both imply additional
            unnecessary ordering as compared to AMOs with the corresponding aq or
            rl bit set.
      csr:
        "#csr-access-ordering":
          text:
          - To enforce ordering in all other cases, software should execute a FENCE
            instruction between the relevant accesses
          - For the purposes of the FENCE instruction, CSR read accesses are classified
            as device input (I), and CSR write accesses are classified as device output
            (O).
          - Thus, accesses to CSRs other than the aforementioned three can be freely
            reordered with respect to FENCE instructions without violating this specification.
      supervisor:
        "#sec:translation":
          text:
          - The ordering on loads and stores provided by FENCE instructions and the
            acquire/release bits on atomic instructions also orders the PTE updates
            associated with those loads and stores as observed by remote harts.
      machine:
        "#memory-ordering-pmas":
          text:
          - Regions of the address space are classified as either main memory or I/O
            for the purposes of ordering by the FENCE instruction and atomic-instruction
            ordering bits.
  fence.i:
    opcode:
    - fence.i
    - imm12
    - rs1
    - 14..12=1
    - rd
    - 6..2=0x03
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &26
    - imm12
    - rs1
    - rd
  mul:
    opcode:
    - mul
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=0
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: m
    main_id: "#multiplication-operations"
    desc:
      m:
        "#multiplication-operations":
          text:
          - MUL performs an XLEN-bit
          - In RV64, MUL can be used to obtain the upper 32 bits of the 64-bit product,
            but signed arguments must be proper 32-bit signed values, whereas unsigned
            arguments must have their upper 32 bits clear
  mulh:
    opcode:
    - mulh
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=1
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: m
    main_id: "#multiplication-operations"
    desc:
      m:
        "#multiplication-operations":
          text:
          - MULH, MULHU, and MULHSU perform the same multiplication but return the
            upper XLEN bits of the full 2
          - 'If both the high and low bits of the same product are required, then
            the recommended code sequence is: MULH[[S]U] rdh, rs1, rs2 ; MUL rdl,
            rs1, rs2 (source register specifiers must be in same order and rdh cannot
            be the same as rs1 or rs2 )'
          - If the arguments are not known to be sign- or zero-extended, an alternative
            is to shift both arguments left by 32 bits, then use MULH[[S]U].
  mulhsu:
    opcode:
    - mulhsu
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=2
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: m
    main_id: "#multiplication-operations"
    desc:
      m:
        "#multiplication-operations":
          text:
          - MULHSU is used in multi-word signed multiplication to multiply the most-significant
            word of the multiplicand (which contains the sign bit) with the less-significant
            words of the multiplier (which are unsigned).
  mulhu:
    opcode:
    - mulhu
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=3
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  div:
    opcode:
    - div
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=4
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIV and DIVU perform an XLEN bits by XLEN bits signed and unsigned integer
            division of rs1 by rs2 , rounding towards zero
          - 'If both the quotient and remainder are required from the same division,
            the recommended code sequence is: DIV[U] rdq, rs1, rs2 ; REM[U] rdr, rs1,
            rs2 ( rdq rs1 or rs2 )'
          - DIV[W]
  divu:
    opcode:
    - divu
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=5
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIVU[W]
  rem:
    opcode:
    - rem
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=6
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - REM and REMU provide the remainder of the corresponding division operation
          - For REM, the sign of the result equals the sign of the dividend.
          - REM[W]
  remu:
    opcode:
    - remu
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=7
    - 6..2=0x0C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - REMU[W]
  mulw:
    opcode:
    - mulw
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=0
    - 6..2=0x0E
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: m
    main_id: "#multiplication-operations"
    desc:
      m:
        "#multiplication-operations":
          text:
          - MULW is an RV64 instruction that multiplies the lower 32 bits of the source
            registers, placing the sign-extension of the lower 32 bits of the result
            into the destination register.
  divw:
    opcode:
    - divw
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=4
    - 6..2=0x0E
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIVW and DIVUW are RV64 instructions that divide the lower 32 bits of
            rs1 by the lower 32 bits of rs2 , treating them as signed and unsigned
            integers respectively, placing the 32-bit quotient in rd , sign-extended
            to 64 bits
  divuw:
    opcode:
    - divuw
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=5
    - 6..2=0x0E
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  remw:
    opcode:
    - remw
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=6
    - 6..2=0x0E
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - REMW and REMUW are RV64 instructions that provide the corresponding signed
            and unsigned remainder operations respectively
          - Both REMW and REMUW always sign-extend the 32-bit result to 64 bits, including
            on a divide by zero.
  remuw:
    opcode:
    - remuw
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=7
    - 6..2=0x0E
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  amoadd.w:
    opcode:
    - amoadd.w
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=0
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amoxor.w:
    opcode:
    - amoxor.w
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=1
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amoor.w:
    opcode:
    - amoor.w
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=2
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amoand.w:
    opcode:
    - amoand.w
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=3
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amomin.w:
    opcode:
    - amomin.w
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=4
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amomax.w:
    opcode:
    - amomax.w
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=5
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amominu.w:
    opcode:
    - amominu.w
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=6
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amomaxu.w:
    opcode:
    - amomaxu.w
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=7
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amoswap.w:
    opcode:
    - amoswap.w
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=0
    - 28..27=1
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  lr.w:
    opcode:
    - lr.w
    - rd
    - rs1
    - 24..20=0
    - aqrl
    - 31..29=0
    - 28..27=2
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: a
    main_id: "#sec:lrsc"
    desc:
      a:
        "#sec:lrsc":
          text:
          - "LR.W loads a word from the address in rs1 , places the sign-extended
            value in rd , and registers a reservation set &acirc;\x80\x94a set of
            bytes that subsumes the bytes in the addressed word"
  sc.w:
    opcode:
    - sc.w
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=0
    - 28..27=3
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:lrsc"
    desc:
      a:
        "#sec:lrsc":
          text:
          - 'SC.W conditionally writes a word in rs2 to the address in rs1 : the SC.W
            succeeds only if the reservation is still valid and the reservation set
            contains the bytes being written'
          - If the SC.W succeeds, the instruction writes the word in rs2 to memory,
            and it writes zero to rd
          - If the SC.W fails, the instruction does not write to memory, and it writes
            a nonzero value to rd
          - Regardless of success or failure, executing an SC.W instruction invalidates
            any reservation held by this hart
  amoadd.d:
    opcode:
    - amoadd.d
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=0
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amoxor.d:
    opcode:
    - amoxor.d
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=1
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amoor.d:
    opcode:
    - amoor.d
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=2
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amoand.d:
    opcode:
    - amoand.d
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=3
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amomin.d:
    opcode:
    - amomin.d
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=4
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amomax.d:
    opcode:
    - amomax.d
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=5
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amominu.d:
    opcode:
    - amominu.d
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=6
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amomaxu.d:
    opcode:
    - amomaxu.d
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=7
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  amoswap.d:
    opcode:
    - amoswap.d
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=0
    - 28..27=1
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - These AMO instructions atomically load a data value from the address in
            rs1 , place the value into register rd , apply a binary operator to the
            loaded value and the original value in rs2 , then store the result back
            to the address in rs1
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions)
      v:
        "#_vector_amo_operations_code_zvamo_code":
          text:
          - If vector AMO instructions are supported, then the scalar Zaamo instructions
            (atomic operations from the standard A extension) must be present.
          - Vector AMO instructions are only supported for the memory element widths
            supported by AMOs in the implementation&rsquo;s scalar architecture
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector load/store and AMO instructions are unaffected by EDIV, and continue
            to move whole elements.
  lr.d:
    opcode:
    - lr.d
    - rd
    - rs1
    - 24..20=0
    - aqrl
    - 31..29=0
    - 28..27=2
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: a
    main_id: "#sec:lrsc"
    desc:
      a:
        "#sec:lrsc":
          text:
          - LR.D and SC.D act analogously on doublewords and are only available on
            RV64. For RV64, LR.W and SC.W sign-extend the value placed in rd .
  sc.d:
    opcode:
    - sc.d
    - rd
    - rs1
    - rs2
    - aqrl
    - 31..29=0
    - 28..27=3
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  ecall:
    opcode:
    - ecall
    - 11..7=0
    - 19..15=0
    - 31..20=0x000
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &7 []
    main_desc: rv32
    main_id: "#rv32"
    desc:
      rv32:
        "#rv32":
          text:
          - RV32I contains 40 unique instructions, though a simple implementation
            might cover the ECALL/EBREAK instructions with a single SYSTEM hardware
            instruction that always traps and might be able to implement the FENCE
            instruction as a NOP, reducing base instruction count to 38 total
        "#environment-call-and-breakpoints":
          text:
          - The ECALL instruction is used to make a service request to the execution
            environment
          - ECALL and EBREAK were previously named SCALL and SBREAK
          - Semihosting is a form of service call and would be more naturally encoded
            as an ECALL using an existing ABI, but this would require the debugger
            to be able to intercept ECALLs, which is a newer addition to the debug
            standard
      machine:
        "#environment-call-and-breakpoint":
          text:
          - The ECALL instruction is used to make a request to the supporting execution
            environment
          - ECALL generates a different exception for each originating privilege mode
            so that environment call exceptions can be selectively delegated
          - "ECALL and EBREAK cause the receiving privilege mode&acirc;\x80\x99s epc
            register to be set to the address of the ECALL or EBREAK instruction itself,
            not minstret CSR."
  ebreak:
    opcode:
    - ebreak
    - 11..7=0
    - 19..15=0
    - 31..20=0x001
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *7
    main_desc: rv32
    main_id: "#environment-call-and-breakpoints"
    desc:
      rv32:
        "#environment-call-and-breakpoints":
          text:
          - The EBREAK instruction is used to return control to a debugging environment.
          - EBREAK was primarily designed to be used by a debugger to cause execution
            to stop and fall back into the debugger
          - EBREAK is also used by the standard gcc compiler to mark code paths that
            should not be executed.
          - "Another use of EBREAK is to support &acirc;\x80\x9Csemihosting&acirc;\x80\x9D,
            where the execution environment includes a debugger that can provide services
            over an alternate system call interface built around the EBREAK instruction"
          - Because the RISC-V base ISA does not provide more than one EBREAK instruction,
            RISC-V semihosting uses a special sequence of instructions to distinguish
            a semihosting EBREAK from a debugger inserted EBREAK
      c:
        "#breakpoint-instruction":
          text:
          - Debuggers can use the C.EBREAK instruction, which expands to ebreak ,
            to cause control to be transferred back to the debugging environment
          - C.EBREAK shares the opcode with the C.ADD instruction, but with rd and
            rs2 both zero, thus can also use the CR format.
      machine:
        "#sec:mcause":
          text:
          - watchpoints) and environment break exceptions (which are raised by the
            EBREAK instruction).
        "#environment-call-and-breakpoint":
          text:
          - The EBREAK instruction is used by debuggers to cause control to be transferred
            back to a debugging environment
          - "As described in the &acirc;\x80\x9CC&acirc;\x80\x9D Standard Extension
            for Compressed Instructions in Volume I of this manual, the C.EBREAK instruction
            performs the same operation as the EBREAK instruction."
  uret:
    opcode:
    - uret
    - 11..7=0
    - 19..15=0
    - 31..20=0x002
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *7
    main_desc: n
    main_id: "#user-status-register-ustatus"
    desc:
      n:
        "#user-status-register-ustatus":
          text:
          - A new instruction, URET, is used to return from traps in U-mode
          - URET copies UPIE into UIE, then sets UPIE, before copying uepc pc
        "#n-extension-instructions":
          text:
          - The URET instruction is added to perform the analogous function to MRET
            and SRET.
        "#reducing-context-swap-overhead":
          text:
          - Execution of URET will place the uepc , ucause , and utval back into initial
            state.
      machine:
        "#otherpriv":
          text:
          - To support the addition of user-level interrupts, we needed to add a separate
            URET instruction to continue to allow classic virtualization of OS code
            using the ERET instruction
  sret:
    opcode:
    - sret
    - 11..7=0
    - 19..15=0
    - 31..20=0x102
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *7
    main_desc: supervisor
    main_id: "#sstatus"
    desc:
      supervisor:
        "#sstatus":
          text:
          - When an SRET instruction (see Section&Acirc;&nbsp;
          - When a trap is taken into supervisor mode, SPIE is set to SIE, and SIE
            is set to 0. When an SRET instruction is executed, SIE is set to SPIE,
            then SPIE is set to 1.
        "#supervisor-exception-program-counter-sepc":
          text:
          - If an implementation allows IALIGN to be either 16 or 32 (by changing
            CSR misa , for example), then, whenever IALIGN=32, bit sepc[1] is masked
            on reads so that it appears to be 0. This masking occurs also for the
            implicit read by the SRET instruction
        "#supervisor-instructions":
          text:
          - In addition to the SRET instruction defined in Section&Acirc;&nbsp;
      hypervisor:
        "#hypervisor-and-virtual-supervisor-csrs":
          text:
          - Matching VS CSRs exist only for the supervisor CSRs that must be duplicated,
            which are mainly those that get automatically written by traps or that
            impact instruction execution immediately after trap entry and/or right
            before SRET, when software alone is unable to swap a CSR at exactly the
            right moment
        "#hypervisor-status-register-hstatus":
          text:
          - The hstatus fields VTSR and VTVM are defined analogously to the mstatus
            fields TSR and TVM, but affect the trapping behavior of the SRET and virtual-memory
            management instructions only when V=1.
          - When an SRET instruction is executed when V=0, V is set to SPV.
          - 'When an SRET instruction is executed when V=0, the reverse assignments
            occur: after SPV and sstatus .SPP have supplied the new virtualization
            and privilege modes, they are written with SP2V and SP2P, respectively.'
        "#trap-return":
          text:
          - The SRET instruction is used to return from a trap taken into HS-mode
            or VS-mode
          - When executed in M-mode or HS-mode (i.e., V=0), SRET first determines
            what the new operating mode will be according to the values in hstatus
            .SPV and sstatus .SPP, as encoded in Table&Acirc;&nbsp;
          - ". SRET then sets hstatus .SPV= hstatus .SP2V, sstatus .SPP= hstatus .SP2P,
            hstatus .SP2V=0, hstatus .SP2P=0, sstatus .SIE= sstatus .SPIE, and sstatus
            .SPIE=1. If the new operating mode will be U, VS, or VU, SRET also sets
            hstatus .SPRV=0. Lastly, SRET sets the virtualization and privilege modes
            as previously determined, and sets pc = sepc ."
          - When executed in VS-mode (i.e., V=1), SRET sets the privilege mode according
            to Table&Acirc;&nbsp;
      machine:
        "#virt-control":
          text:
          - The TSR (Trap SRET) bit is a
          - "&Acirc;&nbsp;field that supports intercepting the supervisor exception
            return instruction, SRET"
          - When TSR=1, attempts to execute SRET while executing in S-mode will raise
            an illegal instruction exception
          - Trapping SRET is necessary to emulate the hypervisor extension (see Chapter&Acirc;&nbsp;
        "#otherpriv":
          text:
          - SRET must be provided if supervisor mode is supported, and should raise
            an illegal instruction exception otherwise
          - SRET should also raise an illegal instruction exception when TSR=1 in
            mstatus , as described in Section&Acirc;&nbsp;
          - Previously, there was only a single ERET instruction (which was also earlier
            known as SRET)
  mret:
    opcode:
    - mret
    - 11..7=0
    - 19..15=0
    - 31..20=0x302
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *7
    main_desc: hypervisor
    main_id: "#hypervisor-status-register-hstatus"
    desc:
      hypervisor:
        "#hypervisor-status-register-hstatus":
          text:
          - An MRET or SRET instruction that changes the operating mode to U-mode,
            VS-mode, or VU-mode also sets SPRV=0.
        "#machine-status-registers-mstatus-and-mstatush":
          text:
          - When an MRET instruction is executed, the virtualization mode V is set
            to MPV, unless MPP=3, in which case V remains 0.
        "#trap-return":
          text:
          - The MRET instruction is used to return from a trap taken into M-mode
          - MRET first determines what the new operating mode will be according to
            the values of MPP and MPV in mstatus or mstatush , as encoded in Table&Acirc;&nbsp;
          - ". MRET then in mstatus / mstatush sets MPV=0, MPP=0, MIE=MPIE, and MPIE=1.
            If the new operating mode will be U, VS, or VU, MRET also sets hstatus
            .SPRV=0. Lastly, MRET sets the virtualization and privilege modes as previously
            determined, and sets pc = mepc ."
      machine:
        "#privstack":
          text:
          - An MRET or SRET instruction is used to return from a trap in M-mode or
            S-mode respectively
        "#memory-privilege-in-mstatus-register":
          text:
          - An MRET or SRET instruction that changes the privilege mode to a mode
            less privileged than M also sets MPRV=0.
        "#machine-trap-delegation-registers-medeleg-and-mideleg":
          text:
          - By default, all traps at any privilege level are handled in machine mode,
            though a machine-mode handler can redirect traps back to the appropriate
            level with the MRET instruction (Section&Acirc;&nbsp;
        "#machine-exception-program-counter-mepc":
          text:
          - If an implementation allows IALIGN to be either 16 or 32 (by changing
            CSR misa , for example), then, whenever IALIGN=32, bit mepc[1] is masked
            on reads so that it appears to be 0. This masking occurs also for the
            implicit read by the MRET instruction
        "#otherpriv":
          text:
          - To return after handling a trap, there are separate trap return instructions
            per privilege level, MRET and SRET
          - MRET is always provided
  dret:
    opcode:
    - dret
    - 11..7=0
    - 19..15=0
    - 31..20=0x7b2
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *7
  sfence.vma:
    opcode:
    - sfence.vma
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x09
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &8
    - rs1
    - rs2
    main_desc: supervisor
    main_id: "#sec:satp"
    desc:
      supervisor:
        "#sec:satp":
          text:
          - "If the new address space&acirc;\x80\x99s page tables have been modified,
            or if an ASID is reused, it may be necessary to execute an SFENCE.VMA
            instruction (see Section&Acirc;&nbsp;"
        "#sec:sfence.vma":
          text:
          - The supervisor memory-management fence instruction SFENCE.VMA is used
            to synchronize updates to in-memory memory-management data structures
            with current execution
          - Executing an SFENCE.VMA instruction guarantees that any previous stores
            already visible to the current RISC-V hart are ordered before all subsequent
            implicit references from that hart to the memory-management data structures
          - The SFENCE.VMA is used to flush any local hardware caches related to address
            translation
          - SFENCE.VMA is also used by higher privilege levels to synchronize page
            table writes and the address translation hardware.
          - "SFENCE.VMA orders only the local hart&acirc;\x80\x99s implicit references
            to the memory-management data structures."
          - One approach is to use 1) a local data fence to ensure local writes are
            visible globally, then 2) an interprocessor interrupt to the other thread,
            then 3) a local SFENCE.VMA in the interrupt handler of the remote thread,
            and finally 4) signal back to originating thread that operation is complete
          - 'The behavior of SFENCE.VMA depends on rs1 and rs2 as follows:'
          - To ensure the implicit reads observe writes to the same memory locations,
            an SFENCE.VMA instruction must be executed after the writes to flush the
            relevant cached translations.
          - Implementations must only perform implicit reads of the translation data
            structures pointed to by the current contents of the satp Changes to the
            sstatus fields SUM and MXR take effect immediately, without the need to
            execute an SFENCE.VMA instruction.
          - 'The following common situations typically require executing an SFENCE.VMA
            instruction:'
          - When software recycles an ASID (i.e., reassociates it with a different
            page table), it should first change satp to point to the new page table
            using the recycled ASID, then execute SFENCE.VMA with rs1 = x0 and rs2
            set to the recycled ASID
          - Alternatively, software can execute the same SFENCE.VMA instruction while
            a different ASID is loaded into satp , provided the next time satp is
            loaded with the recycled ASID, it is simultaneously loaded with the new
            page table.
          - If the implementation does not provide ASIDs, or software chooses to always
            use ASID 0, then after every satp write, software should execute SFENCE.VMA
            with rs1 = x0
          - If software modifies a non-leaf PTE, it should execute SFENCE.VMA with
            rs1 = x0
          - If software modifies a leaf PTE, it should execute SFENCE.VMA with rs1
            set to a virtual address within the page
          - If any PTE along the traversal path had its G bit set, rs2 must be x0
            ; otherwise, rs2 For the special cases of increasing the permissions on
            a leaf PTE and changing an invalid PTE to a valid leaf, software may choose
            to execute the SFENCE.VMA lazily
          - After modifying the PTE but before executing SFENCE.VMA, either the new
            or old permissions will be used
          - In the latter case, a page-fault exception might occur, at which point
            software should execute SFENCE.VMA in accordance with the previous bullet
            point.
        "#sec:translation":
          text:
          - "Additionally, they need not be flushed from local address-translation
            caches when an SFENCE.VMA instruction is executed with rs2 &acirc;\x89&nbsp;
            x0 ."
      hypervisor:
        "#sec:hfence.vma":
          text:
          - These instructions perform a function similar to SFENCE.VMA (Section&Acirc;&nbsp;
          - If an HFENCE.VVMA instruction executes without trapping, its effect is
            much the same as temporarily entering VS-mode and executing SFENCE.VMA
        "#memory-management-fences":
          text:
          - The behavior of the SFENCE.VMA instruction is affected by the current
            virtualization mode V
          - When V=1, the virtual-address argument to SFENCE.VMA is a guest virtual
            address within the current virtual machine, and the ASID argument is a
            VS-level ASID within the current virtual machine
          - The SFENCE.VMA instruction orders stores only to the VS-level address-translation
            structures with subsequent VS-level address translations for the same
            virtual machine, i.e., only when hgatp .VMID is the same as when the SFENCE.VMA
            executed.
          - For HS-level address translation, this is accomplished by executing in
            M-mode an SFENCE.VMA instruction with rs1 = x0 and rs2 = x0 , after the
            PMP CSRs are written
      machine:
        "#endianness-control-in-mstatus-and-mstatush-registers":
          text:
          - "Since changing SBE alters the implementation&acirc;\x80\x99s interpretation
            of these data structures, if any such data structures remain in use across
            a change to SBE, M-mode software must follow such a change to SBE by executing
            an SFENCE.VMA instruction with rs1 = x0 and rs2 = x0 ."
          - In this case, no additional SFENCE.VMA is necessary, beyond what would
            ordinarily be required for a world switch.
        "#virt-control":
          text:
          - When TVM=1, attempts to read or write the satp CSR or execute the SFENCE.VMA
            instruction while executing in S-mode will raise an illegal instruction
            exception
          - Trapping satp accesses and the SFENCE.VMA instruction provides the hooks
            necessary to lazily populate shadow page tables.
        "#pmp-vmem":
          text:
          - This is accomplished by executing an SFENCE.VMA instruction with rs1 =
            x0 rs2 = x0 , after the PMP CSRs are written.
  wfi:
    opcode:
    - wfi
    - 11..7=0
    - 19..15=0
    - 31..20=0x105
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *7
    main_desc: hypervisor
    main_id: "#wfi-in-virtual-operating-modes"
    desc:
      hypervisor:
        "#wfi-in-virtual-operating-modes":
          text:
          - Executing instruction WFI when V=1 causes an illegal instruction exception,
            unless it completes within an implementation-specific, bounded time limit.
          - The behavior required of WFI in VS-mode and VU-mode is the same as required
            of it in U-mode when S-mode exists.
      machine:
        "#virt-control":
          text:
          - "&Acirc;&nbsp;field that supports intercepting the WFI instruction (see
            Section&Acirc;&nbsp;"
          - When TW=0, the WFI instruction may execute in lower privilege modes when
            not prevented for some other reason
          - When TW=1, then if WFI is executed in any less-privileged mode, and it
            does not complete within an implementation-specific, bounded time limit,
            the WFI instruction causes an illegal instruction exception
          - The time limit may always be 0, in which case WFI always causes an illegal
            instruction exception in less-privileged modes when TW=1. TW is hard-wired
            to 0 when there are no modes less privileged than M.
          - Trapping the WFI instruction can trigger a world switch to another guest
            OS, rather than wastefully idling in the current guest.
          - When S-mode is implemented, then executing WFI in U-mode causes an illegal
            instruction exception, unless it completes within an implementation-specific,
            bounded time limit
          - A future revision of this specification might add a feature that allows
            S-mode to selectively permit WFI in U-mode
        "#wfi":
          text:
          - The Wait for Interrupt instruction (WFI) provides a hint to the implementation
            that the current hart can be stalled until an interrupt might need servicing
          - Execution of the WFI instruction can also be used to inform the hardware
            platform that suitable interrupts should preferentially be routed to this
            hart
          - WFI is available in all privileged modes, and optionally available to
            U-mode
          - The following instruction takes the interrupt exception and trap, so that
            a simple return from the trap handler will execute code after the WFI
            instruction.
          - The purpose of the WFI instruction is to provide a hint to the implementation,
            and so a legal implementation is to simply implement WFI as a NOP.
          - If the implementation does not stall the hart on execution of the instruction,
            then the interrupt will be taken on some instruction in the idle loop
            containing the WFI, and on a simple return from the handler, the idle
            loop will resume execution.
          - The WFI instruction can also be executed when interrupts are disabled
          - The operation of WFI must be unaffected by the global interrupt bits in
            mstatus (MIE and SIE) and the delegation register mideleg If the event
            that causes the hart to resume execution does not cause an interrupt to
            be taken, execution will resume at pc + 4, and software must determine
            what action to take, including looping back to repeat the WFI if there
            was no actionable event.
          - By allowing wakeup when interrupts are disabled, an alternate entry point
            to an interrupt handler can be called that does not require saving the
            current context, as the current context can be saved or discarded before
            the WFI is executed.
          - As implementations are free to implement WFI as a NOP, software must explicitly
            check for any relevant pending but disabled interrupts in the code following
            an WFI, and should loop back to the WFI if no suitable interrupt was detected
          - The operation of WFI is unaffected by the delegation register settings.
          - WFI is defined so that an implementation can trap into a higher privilege
            mode, either immediately on encountering the WFI or after some interval
            to initiate a machine-mode transition to a lower power state, for example.
  csrrw:
    opcode:
    - csrrw
    - rd
    - rs1
    - imm12
    - 14..12=1
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The CSRRW (Atomic Read/Write CSR) instruction atomically swaps values
            in the CSRs and integer registers
          - CSRRW reads the old value of the CSR, zero-extends the value to XLEN bits,
            then writes it to integer register rd
          - A CSRRW with rs1 = x0 will attempt to write zero to the destination CSR.
          - The assembler pseudoinstruction to write a CSR, CSRW csr, rs1 , is encoded
            as CSRRW x0, csr, rs1 , while CSRWI csr, uimm , is encoded as CSRRWI x0,
            csr, uimm .
  csrrs:
    opcode:
    - csrrs
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The CSRRS (Atomic Read and Set Bits in CSR) instruction reads the value
            of the CSR, zero-extends the value to XLEN bits, and writes it to integer
            register rd
          - For both CSRRS and CSRRC, if rs1 = x0 , then the instruction will not
            write to the CSR at all, and so shall not cause any of the side effects
            that might otherwise occur on a CSR write, such as raising illegal instruction
            exceptions on accesses to read-only CSRs
          - Both CSRRS and CSRRC always read the addressed CSR and cause any read
            side effects regardless of rs1 and rd fields
          - The CSRRS and CSRRC instructions have same behavior so are shown as CSRR
          - The assembler pseudoinstruction to read a CSR, CSRR rd, csr , is encoded
            as CSRRS rd, csr, x0
      hypervisor:
        "#sec:hinterruptregs":
          text:
          - However, the value used in the read-modify-write sequence of a CSRRS or
            CSRRC instruction contains only the software-writable VSEIP bit, ignoring
            other interrupt sources.
        "#machine-interrupt-registers-mip-and-mie":
          text:
          - Instructions CSRRS and CSRRC have the same modified behavior for bit VSEIP
            in mip as they do for VSEIP in hip , as described in Section&Acirc;&nbsp;
      machine:
        "#machine-interrupt-registers-mip-and-mie":
          text:
          - However, the value used in the read-modify-write sequence of a CSRRS or
            CSRRC instruction contains only the software-writable SEIP bit, ignoring
            the interrupt value from the external interrupt controller.
  csrrc:
    opcode:
    - csrrc
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The CSRRC (Atomic Read and Clear Bits in CSR) instruction reads the value
            of the CSR, zero-extends the value to XLEN bits, and writes it to integer
            register rd
  csrrwi:
    opcode:
    - csrrwi
    - rd
    - rs1
    - imm12
    - 14..12=5
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The CSRRWI, CSRRSI, and CSRRCI variants are similar to CSRRW, CSRRS, and
            CSRRC respectively, except they update the CSR using an XLEN-bit value
            obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field
            encoded in the rs1 field instead of a value from an integer register
          - For CSRRWI, if rd = x0 , then the instruction shall not read the CSR and
            shall not cause any of the side effects that might occur on a CSR read
  csrrsi:
    opcode:
    - csrrsi
    - rd
    - rs1
    - imm12
    - 14..12=6
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these instructions
            will not write to the CSR, and shall not cause any of the side effects
            that might otherwise occur on a CSR write
          - Both CSRRSI and CSRRCI will always read the CSR and cause any read side
            effects regardless of rd and rs1 fields.
  csrrci:
    opcode:
    - csrrci
    - rd
    - rs1
    - imm12
    - 14..12=7
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
  hfence.bvma:
    opcode:
    - hfence.bvma
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x11
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *8
  hfence.gvma:
    opcode:
    - hfence.gvma
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x51
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *8
    main_desc: hypervisor
    main_id: "#sec:hgatp"
    desc:
      hypervisor:
        "#sec:hgatp":
          text:
          - "If the new virtual machine&acirc;\x80\x99s guest physical page tables
            have been modified, it may be necessary to execute an HFENCE.GVMA instruction
            (see Section&Acirc;&nbsp;"
        "#sec:hfence.vma":
          text:
          - The hypervisor memory-management fence instructions, HFENCE.GVMA and HFENCE.VVMA,
            are valid only in HS-mode when mstatus .TVM=0, or in M-mode (irrespective
            of mstatus .TVM)
          - "), except applying to the guest-physical memory-management data structures
            controlled by CSR hgatp (HFENCE.GVMA) or the VS-level memory-management
            data structures controlled by CSR vsatp satp (either the HS-level satp
            when V=0 or vsatp when V=1)."
          - Executing an HFENCE.GVMA instruction guarantees that any previous stores
            already visible to the current hart are ordered before all subsequent
            implicit reads by that hart of guest-physical memory-management data structures
            done for instructions that follow the HFENCE.GVMA
          - For HFENCE.GVMA, a guest physical address specified in rs1 is shifted
            right by 2&Acirc;&nbsp;bits to accommodate addresses wider than the current
            XLEN
          - Simpler implementations of HFENCE.GVMA can ignore the guest physical address
            in rs1 and the VMID value in rs2 and always perform a global fence for
            the guest-physical memory management of all virtual machines, or even
            a global fence for all memory-management data structures.
        "#memory-management-fences":
          text:
          - Hypervisor instructions HFENCE.GVMA and HFENCE.VVMA provide additional
            memory-management fences to complement SFENCE.VMA
          - When PMP settings are modified in a manner that affects either the physical
            memory that holds guest-physical page tables or the physical memory to
            which guest-physical page tables point, an HFENCE.GVMA instruction with
            rs1 = x0 and rs2 = x0 must be executed in M-mode after the PMP CSRs are
            written
  fadd.s:
    opcode:
    - fadd.s
    - rd
    - rs1
    - rs2
    - 31..27=0x00
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FADD.S and FMUL.S perform single-precision floating-point addition and
            multiplication respectively, between rs1 and rs2
  fsub.s:
    opcode:
    - fsub.s
    - rd
    - rs1
    - rs2
    - 31..27=0x01
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FSUB.S performs the single-precision floating-point subtraction of rs2
            from rs1
  fmul.s:
    opcode:
    - fmul.s
    - rd
    - rs1
    - rs2
    - 31..27=0x02
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fdiv.s:
    opcode:
    - fdiv.s
    - rd
    - rs1
    - rs2
    - 31..27=0x03
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FDIV.S performs the single-precision floating-point division of rs1 by
            rs2
  fsgnj.s:
    opcode:
    - fsgnj.s
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1
          - Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction FMV.S
            rx, ry ); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry ); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry ).
  fsgnjn.s:
    opcode:
    - fsgnjn.s
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=1
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fsgnjx.s:
    opcode:
    - fsgnjx.s
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=2
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fmin.s:
    opcode:
    - fmin.s
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - Floating-point minimum-number and maximum-number instructions FMIN.S and
            FMAX.S write, respectively, the smaller or larger of rs1 and rs2 rd
          - Note that in version 2.2 of the F extension, the FMIN.S and FMAX.S instructions
            were amended to implement the proposed IEEE 754-201x minimumNumber and
            maximumNumber operations, rather than the IEEE 754-2008 minNum and maxNum
            operations
  fmax.s:
    opcode:
    - fmax.s
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=1
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fsqrt.s:
    opcode:
    - fsqrt.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x0B
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FSQRT.S computes the square root of rs1
  fadd.d:
    opcode:
    - fadd.d
    - rd
    - rs1
    - rs2
    - 31..27=0x00
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FADD.S and FMUL.S perform single-precision floating-point addition and
            multiplication respectively, between rs1 and rs2
  fsub.d:
    opcode:
    - fsub.d
    - rd
    - rs1
    - rs2
    - 31..27=0x01
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FSUB.S performs the single-precision floating-point subtraction of rs2
            from rs1
  fmul.d:
    opcode:
    - fmul.d
    - rd
    - rs1
    - rs2
    - 31..27=0x02
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fdiv.d:
    opcode:
    - fdiv.d
    - rd
    - rs1
    - rs2
    - 31..27=0x03
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FDIV.S performs the single-precision floating-point division of rs1 by
            rs2
  fsgnj.d:
    opcode:
    - fsgnj.d
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=0
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.D,
            FSGNJN.D, and FSGNJX.D are defined analogously to the single-precision
            sign-injection instruction.
  fsgnjn.d:
    opcode:
    - fsgnjn.d
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=1
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fsgnjx.d:
    opcode:
    - fsgnjx.d
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=2
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fmin.d:
    opcode:
    - fmin.d
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=0
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - Floating-point minimum-number and maximum-number instructions FMIN.S and
            FMAX.S write, respectively, the smaller or larger of rs1 and rs2 rd
          - Note that in version 2.2 of the F extension, the FMIN.S and FMAX.S instructions
            were amended to implement the proposed IEEE 754-201x minimumNumber and
            maximumNumber operations, rather than the IEEE 754-2008 minNum and maxNum
            operations
  fmax.d:
    opcode:
    - fmax.d
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=1
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fcvt.s.d:
    opcode:
    - fcvt.s.d
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x08
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - The double-precision to single-precision and single-precision to double-precision
            conversion instructions, FCVT.S.D and FCVT.D.S, are encoded in the OP-FP
            major opcode space and both the source and destination are floating-point
            registers
          - FCVT.S.D rounds according to the RM field; FCVT.D.S will never round.
  fcvt.d.s:
    opcode:
    - fcvt.d.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x08
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fsqrt.d:
    opcode:
    - fsqrt.d
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x0B
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FSQRT.S computes the square root of rs1
  fadd.q:
    opcode:
    - fadd.q
    - rd
    - rs1
    - rs2
    - 31..27=0x00
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FADD.S and FMUL.S perform single-precision floating-point addition and
            multiplication respectively, between rs1 and rs2
  fsub.q:
    opcode:
    - fsub.q
    - rd
    - rs1
    - rs2
    - 31..27=0x01
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FSUB.S performs the single-precision floating-point subtraction of rs2
            from rs1
  fmul.q:
    opcode:
    - fmul.q
    - rd
    - rs1
    - rs2
    - 31..27=0x02
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fdiv.q:
    opcode:
    - fdiv.q
    - rd
    - rs1
    - rs2
    - 31..27=0x03
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FDIV.S performs the single-precision floating-point division of rs1 by
            rs2
  fsgnj.q:
    opcode:
    - fsgnj.q
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=0
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.Q,
            FSGNJN.Q, and FSGNJX.Q are defined analogously to the double-precision
            sign-injection instruction.
  fsgnjn.q:
    opcode:
    - fsgnjn.q
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=1
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fsgnjx.q:
    opcode:
    - fsgnjx.q
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=2
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fmin.q:
    opcode:
    - fmin.q
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=0
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - Floating-point minimum-number and maximum-number instructions FMIN.S and
            FMAX.S write, respectively, the smaller or larger of rs1 and rs2 rd
          - Note that in version 2.2 of the F extension, the FMIN.S and FMAX.S instructions
            were amended to implement the proposed IEEE 754-201x minimumNumber and
            maximumNumber operations, rather than the IEEE 754-2008 minNum and maxNum
            operations
  fmax.q:
    opcode:
    - fmax.q
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=1
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  fcvt.s.q:
    opcode:
    - fcvt.s.q
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x08
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - FCVT.S.Q or FCVT.Q.S converts a quad-precision floating-point number to
            a single-precision floating-point number, or vice-versa, respectively
  fcvt.q.s:
    opcode:
    - fcvt.q.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x08
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fcvt.d.q:
    opcode:
    - fcvt.d.q
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x08
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - FCVT.D.Q or FCVT.Q.D converts a quad-precision floating-point number to
            a double-precision floating-point number, or vice-versa, respectively.
  fcvt.q.d:
    opcode:
    - fcvt.q.d
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x08
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fsqrt.q:
    opcode:
    - fsqrt.q
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x0B
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FSQRT.S computes the square root of rs1
  fle.s:
    opcode:
    - fle.s
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  flt.s:
    opcode:
    - flt.s
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=1
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: f
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      f:
        "#single-precision-floating-point-compare-instructions":
          text:
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN'
  feq.s:
    opcode:
    - feq.s
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=2
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: f
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      f:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (
          - 'FEQ.S performs a quiet comparison: it only sets the invalid operation
            exception flag if either input is a signaling NaN'
  fle.d:
    opcode:
    - fle.d
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=0
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  flt.d:
    opcode:
    - flt.d
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=1
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: d
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      d:
        "#single-precision-floating-point-compare-instructions":
          text:
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN'
  feq.d:
    opcode:
    - feq.d
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=2
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: d
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      d:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (
          - 'FEQ.S performs a quiet comparison: it only sets the invalid operation
            exception flag if either input is a signaling NaN'
  fle.q:
    opcode:
    - fle.q
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=0
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
  flt.q:
    opcode:
    - flt.q
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=1
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: q
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      q:
        "#single-precision-floating-point-compare-instructions":
          text:
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN'
  feq.q:
    opcode:
    - feq.q
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=2
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *5
    main_desc: q
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      q:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (
          - 'FEQ.S performs a quiet comparison: it only sets the invalid operation
            exception flag if either input is a signaling NaN'
  fcvt.w.s:
    opcode:
    - fcvt.w.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x18
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - FCVT.W.S or FCVT.L.S converts a floating-point number in floating-point
            register rs1 to a signed 32-bit or 64-bit integer, respectively, in integer
            register rd
          - FCVT.W.S
  fcvt.wu.s:
    opcode:
    - fcvt.wu.s
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x18
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - FCVT.WU.S, FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or
            from unsigned integer values
          - FCVT.WU.S
  fcvt.l.s:
    opcode:
    - fcvt.l.s
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x18
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - FCVT.L.S
  fcvt.lu.s:
    opcode:
    - fcvt.lu.s
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x18
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - FCVT.LU.S
  fmv.x.w:
    opcode:
    - fmv.x.w
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - FMV.X.W moves the single-precision value in floating-point register rs1
            rd
  fclass.s:
    opcode:
    - fclass.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=1
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: f
    main_id: "#single-precision-floating-point-classify-instruction"
    desc:
      f:
        "#single-precision-floating-point-classify-instruction":
          text:
          - The FCLASS.S instruction examines the value in floating-point register
            rs1 and writes to integer register rd a 10-bit mask that indicates the
            class of the floating-point number
          - FCLASS.S does not set the floating-point exception flags
  fcvt.w.d:
    opcode:
    - fcvt.w.d
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x18
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - FCVT.W.D or FCVT.L.D converts a double-precision floating-point number
            in floating-point register rs1 to a signed 32-bit or 64-bit integer, respectively,
            in integer register rd
  fcvt.wu.d:
    opcode:
    - fcvt.wu.d
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x18
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU variants convert to or
            from unsigned integer values
  fcvt.l.d:
    opcode:
    - fcvt.l.d
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x18
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fcvt.lu.d:
    opcode:
    - fcvt.lu.d
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x18
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fmv.x.d:
    opcode:
    - fmv.x.d
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=0
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - FMV.X.D moves the double-precision value in floating-point register rs1
            to a representation in IEEE 754-2008 standard encoding in integer register
            rd
          - FMV.X.D and FMV.D.X do not modify the bits being transferred; in particular,
            the payloads of non-canonical NaNs are preserved.
  fclass.d:
    opcode:
    - fclass.d
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=1
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: d
    main_id: "#double-precision-floating-point-classify-instruction"
    desc:
      d:
        "#double-precision-floating-point-classify-instruction":
          text:
          - The double-precision floating-point classify instruction, FCLASS.D, is
            defined analogously to its single-precision counterpart, but operates
            on double-precision operands.
  fcvt.w.q:
    opcode:
    - fcvt.w.q
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x18
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - FCVT.W.Q or FCVT.L.Q converts a quad-precision floating-point number to
            a signed 32-bit or 64-bit integer, respectively
  fcvt.wu.q:
    opcode:
    - fcvt.wu.q
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x18
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - FCVT.WU.Q, FCVT.LU.Q, FCVT.Q.WU, and FCVT.Q.LU variants convert to or
            from unsigned integer values
  fcvt.l.q:
    opcode:
    - fcvt.l.q
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x18
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fcvt.lu.q:
    opcode:
    - fcvt.lu.q
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x18
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fmv.x.q:
    opcode:
    - fmv.x.q
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=0
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: rv128
    main_id: "#rv128"
    desc:
      rv128:
        "#rv128":
          text:
          - The floating-point instruction set is unchanged, although the 128-bit
            Q floating-point extension can now support FMV.X.Q and FMV.Q.X instructions,
            together with additional FCVT instructions to and from the T (128-bit)
            integer format.
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - FMV.X.Q and FMV.Q.X instructions are not provided in RV32 or RV64, so
            quad-precision bit patterns must be moved to the integer registers via
            memory.
          - RV128 will support FMV.X.Q and FMV.Q.X in the Q extension.
  fclass.q:
    opcode:
    - fclass.q
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=1
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: q
    main_id: "#quad-precision-floating-point-classify-instruction"
    desc:
      q:
        "#quad-precision-floating-point-classify-instruction":
          text:
          - The quad-precision floating-point classify instruction, FCLASS.Q, is defined
            analogously to its double-precision counterpart, but operates on quad-precision
            operands.
  fcvt.s.w:
    opcode:
    - fcvt.s.w
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1A
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - FCVT.S.W or FCVT.S.L converts a 32-bit or 64-bit signed integer, respectively,
            in integer register rs1 into a floating-point number in floating-point
            register rd
          - A floating-point register can be initialized to floating-point positive
            zero using FCVT.S.W rd , x0 , which will never set any exception flags.
  fcvt.s.wu:
    opcode:
    - fcvt.s.wu
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x1A
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fcvt.s.l:
    opcode:
    - fcvt.s.l
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x1A
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - FCVT.L[U].S and FCVT.S.L[U] are RV64-only instructions
  fcvt.s.lu:
    opcode:
    - fcvt.s.lu
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x1A
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fmv.w.x:
    opcode:
    - fmv.w.x
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1E
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - FMV.W.X moves the single-precision value encoded in IEEE 754-2008 standard
            encoding from the lower 32 bits of integer register rs1 to the floating-point
            register rd
          - The FMV.W.X and FMV.X.W instructions were previously called FMV.S.X and
            FMV.X.S
  fcvt.d.w:
    opcode:
    - fcvt.d.w
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1A
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively,
            in integer register rs1 into a double-precision floating-point number
            in floating-point register rd
          - Note FCVT.D.W[U] always produces an exact result and is unaffected by
            rounding mode.
  fcvt.d.wu:
    opcode:
    - fcvt.d.wu
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x1A
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fcvt.d.l:
    opcode:
    - fcvt.d.l
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x1A
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - FCVT.L[U].D and FCVT.D.L[U] are RV64-only instructions
  fcvt.d.lu:
    opcode:
    - fcvt.d.lu
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x1A
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fmv.d.x:
    opcode:
    - fmv.d.x
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1E
    - 14..12=0
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - FMV.D.X moves the double-precision value encoded in IEEE 754-2008 standard
            encoding from the integer register rs1 to the floating-point register
            rd .
  fcvt.q.w:
    opcode:
    - fcvt.q.w
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1A
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - FCVT.Q.W or FCVT.Q.L converts a 32-bit or 64-bit signed integer, respectively,
            into a quad-precision floating-point number
  fcvt.q.wu:
    opcode:
    - fcvt.q.wu
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x1A
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fcvt.q.l:
    opcode:
    - fcvt.q.l
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x1A
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - FCVT.L[U].Q and FCVT.Q.L[U] are RV64-only instructions.
  fcvt.q.lu:
    opcode:
    - fcvt.q.lu
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x1A
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  fmv.q.x:
    opcode:
    - fmv.q.x
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1E
    - 14..12=0
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *4
  flw:
    opcode:
    - flw
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x01
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: f
    main_id: "#single-precision-load-and-store-instructions"
    desc:
      f:
        "#single-precision-load-and-store-instructions":
          text:
          - The FLW instruction loads a single-precision floating-point value from
            memory into floating-point register rd
          - FLW and FSW are only guaranteed to execute atomically if the effective
            address is naturally aligned.
          - FLW and FSW do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved.
      v:
        "#_vector_load_store_width_encoding":
          text:
          - FLW/FSW
  fld:
    opcode:
    - fld
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x01
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: d
    main_id: "#fld_fsd"
    desc:
      d:
        "#fld_fsd":
          text:
          - The FLD instruction loads a double-precision floating-point value from
            memory into floating-point register rd
          - FLD and FSD are only guaranteed to execute atomically if the effective
            address is naturally aligned and XLEN
          - FLD and FSD do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved.
      v:
        "#_vector_load_store_width_encoding":
          text:
          - FLD/FSD
  flq:
    opcode:
    - flq
    - rd
    - rs1
    - imm12
    - 14..12=4
    - 6..2=0x01
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *3
    main_desc: q
    main_id: "#quad-precision-load-and-store-instructions"
    desc:
      q:
        "#quad-precision-load-and-store-instructions":
          text:
          - FLQ and FSQ are only guaranteed to execute atomically if the effective
            address is naturally aligned and XLEN=128.
          - FLQ and FSQ do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved.
      v:
        "#_vector_load_store_width_encoding":
          text:
          - FLQ/FSQ
  fsw:
    opcode:
    - fsw
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=2
    - 6..2=0x09
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *6
    main_desc: f
    main_id: "#single-precision-load-and-store-instructions"
    desc:
      f:
        "#single-precision-load-and-store-instructions":
          text:
          - FSW stores a single-precision value from floating-point register rs2 to
            memory.
  fsd:
    opcode:
    - fsd
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=3
    - 6..2=0x09
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *6
    main_desc: d
    main_id: "#fld_fsd"
    desc:
      d:
        "#fld_fsd":
          text:
          - FSD stores a double-precision value from the floating-point registers
            to memory
      machine:
        "#priority-and-matching-logic":
          text:
          - The same behavior may manifest for floating-point stores wider than XLEN
            bits (e.g., the FSD instruction in RV32D), even when the store address
            is naturally aligned.
  fsq:
    opcode:
    - fsq
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=4
    - 6..2=0x09
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *6
  fmadd.s:
    opcode:
    - fmadd.s
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=0
    - 6..2=0x10
    - 1..0=3
    opcode_group: opcodes
    opcode_args: &9
    - rd
    - rs1
    - rs2
    - rs3
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FMADD.S multiplies the values in rs1 and rs2 , adds the value in rs3 ,
            and writes the final result to rd
          - "FMADD.S computes (rs1 &Atilde;\x97 rs2)+rs3 ."
  fmsub.s:
    opcode:
    - fmsub.s
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=0
    - 6..2=0x11
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FMSUB.S multiplies the values in rs1 and rs2 , subtracts the value in
            rs3 , and writes the final result to rd
          - "FMSUB.S computes (rs1 &Atilde;\x97 rs2)-rs3 ."
  fnmsub.s:
    opcode:
    - fnmsub.s
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=0
    - 6..2=0x12
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FNMSUB.S multiplies the values in rs1 and rs2 , negates the product, adds
            the value in rs3 , and writes the final result to rd
          - "FNMSUB.S computes -(rs1 &Atilde;\x97 rs2)+rs3 ."
  fnmadd.s:
    opcode:
    - fnmadd.s
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=0
    - 6..2=0x13
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FNMADD.S multiplies the values in rs1 and rs2 , negates the product, subtracts
            the value in rs3 , and writes the final result to rd
          - "FNMADD.S computes -(rs1 &Atilde;\x97 rs2)-rs3 ."
  fmadd.d:
    opcode:
    - fmadd.d
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=1
    - 6..2=0x10
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FMADD.S multiplies the values in rs1 and rs2 , adds the value in rs3 ,
            and writes the final result to rd
          - "FMADD.S computes (rs1 &Atilde;\x97 rs2)+rs3 ."
  fmsub.d:
    opcode:
    - fmsub.d
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=1
    - 6..2=0x11
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FMSUB.S multiplies the values in rs1 and rs2 , subtracts the value in
            rs3 , and writes the final result to rd
          - "FMSUB.S computes (rs1 &Atilde;\x97 rs2)-rs3 ."
  fnmsub.d:
    opcode:
    - fnmsub.d
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=1
    - 6..2=0x12
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FNMSUB.S multiplies the values in rs1 and rs2 , negates the product, adds
            the value in rs3 , and writes the final result to rd
          - "FNMSUB.S computes -(rs1 &Atilde;\x97 rs2)+rs3 ."
  fnmadd.d:
    opcode:
    - fnmadd.d
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=1
    - 6..2=0x13
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FNMADD.S multiplies the values in rs1 and rs2 , negates the product, subtracts
            the value in rs3 , and writes the final result to rd
          - "FNMADD.S computes -(rs1 &Atilde;\x97 rs2)-rs3 ."
  fmadd.q:
    opcode:
    - fmadd.q
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=3
    - 6..2=0x10
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FMADD.S multiplies the values in rs1 and rs2 , adds the value in rs3 ,
            and writes the final result to rd
          - "FMADD.S computes (rs1 &Atilde;\x97 rs2)+rs3 ."
  fmsub.q:
    opcode:
    - fmsub.q
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=3
    - 6..2=0x11
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FMSUB.S multiplies the values in rs1 and rs2 , subtracts the value in
            rs3 , and writes the final result to rd
          - "FMSUB.S computes (rs1 &Atilde;\x97 rs2)-rs3 ."
  fnmsub.q:
    opcode:
    - fnmsub.q
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=3
    - 6..2=0x12
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FNMSUB.S multiplies the values in rs1 and rs2 , negates the product, adds
            the value in rs3 , and writes the final result to rd
          - "FNMSUB.S computes -(rs1 &Atilde;\x97 rs2)+rs3 ."
  fnmadd.q:
    opcode:
    - fnmadd.q
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=3
    - 6..2=0x13
    - 1..0=3
    opcode_group: opcodes
    opcode_args: *9
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FNMADD.S multiplies the values in rs1 and rs2 , negates the product, subtracts
            the value in rs3 , and writes the final result to rd
          - "FNMADD.S computes -(rs1 &Atilde;\x97 rs2)-rs3 ."
  "@custom0":
    opcode:
    - "@custom0"
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x02
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom0.rs1":
    opcode:
    - "@custom0.rs1"
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x02
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom0.rs1.rs2":
    opcode:
    - "@custom0.rs1.rs2"
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x02
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom0.rd":
    opcode:
    - "@custom0.rd"
    - rd
    - rs1
    - imm12
    - 14..12=4
    - 6..2=0x02
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom0.rd.rs1":
    opcode:
    - "@custom0.rd.rs1"
    - rd
    - rs1
    - imm12
    - 14..12=6
    - 6..2=0x02
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom0.rd.rs1.rs2":
    opcode:
    - "@custom0.rd.rs1.rs2"
    - rd
    - rs1
    - imm12
    - 14..12=7
    - 6..2=0x02
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom1":
    opcode:
    - "@custom1"
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x0A
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom1.rs1":
    opcode:
    - "@custom1.rs1"
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x0A
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom1.rs1.rs2":
    opcode:
    - "@custom1.rs1.rs2"
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x0A
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom1.rd":
    opcode:
    - "@custom1.rd"
    - rd
    - rs1
    - imm12
    - 14..12=4
    - 6..2=0x0A
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom1.rd.rs1":
    opcode:
    - "@custom1.rd.rs1"
    - rd
    - rs1
    - imm12
    - 14..12=6
    - 6..2=0x0A
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom1.rd.rs1.rs2":
    opcode:
    - "@custom1.rd.rs1.rs2"
    - rd
    - rs1
    - imm12
    - 14..12=7
    - 6..2=0x0A
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom2":
    opcode:
    - "@custom2"
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x16
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom2.rs1":
    opcode:
    - "@custom2.rs1"
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x16
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom2.rs1.rs2":
    opcode:
    - "@custom2.rs1.rs2"
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x16
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom2.rd":
    opcode:
    - "@custom2.rd"
    - rd
    - rs1
    - imm12
    - 14..12=4
    - 6..2=0x16
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom2.rd.rs1":
    opcode:
    - "@custom2.rd.rs1"
    - rd
    - rs1
    - imm12
    - 14..12=6
    - 6..2=0x16
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom2.rd.rs1.rs2":
    opcode:
    - "@custom2.rd.rs1.rs2"
    - rd
    - rs1
    - imm12
    - 14..12=7
    - 6..2=0x16
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom3":
    opcode:
    - "@custom3"
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x1E
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom3.rs1":
    opcode:
    - "@custom3.rs1"
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x1E
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom3.rs1.rs2":
    opcode:
    - "@custom3.rs1.rs2"
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x1E
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom3.rd":
    opcode:
    - "@custom3.rd"
    - rd
    - rs1
    - imm12
    - 14..12=4
    - 6..2=0x1E
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom3.rd.rs1":
    opcode:
    - "@custom3.rd.rs1"
    - rd
    - rs1
    - imm12
    - 14..12=6
    - 6..2=0x1E
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@custom3.rd.rs1.rs2":
    opcode:
    - "@custom3.rd.rs1.rs2"
    - rd
    - rs1
    - imm12
    - 14..12=7
    - 6..2=0x1E
    - 1..0=3
    opcode_group: opcodes-custom
    opcode_args: *3
    main_desc: custom
    main_id: "#"
    desc:
      custom:
        "#":
          text: []
  "@slli.rv32":
    opcode:
    - "@slli.rv32"
    - rd
    - rs1
    - 31..25=0
    - shamtw
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *4
  "@srli.rv32":
    opcode:
    - "@srli.rv32"
    - rd
    - rs1
    - 31..25=0
    - shamtw
    - 14..12=5
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *4
  "@srai.rv32":
    opcode:
    - "@srai.rv32"
    - rd
    - rs1
    - 31..25=32
    - shamtw
    - 14..12=5
    - 6..2=0x04
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *4
  "@frflags":
    opcode:
    - "@frflags"
    - rd
    - 19..15=0
    - 31..20=0x001
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: &10
    - rd
  "@fsflags":
    opcode:
    - "@fsflags"
    - rd
    - rs1
    - 31..20=0x001
    - 14..12=1
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *4
  "@fsflagsi":
    opcode:
    - "@fsflagsi"
    - rd
    - zimm
    - 31..20=0x001
    - 14..12=5
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: &11
    - rd
    - zimm
  "@frrm":
    opcode:
    - "@frrm"
    - rd
    - 19..15=0
    - 31..20=0x002
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *10
  "@fsrm":
    opcode:
    - "@fsrm"
    - rd
    - rs1
    - 31..20=0x002
    - 14..12=1
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *4
  "@fsrmi":
    opcode:
    - "@fsrmi"
    - rd
    - zimm
    - 31..20=0x002
    - 14..12=5
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *11
  "@fscsr":
    opcode:
    - "@fscsr"
    - rd
    - rs1
    - 31..20=0x003
    - 14..12=1
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *4
  "@frcsr":
    opcode:
    - "@frcsr"
    - rd
    - 19..15=0
    - 31..20=0x003
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *10
  "@rdcycle":
    opcode:
    - "@rdcycle"
    - rd
    - 19..15=0
    - 31..20=0xC00
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *10
  "@rdtime":
    opcode:
    - "@rdtime"
    - rd
    - 19..15=0
    - 31..20=0xC01
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *10
  "@rdinstret":
    opcode:
    - "@rdinstret"
    - rd
    - 19..15=0
    - 31..20=0xC02
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *10
  "@rdcycleh":
    opcode:
    - "@rdcycleh"
    - rd
    - 19..15=0
    - 31..20=0xC80
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *10
  "@rdtimeh":
    opcode:
    - "@rdtimeh"
    - rd
    - 19..15=0
    - 31..20=0xC81
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *10
  "@rdinstreth":
    opcode:
    - "@rdinstreth"
    - rd
    - 19..15=0
    - 31..20=0xC82
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *10
  "@scall":
    opcode:
    - "@scall"
    - 11..7=0
    - 19..15=0
    - 31..20=0x000
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *7
  "@sbreak":
    opcode:
    - "@sbreak"
    - 11..7=0
    - 19..15=0
    - 31..20=0x001
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *7
  "@fmv.x.s":
    opcode:
    - "@fmv.x.s"
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *4
  "@fmv.s.x":
    opcode:
    - "@fmv.s.x"
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1E
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *4
  "@fence.tso":
    opcode:
    - "@fence.tso"
    - 31..28=8
    - 27..24=3
    - 23..20=3
    - 19..15=ignore
    - 14..12=0
    - 11..7=ignore
    - 6..2=0x03
    - 1..0=3
    opcode_group: opcodes-pseudo
    opcode_args: *7
  c.addi4spn:
    opcode:
    - c.addi4spn
    - 1..0=0
    - 15..13=0
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - "In the standard RISC-V calling convention, the stack pointer sp C.ADDI4SPN
            is a CIW-format instruction that adds a zero -extended non-zero immediate,
            scaled by 4, to the stack pointer, x2 , and writes the result to rd&acirc;\x80\x86'"
          - "C.ADDI4SPN is only valid when nzuimm &acirc;\x89&nbsp;"
  c.fld:
    opcode:
    - c.fld
    - 1..0=0
    - 15..13=1
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.lq
    - for
    - RV128
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - "C.FLD is an RV32DC/RV64DC-only instruction that loads a double-precision
            floating-point value from memory into floating-point register rd&acirc;\x80\x86
            &acirc;\x80&sup2;"
  c.lw:
    opcode:
    - c.lw
    - 1..0=0
    - 15..13=2
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - "C.LW loads a 32-bit value from memory into register rd&acirc;\x80\x86
            &acirc;\x80&sup2;"
  c.flw:
    opcode:
    - c.flw
    - 1..0=0
    - 15..13=3
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.ld
    - for
    - RV64
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - "C.FLW is an RV32FC-only instruction that loads a single-precision floating-point
            value from memory into floating-point register rd&acirc;\x80\x86 &acirc;\x80&sup2;"
  c.fsd:
    opcode:
    - c.fsd
    - 1..0=0
    - 15..13=5
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.sq
    - for
    - RV128
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - "C.FSD is an RV32DC/RV64DC-only instruction that stores a double-precision
            floating-point value in floating-point register rs2&acirc;\x80\x86 &acirc;\x80&sup2;"
  c.sw:
    opcode:
    - c.sw
    - 1..0=0
    - 15..13=6
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - "C.SW stores a 32-bit value in register rs2&acirc;\x80\x86 &acirc;\x80&sup2;"
  c.fsw:
    opcode:
    - c.fsw
    - 1..0=0
    - 15..13=7
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.sd
    - for
    - RV64
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - "C.FSW is an RV32FC-only instruction that stores a single-precision floating-point
            value in floating-point register rs2&acirc;\x80\x86 &acirc;\x80&sup2;"
  c.addi:
    opcode:
    - c.addi
    - 1..0=1
    - 15..13=0
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.ADDI adds the non-zero sign-extended 6-bit immediate to the value in
            register rd then writes the result to rd
          - C.ADDI expands into addi rd, rd, nzimm[5:0]
          - "C.ADDI is only valid when rd &acirc;\x89&nbsp; x0 and nzimm &acirc;\x89&nbsp;"
        "#sec:rvc-hints":
          text:
          - C.ADDI t0 , 0
  c.jal:
    opcode:
    - c.jal
    - 1..0=1
    - 15..13=1
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.addiw
    - for
    - RV64
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#control-transfer-instructions"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - C.JAL is an RV32C-only instruction that performs the same operation as
            C.J, but additionally writes the address of the instruction following
            the jump ( pc +2) to the link register, x1
          - C.JAL expands to jal x1, offset[11:1] .
  c.li:
    opcode:
    - c.li
    - 1..0=1
    - 15..13=2
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-constant-generation-instructions"
    desc:
      c:
        "#integer-constant-generation-instructions":
          text:
          - C.LI loads the sign-extended 6-bit immediate, imm , into register rd
          - C.LI expands into addi rd, x0, imm[5:0]
          - "C.LI is only valid when rd &acirc;\x89&nbsp; x0 ; the code points with
            rd = x0 encode HINTs."
  c.lui:
    opcode:
    - c.lui
    - 1..0=1
    - 15..13=3
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.addi16sp
    - when
    - rd=2
    opcode_group: opcodes-rvc
    opcode_args: &27
    - rd=2
    main_desc: c
    main_id: "#integer-constant-generation-instructions"
    desc:
      c:
        "#integer-constant-generation-instructions":
          text:
          - "C.LUI loads the non-zero 6-bit immediate field into bits 17&acirc;\x80\x9312
            of the destination register, clears the bottom 12 bits, and sign-extends
            bit 17 into all higher bits of the destination"
          - C.LUI expands into lui rd, nzimm[17:12]
          - "C.LUI is only valid when rd &acirc;\x80\x84&acirc;\x89&nbsp;&acirc;\x80\x84{
            x0 , x2 }"
        "#integer-register-immediate-operations":
          text:
          - C.ADDI16SP shares the opcode with C.LUI, but has a destination field of
            x2
  c.srli:
    opcode:
    - c.srli
    - 1..0=1
    - 15..13=4
    - 12=ignore
    - 11..10=0
    - 9..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - "C.SRLI is a CB-format instruction that performs a logical right shift
            of the value in register rd&acirc;\x80\x86 &acirc;\x80&sup2;"
          - "For RV128C, a shift amount of zero is used to encode a shift of 64. Furthermore,
            the shift amount is sign-extended for RV128C, and so the legal shift amounts
            are 1&acirc;\x80\x9331, 64, and 96&acirc;\x80\x93127. C.SRLI expands into
            srli rd&acirc;\x80\x86', rd&acirc;\x80\x86', shamt[5:0] , except for RV128C
            with shamt=0 , which expands to srli rd&acirc;\x80\x86', rd&acirc;\x80\x86',
            64 ."
  c.srai:
    opcode:
    - c.srai
    - 1..0=1
    - 15..13=4
    - 12=ignore
    - 11..10=1
    - 9..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.SRAI is defined analogously to C.SRLI, but instead performs an arithmetic
            right shift
          - "C.SRAI expands to srai rd&acirc;\x80\x86', rd&acirc;\x80\x86', shamt[5:0]
            ."
  c.andi:
    opcode:
    - c.andi
    - 1..0=1
    - 15..13=4
    - 12=ignore
    - 11..10=2
    - 9..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - "C.ANDI is a CB-format instruction that computes the bitwise AND of the
            value in register rd&acirc;\x80\x86 &acirc;\x80&sup2;"
          - ". C.ANDI expands to andi rd&acirc;\x80\x86', rd&acirc;\x80\x86', imm[5:0]
            ."
  c.sub:
    opcode:
    - c.sub
    - 1..0=1
    - 15..13=4
    - 12=0
    - 11..10=3
    - 9..7=ignore
    - 6..5=0
    - 4..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - "C.SUB subtracts the value in register rs2&acirc;\x80\x86 &acirc;\x80&sup2;"
          - ". C.SUB expands into sub rd&acirc;\x80\x86', rd&acirc;\x80\x86', rs2&acirc;\x80\x86'
            ."
  c.xor:
    opcode:
    - c.xor
    - 1..0=1
    - 15..13=4
    - 12=0
    - 11..10=3
    - 9..7=ignore
    - 6..5=1
    - 4..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - "C.XOR computes the bitwise XOR of the values in registers rd&acirc;\x80\x86
            &acirc;\x80&sup2; rs2&acirc;\x80\x86 &acirc;\x80&sup2;"
          - ". C.XOR expands into xor rd&acirc;\x80\x86', rd&acirc;\x80\x86', rs2&acirc;\x80\x86'
            ."
  c.or:
    opcode:
    - c.or
    - 1..0=1
    - 15..13=4
    - 12=0
    - 11..10=3
    - 9..7=ignore
    - 6..5=2
    - 4..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - "C.OR computes the bitwise OR of the values in registers rd&acirc;\x80\x86
            &acirc;\x80&sup2; rs2&acirc;\x80\x86 &acirc;\x80&sup2;"
          - ". C.OR expands into or rd&acirc;\x80\x86', rd&acirc;\x80\x86', rs2&acirc;\x80\x86'
            ."
  c.and:
    opcode:
    - c.and
    - 1..0=1
    - 15..13=4
    - 12=0
    - 11..10=3
    - 9..7=ignore
    - 6..5=3
    - 4..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - "C.AND computes the bitwise AND of the values in registers rd&acirc;\x80\x86
            &acirc;\x80&sup2; rs2&acirc;\x80\x86 &acirc;\x80&sup2;"
          - ". C.AND expands into and rd&acirc;\x80\x86', rd&acirc;\x80\x86', rs2&acirc;\x80\x86'
            ."
  c.subw:
    opcode:
    - c.subw
    - 1..0=1
    - 15..13=4
    - 12=1
    - 11..10=3
    - 9..7=ignore
    - 6..5=0
    - 4..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - "C.SUBW is an RV64C/RV128C-only instruction that subtracts the value in
            register rs2&acirc;\x80\x86 &acirc;\x80&sup2;"
          - ". C.SUBW expands into subw rd&acirc;\x80\x86', rd&acirc;\x80\x86', rs2&acirc;\x80\x86'
            ."
  c.addw:
    opcode:
    - c.addw
    - 1..0=1
    - 15..13=4
    - 12=1
    - 11..10=3
    - 9..7=ignore
    - 6..5=1
    - 4..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - "C.ADDW is an RV64C/RV128C-only instruction that adds the values in registers
            rd&acirc;\x80\x86 &acirc;\x80&sup2;"
          - ". C.ADDW expands into addw rd&acirc;\x80\x86', rd&acirc;\x80\x86', rs2&acirc;\x80\x86'
            ."
  c.j:
    opcode:
    - c.j
    - 1..0=1
    - 15..13=5
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#control-transfer-instructions"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - C.J performs an unconditional control transfer
          - C.J can therefore target a
          - C.J expands to jal x0, offset[11:1] .
  c.beqz:
    opcode:
    - c.beqz
    - 1..0=1
    - 15..13=6
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#control-transfer-instructions"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - C.BEQZ performs conditional control transfers
          - "C.BEQZ takes the branch if the value in register rs1&acirc;\x80\x86 &acirc;\x80&sup2;"
  c.bnez:
    opcode:
    - c.bnez
    - 1..0=1
    - 15..13=7
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#control-transfer-instructions"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - "C.BNEZ is defined analogously, but it takes the branch if rs1&acirc;\x80\x86
            &acirc;\x80&sup2;"
  c.slli:
    opcode:
    - c.slli
    - 1..0=2
    - 15..13=0
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.SLLI is a CI-format instruction that performs a logical left shift of
            the value in register rd then writes the result to rd
          - For RV128C, a shift amount of zero is used to encode a shift of 64. C.SLLI
            expands into slli rd, rd, shamt[5:0] , except for RV128C with shamt=0
            , which expands to slli rd, rd, 64 .
  c.fldsp:
    opcode:
    - c.fldsp
    - 1..0=2
    - 15..13=1
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.lqsp
    - for
    - RV128
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.FLDSP is an RV32DC/RV64DC-only instruction that loads a double-precision
            floating-point value from memory into floating-point register rd
  c.lwsp:
    opcode:
    - c.lwsp
    - 1..0=2
    - 15..13=2
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.LWSP loads a 32-bit value from memory into register rd
          - "C.LWSP is only valid when rd &acirc;\x80\x84&acirc;\x89&nbsp;&acirc;\x80\x84
            x0 ; the code points with rd &acirc;\x80\x84=&acirc;\x80\x84 x0 are reserved."
  c.flwsp:
    opcode:
    - c.flwsp
    - 1..0=2
    - 15..13=3
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.ldsp
    - for
    - RV64
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.FLWSP is an RV32FC-only instruction that loads a single-precision floating-point
            value from memory into floating-point register rd
  c.mv:
    opcode:
    - c.mv
    - 1..0=2
    - 15..13=4
    - 12=0
    - 11..2=ignore
    - "#"
    - "!rs2"
    - "="
    - c.jr
    opcode_group: opcodes-rvc
    opcode_args: &28
    - "!rs2"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - C.MV copies the value in register rs2 into register rd
          - C.MV expands into add rd, x0, rs2
          - "C.MV is only valid when rs2 &acirc;\x80\x84&acirc;\x89&nbsp;&acirc;\x80\x84
            x0 ; the code points with rs2 &acirc;\x80\x84=&acirc;\x80\x84 x0 correspond
            to the C.JR instruction"
          - C.MV expands to a different instruction than the canonical MV pseudoinstruction,
            which instead uses ADDI
          - using register-renaming hardware, may find it more convenient to expand
            C.MV to MV instead of ADD, at slight additional hardware cost.
  c.add:
    opcode:
    - c.add
    - 1..0=2
    - 15..13=4
    - 12=1
    - 11..2=ignore
    - "#"
    - "!rs1"
    - "="
    - c.ebreak;
    - "!rs2=c.jalr"
    opcode_group: opcodes-rvc
    opcode_args: &29
    - "!rs1"
    - "!rs2=c.jalr"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - C.ADD adds the values in registers rd and rs2 and writes the result to
            register rd
          - C.ADD expands into add rd, rd, rs2
          - "C.ADD is only valid when rs2 &acirc;\x80\x84&acirc;\x89&nbsp;&acirc;\x80\x84
            x0 ; the code points with rs2 &acirc;\x80\x84=&acirc;\x80\x84 x0 correspond
            to the C.JALR and C.EBREAK instructions"
        "#sec:rvc-hints":
          text:
          - RVC HINTs are encoded as computational instructions that do not modify
            the architectural state, either because rd = x0 C.ADD x0 , t0 ), or because
            rd is overwritten with a copy of itself (e.g
          - C.ADD x0 , t0 might not encode the same HINT as
  c.fsdsp:
    opcode:
    - c.fsdsp
    - 1..0=2
    - 15..13=5
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.sqsp
    - for
    - RV128
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.FSDSP is an RV32DC/RV64DC-only instruction that stores a double-precision
            floating-point value in floating-point register rs2 to memory
  c.swsp:
    opcode:
    - c.swsp
    - 1..0=2
    - 15..13=6
    - 12=ignore
    - 11..2=ignore
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.SWSP stores a 32-bit value in register rs2 to memory
  c.fswsp:
    opcode:
    - c.fswsp
    - 1..0=2
    - 15..13=7
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.sdsp
    - for
    - RV64
    opcode_group: opcodes-rvc
    opcode_args: *7
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.FSWSP is an RV32FC-only instruction that stores a single-precision floating-point
            value in floating-point register rs2 to memory
  "@c.nop":
    opcode:
    - "@c.nop"
    - 1..0=1
    - 15..13=0
    - 12=0
    - 11..7=0
    - 6..2=0
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.addi16sp":
    opcode:
    - "@c.addi16sp"
    - 1..0=1
    - 15..13=3
    - 12=ignore
    - 11..7=2
    - 6..2=ignore
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.jr":
    opcode:
    - "@c.jr"
    - 1..0=2
    - 15..13=4
    - 12=0
    - 11..7=ignore
    - 6..2=0
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.jalr":
    opcode:
    - "@c.jalr"
    - 1..0=2
    - 15..13=4
    - 12=1
    - 11..7=ignore
    - 6..2=0
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.ebreak":
    opcode:
    - "@c.ebreak"
    - 1..0=2
    - 15..13=4
    - 12=1
    - 11..7=0
    - 6..2=0
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.ld":
    opcode:
    - "@c.ld"
    - 1..0=0
    - 15..13=3
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.flw
    - for
    - RV32
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.sd":
    opcode:
    - "@c.sd"
    - 1..0=0
    - 15..13=7
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.fsw
    - for
    - RV32
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.addiw":
    opcode:
    - "@c.addiw"
    - 1..0=1
    - 15..13=1
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.jal
    - for
    - RV32
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.ldsp":
    opcode:
    - "@c.ldsp"
    - 1..0=2
    - 15..13=3
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.flwsp
    - for
    - RV32
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.sdsp":
    opcode:
    - "@c.sdsp"
    - 1..0=2
    - 15..13=7
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.fswsp
    - for
    - RV32
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.lq":
    opcode:
    - "@c.lq"
    - 1..0=0
    - 15..13=1
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.fld
    - for
    - RV32/64
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.sq":
    opcode:
    - "@c.sq"
    - 1..0=0
    - 15..13=5
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.fsd
    - for
    - RV32/64
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.lqsp":
    opcode:
    - "@c.lqsp"
    - 1..0=2
    - 15..13=1
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.fldsp
    - for
    - RV32/64
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  "@c.sqsp":
    opcode:
    - "@c.sqsp"
    - 1..0=2
    - 15..13=5
    - 12=ignore
    - 11..2=ignore
    - "#"
    - c.fsdsp
    - for
    - RV32/64
    opcode_group: opcodes-rvc-pseudo
    opcode_args: *7
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  vsetvli:
    opcode:
    - vsetvli
    - 31=0
    - zimm11
    - rs1
    - 14..12=0x7
    - rd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: &30
    - zimm11
    - rs1
    - rd
    main_desc: v
    main_id: "#_vector_length_register_code_vl_code"
    desc:
      v:
        "#_vector_length_register_code_vl_code":
          text:
          - vl The XLEN -bit-wide read-only vl CSR can only be updated by the vsetvli
            and vsetvl instructions, and the fault-only-first vector load instruction
            variants.
        "#_vector_instruction_formats":
          text:
          - 0 |        zimm[10:0]      |    rs1   | 1 1 1 |    rd   |1010111| vsetvli
        "#_configuration_setting_instructions":
          text:
          - vsetvli
        "#__code_vsetvli_code_code_vsetvl_code_instructions":
          text:
          - The vsetvli instruction sets the vtype and vl CSRs based on its arguments,
            and writes the new value of vl into rd .
          - The new vtype setting is encoded in the immediate fields of vsetvli and
            in the rs2 register for vsetvl
          - Table 7. AVL used in vsetvli and vsetvl instructions rd rs1 AVL value
          - 'vsetvli rd, rs1, vtypei # rd = new vl, rs1 = AVL, vtypei = new vtype
            setting'
          - 0 |        zimm[10:0]      |    rs1   | 1 1 1 |    rd   |1010111| vsetvli
          - 'vsetvli t0, a0, e8          # SEW= 8, LMUL=1, EDIV=1'
          - 'vsetvli t0, a0, e8,m2       # SEW= 8, LMUL=2, EDIV=1'
          - 'vsetvli t0, a0, e32,m2,d4   # SEW=32, LMUL=2, EDIV=4'
        "#_examples":
          text:
          - 'vsetvli a3, a0, e32,m8  # Use only 32-bit elements'
          - 'vsetvli a3, a0, e16,m4  # vtype = 16-bit integer vectors'
          - 'vsetvli x0, a0, e32,m8  # Operate on 32b values'
        "#_unit_stride_fault_only_first_loads":
          text:
          - 'vsetvli a1, t0, e8  # Vector of bytes of maximum length'
        "#_example_using_vector_mask_instructions":
          text:
          - 'vsetvli x0, t0, e8      # Max length vectors of bytes'
          - 'vsetvli x0, a2, e8   # Vectors of bytes.'
          - 'vsetvli x0, a2, e8,m8   # Vectors of bytes.'
          - 'vsetvli t1, a2, e8,m8   # Vectors of bytes.'
        "#_vector_iota_instruction":
          text:
          - 'vsetvli a5, a0, e32,m8  # 32-bit integers'
        "#_regular_vector_arithmetic_instructions_under_ediv":
          text:
          - 'vsetvli t0, a0, e32,m1,d4  # Vectors of 32-bit elements, divided into
            byte sub-elements'
        "#_vector_reduction_instructions_under_ediv":
          text:
          - 'vsetvli t0, a0, e32,d4  # Vectors of 32-bit elements, divided into byte
            sub-elements'
        "#_vector_floating_point_dot_product_instruction":
          text:
          - 'vsetvli t0, a0, e32,m1,d2  # Vectors of 32-bit elements, divided into
            16b sub-elements'
          - 'vsetvli t0, a0, e64,m1,d4  # Vectors of 64-bit elements, divided into
            16b sub-elements'
        "#_vector_vector_add_example":
          text:
          - 'vsetvli t0, a0, e32 # Set vector length based on 32-bit vectors'
        "#_example_with_mixed_width_mask_and_compute":
          text:
          - 'vsetvli a4, a0, e8,m1  # Byte vector for predicate calc'
          - 'vsetvli x0, a0, e32,m4 # Vector of 32-bit values.'
        "#_memcpy_example":
          text:
          - 'vsetvli t0, a2, e8,m8  # Vectors of 8b'
        "#_conditional_example":
          text:
          - 'vsetvli t0, a0, e16  # Use 16b elements.'
        "#_saxpy_example":
          text:
          - vsetvli a4, a0, e32, m8
        "#_sgemm_example":
          text:
          - 'vsetvli nvl, nt, e32  # 32-bit vectors, LMUL=1'
  vsetvl:
    opcode:
    - vsetvl
    - 31=1
    - 30..25=0x0
    - rs2
    - rs1
    - 14..12=0x7
    - rd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: &31
    - rs2
    - rs1
    - rd
    main_desc: v
    main_id: "#_vector_type_register_code_vtype_code"
    desc:
      v:
        "#_vector_type_register_code_vtype_code":
          text:
          - vtype The read-only XLEN-wide vector type CSR, vtype provides the default
            type used to interpret the contents of the vector register file, and can
            only be updated by vsetvl{i} instructions
          - Allowing updates only via the vsetvl{i} vtype register state
        "#_vector_type_illegal_code_vill_code":
          text:
          - vill The vill bit is used to encode that a previous vsetvl{i} vtype .
        "#_vector_start_index_csr_code_vstart_code":
          text:
          - Note vsetvl{i} , reset the vstart vstart is not modified by vector instructions
            that raise illegal-instruction exceptions.
        "#_state_of_vector_extension_at_reset":
          text:
          - In particular, vtype and vl must have values that can be read and then
            restored with a single vsetvl instruction.
          - Note vsetvl{i} , which will reset vstart
        "#_mapping_across_mixed_width_operations":
          text:
          - Note vsetvl instructions below could have a facility added to dynamically
            select an appropriate LMUL according to the required application vector
            length (AVL) and range of element widths
        "#_vector_instruction_formats":
          text:
          - 1 |   000000    |   rs2    |    rs1   | 1 1 1 |    rd   |1010111| vsetvl
        "#_configuration_setting_instructions":
          text:
          - vsetvl
        "#__code_vsetvli_code_code_vsetvl_code_instructions":
          text:
          - 'vsetvl  rd, rs1, rs2    # rd = new vl, rs1 = AVL, rs2 = new vtype value'
          - 1 |   000000    |   rs2    |    rs1   | 1 1 1 |    rd   |1010111| vsetvl
        "#_constraints_on_setting_code_vl_code":
          text:
          - 'vl The vsetvl{i} instructions first set VLMAX according to the vtype
            vl obeying the following constraints: vl = AVL if AVL &le; VLMAX ceil(AVL
            / 2) &le; vl &le; VLMAX if AVL < (2 * VLMAX) vl = VLMAX if AVL &ge; (2
            * VLMAX) Deterministic on any given implementation for same input AVL
            and VLMAX values'
          - 'These specific properties follow from the prior rules: vl = 0 if AVL
            = 0 vl > 0 if AVL > 0 vl &le; VLMAX vl &le; AVL a value read from vl when
            used as the AVL argument to vsetvl{i} results in the same value in vl
            , provided the resultant VLMAX equals the value of VLMAX at the time that
            vl was read'
          - vsetvl
        "#__code_vsetvl_code_instruction":
          text:
          - The vsetvl variant operates similarly to vsetvli except that it takes
            a vtype value from rs2 and can be used for context restore, and when the
            vtypei field is too small to hold the desired setting.
          - Note x vsetvl
  vlb.v:
    opcode:
    - vlb.v
    - nf
    - 28..26=4
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: &12
    - rs1
    - vd
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - 'vlb.v  vd, (rs1), vm # 8b signed'
        "#_example_with_mixed_width_mask_and_compute":
          text:
          - 'vlb.v v1, (a1)                # Load a[i]'
        "#_memcpy_example":
          text:
          - 'vlb.v v0, (a1)                # Load bytes'
        "#_conditional_example":
          text:
          - 'vlb.v v0, (a1)          # Get x[i], sign-extended to 16b'
  vlh.v:
    opcode:
    - vlh.v
    - nf
    - 28..26=4
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_examples"
    desc:
      v:
        "#_examples":
          text:
          - 'vlh.v v8, (a1)          # Sign-extend 16b load values to 32b elements'
          - 'vlh.v v4, (a1)          # Get 16b vector'
        "#_vector_unit_stride_instructions":
          text:
          - 'vlh.v  vd, (rs1), vm # 16b signed'
        "#_conditional_example":
          text:
          - 'vlh.v v1, (a2), v0.t    # z[i] = a[i] case'
          - 'vlh.v v1, (a3), v0.t    # z[i] = b[i] case'
  vlw.v:
    opcode:
    - vlw.v
    - nf
    - 28..26=4
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - 'vlw.v  vd, (rs1), vm # 32b signed'
        "#_vector_iota_instruction":
          text:
          - 'vlw.v v8, (a1)                # Load input vector'
        "#_vector_vector_add_example":
          text:
          - 'vlw.v v0, (a1)           # Get first vector'
          - 'vlw.v v1, (a2)           # Get second vector'
        "#_example_with_mixed_width_mask_and_compute":
          text:
          - 'vlw.v v4, (a3), v0.t          # Load requested elements of C.'
        "#_saxpy_example":
          text:
          - vlw.v v0, (a1)
          - vlw.v v8, (a2)
        "#_sgemm_example":
          text:
          - vlw.v  v0, (cnp); add ccp, cnp, cstride;
          - vlw.v  v1, (ccp); add ccp, ccp, cstride;
          - vlw.v  v2, (ccp); add ccp, ccp, cstride;
          - vlw.v  v3, (ccp); add ccp, ccp, cstride;
          - vlw.v  v4, (ccp); add ccp, ccp, cstride;
          - vlw.v  v5, (ccp); add ccp, ccp, cstride;
          - vlw.v  v6, (ccp); add ccp, ccp, cstride;
          - vlw.v  v7, (ccp); add ccp, ccp, cstride;
          - vlw.v  v8, (ccp); add ccp, ccp, cstride;
          - vlw.v  v9, (ccp); add ccp, ccp, cstride;
          - vlw.v v10, (ccp); add ccp, ccp, cstride;
          - vlw.v v11, (ccp); add ccp, ccp, cstride;
          - vlw.v v12, (ccp); add ccp, ccp, cstride;
          - vlw.v v13, (ccp); add ccp, ccp, cstride;
          - vlw.v v14, (ccp); add ccp, ccp, cstride;
          - vlw.v v15, (ccp)
          - vlw.v v16, (bkp)
          - 'vlw.v v16, (bkp)            # Get next vector from B matrix, overlap
            loads with jump stalls'
  vle.v:
    opcode:
    - vle.v
    - nf
    - 28..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - 'vle.v  vd, (rs1), vm # SEW'
  vlbu.v:
    opcode:
    - vlbu.v
    - nf
    - 28..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - 'vlbu.v vd, (rs1), vm # 8b unsigned'
  vlhu.v:
    opcode:
    - vlhu.v
    - nf
    - 28..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - 'vlhu.v vd, (rs1), vm # 16b unsigned'
  vlwu.v:
    opcode:
    - vlwu.v
    - nf
    - 28..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - 'vlwu.v vd, (rs1), vm # 32b unsigned'
  vsb.v:
    opcode:
    - vsb.v
    - nf
    - 28..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: &13
    - rs1
    - vs3
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - 'vsb.v  vs3, (rs1), vm  # 8b store'
        "#_example_using_vector_mask_instructions":
          text:
          - 'vsb.v v1, (a2), v0.t    # Write out bytes'
          - 'vsb.v v1, (a3), v0.t    # Write out bytes'
          - 'vsb.v v0, (a3)          # Store zero.'
        "#_memcpy_example":
          text:
          - 'vsb.v v0, (a3)                # Store bytes'
  vsh.v:
    opcode:
    - vsh.v
    - nf
    - 28..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *13
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - 'vsh.v  vs3, (rs1), vm  # 16b store'
        "#_conditional_example":
          text:
          - 'vsh.v v1, (a4)          # Store z'
  vsw.v:
    opcode:
    - vsw.v
    - nf
    - 28..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *13
    main_desc: v
    main_id: "#_examples"
    desc:
      v:
        "#_examples":
          text:
          - 'vsw.v v8, (a2)          # Store vector of 32b results'
          - 'vsw.v v8, (a2)          # Store vector of 32b'
        "#_vector_unit_stride_instructions":
          text:
          - 'vsw.v  vs3, (rs1), vm  # 32b store'
        "#_vector_vector_add_example":
          text:
          - 'vsw.v v2, (a3)           # Store result'
        "#_example_with_mixed_width_mask_and_compute":
          text:
          - 'vsw.v v4, (a2)                # Store b[i].'
        "#_saxpy_example":
          text:
          - vsw.v v8, (a2)
        "#_sgemm_example":
          text:
          - vsw.v  v0, (cnp); add ccp, cnp, cstride;
          - vsw.v  v1, (ccp); add ccp, ccp, cstride;
          - vsw.v  v2, (ccp); add ccp, ccp, cstride;
          - vsw.v  v3, (ccp); add ccp, ccp, cstride;
          - vsw.v  v4, (ccp); add ccp, ccp, cstride;
          - vsw.v  v5, (ccp); add ccp, ccp, cstride;
          - vsw.v  v6, (ccp); add ccp, ccp, cstride;
          - vsw.v  v7, (ccp); add ccp, ccp, cstride;
          - vsw.v  v8, (ccp); add ccp, ccp, cstride;
          - vsw.v  v9, (ccp); add ccp, ccp, cstride;
          - vsw.v v10, (ccp); add ccp, ccp, cstride;
          - vsw.v v11, (ccp); add ccp, ccp, cstride;
          - vsw.v v12, (ccp); add ccp, ccp, cstride;
          - vsw.v v13, (ccp); add ccp, ccp, cstride;
          - vsw.v v14, (ccp); add ccp, ccp, cstride;
          - vsw.v v15, (ccp)
  vse.v:
    opcode:
    - vse.v
    - nf
    - 28..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *13
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - 'vse.v  vs3, (rs1), vm  # SEW store'
  vlsb.v:
    opcode:
    - vlsb.v
    - nf
    - 28..26=6
    - vm
    - rs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: &14
    - rs2
    - rs1
    - vd
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vlsb.v  vd, (rs1), rs2, vm # 8b'
  vlsh.v:
    opcode:
    - vlsh.v
    - nf
    - 28..26=6
    - vm
    - rs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *14
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vlsh.v  vd, (rs1), rs2, vm # 16b'
  vlsw.v:
    opcode:
    - vlsw.v
    - nf
    - 28..26=6
    - vm
    - rs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *14
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vlsw.v  vd, (rs1), rs2, vm # 32b'
  vlse.v:
    opcode:
    - vlse.v
    - nf
    - 28..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *14
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vlse.v  vd, (rs1), rs2, vm  # SEW'
  vlsbu.v:
    opcode:
    - vlsbu.v
    - nf
    - 28..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *14
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vlsbu.v vd, (rs1), rs2, vm # unsigned 8b'
  vlshu.v:
    opcode:
    - vlshu.v
    - nf
    - 28..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *14
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vlshu.v vd, (rs1), rs2, vm # unsigned 16b'
  vlswu.v:
    opcode:
    - vlswu.v
    - nf
    - 28..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *14
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vlswu.v vd, (rs1), rs2, vm # unsigned 32b'
  vssb.v:
    opcode:
    - vssb.v
    - nf
    - 28..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: &15
    - rs2
    - rs1
    - vs3
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vssb.v vs3, (rs1), rs2, vm  # 8b'
  vssh.v:
    opcode:
    - vssh.v
    - nf
    - 28..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *15
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vssh.v vs3, (rs1), rs2, vm  # 16b'
  vssw.v:
    opcode:
    - vssw.v
    - nf
    - 28..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *15
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vssw.v vs3, (rs1), rs2, vm  # 32b'
  vsse.v:
    opcode:
    - vsse.v
    - nf
    - 28..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *15
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - 'vsse.v vs3, (rs1), rs2, vm  # SEW'
  vlxb.v:
    opcode:
    - vlxb.v
    - nf
    - 28..26=7
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: &16
    - vs2
    - rs1
    - vd
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vlxb.v  vd, (rs1), vs2, vm  # 8b'
  vlxh.v:
    opcode:
    - vlxh.v
    - nf
    - 28..26=7
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vlxh.v  vd, (rs1), vs2, vm  # 16b'
  vlxw.v:
    opcode:
    - vlxw.v
    - nf
    - 28..26=7
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vlxw.v  vd, (rs1), vs2, vm  # 32b'
  vlxe.v:
    opcode:
    - vlxe.v
    - nf
    - 28..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vlxe.v  vd, (rs1), vs2, vm  # SEW'
  vlxbu.v:
    opcode:
    - vlxbu.v
    - nf
    - 28..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vlxbu.v vd, (rs1), vs2, vm  # 8b unsigned'
  vlxhu.v:
    opcode:
    - vlxhu.v
    - nf
    - 28..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vlxhu.v vd, (rs1), vs2, vm  # 16b unsigned'
  vlxwu.v:
    opcode:
    - vlxwu.v
    - nf
    - 28..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vlxwu.v vd, (rs1), vs2, vm  # 32b unsigned'
  vsxb.v:
    opcode:
    - vsxb.v
    - nf
    - 28..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: &17
    - vs2
    - rs1
    - vs3
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vsxb.v vs3, (rs1), vs2, vm  # 8b'
  vsxh.v:
    opcode:
    - vsxh.v
    - nf
    - 28..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *17
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vsxh.v vs3, (rs1), vs2, vm  # 16b'
  vsxw.v:
    opcode:
    - vsxw.v
    - nf
    - 28..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *17
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vsxw.v vs3, (rs1), vs2, vm  # 32b'
  vsxe.v:
    opcode:
    - vsxe.v
    - nf
    - 28..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *17
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vsxe.v vs3, (rs1), vs2, vm  # SEW'
  vsuxb.v:
    opcode:
    - vsuxb.v
    - 31..29=0
    - 28..26=7
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *17
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vsuxb.v vs3, (rs1), vs2, vm  # 8b'
  vsuxh.v:
    opcode:
    - vsuxh.v
    - 31..29=0
    - 28..26=7
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *17
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vsuxh.v vs3, (rs1), vs2, vm  # 16b'
  vsuxw.v:
    opcode:
    - vsuxw.v
    - 31..29=0
    - 28..26=7
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *17
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vsuxw.v vs3, (rs1), vs2, vm  # 32b'
        "#_vector_iota_instruction":
          text:
          - 'vsuxw.v v8, (a2), v16, v0.t   # Scatter using scaled viota results under
            mask'
  vsuxe.v:
    opcode:
    - vsuxe.v
    - 31..29=0
    - 28..26=7
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: opcodes-rvv
    opcode_args: *17
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - 'vsuxe.v vs3, (rs1), vs2, vm  # SEW'
  vlbff.v:
    opcode:
    - vlbff.v
    - 31..29=0
    - 28..26=4
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_unit_stride_fault_only_first_loads"
    desc:
      v:
        "#_unit_stride_fault_only_first_loads":
          text:
          - 'vlbff.v  vd, (rs1), vm # 8b'
          - 'vlbff.v v1, (a3)      # Load bytes'
  vlhff.v:
    opcode:
    - vlhff.v
    - 31..29=0
    - 28..26=4
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_unit_stride_fault_only_first_loads"
    desc:
      v:
        "#_unit_stride_fault_only_first_loads":
          text:
          - 'vlhff.v  vd, (rs1), vm # 16b'
  vlwff.v:
    opcode:
    - vlwff.v
    - 31..29=0
    - 28..26=4
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_unit_stride_fault_only_first_loads"
    desc:
      v:
        "#_unit_stride_fault_only_first_loads":
          text:
          - 'vlwff.v  vd, (rs1), vm # 32b'
  vleff.v:
    opcode:
    - vleff.v
    - 31..29=0
    - 28..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_unit_stride_fault_only_first_loads"
    desc:
      v:
        "#_unit_stride_fault_only_first_loads":
          text:
          - 'vleff.v  vd, (rs1), vm # SEW'
  vlbuff.v:
    opcode:
    - vlbuff.v
    - 31..29=0
    - 28..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_unit_stride_fault_only_first_loads"
    desc:
      v:
        "#_unit_stride_fault_only_first_loads":
          text:
          - 'vlbuff.v vd, (rs1), vm # unsigned 8b'
        "#_example_using_vector_mask_instructions":
          text:
          - 'vlbuff.v v1, (a1)       # Get src bytes'
          - 'vlbuff.v v1, (a1)       # Get src bytes'
  vlhuff.v:
    opcode:
    - vlhuff.v
    - 31..29=0
    - 28..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_unit_stride_fault_only_first_loads"
    desc:
      v:
        "#_unit_stride_fault_only_first_loads":
          text:
          - 'vlhuff.v vd, (rs1), vm # unsigned 16b'
  vlwuff.v:
    opcode:
    - vlwuff.v
    - 31..29=0
    - 28..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_unit_stride_fault_only_first_loads"
    desc:
      v:
        "#_unit_stride_fault_only_first_loads":
          text:
          - 'vlwuff.v vd, (rs1), vm # unsigned 32b'
  vfadd.vf:
    opcode:
    - vfadd.vf
    - 31..26=0x00
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_add_subtract_instructions":
          text:
          - 'vfadd.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfadd.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfadd
  vfsub.vf:
    opcode:
    - vfsub.vf
    - 31..26=0x02
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_add_subtract_instructions":
          text:
          - 'vfsub.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfsub.vf vd, vs2, rs1, vm   # Vector-scalar vd[i] = vs2[i] - f[rs1]'
        "#_vector_instruction_listing":
          text:
          - vfsub
  vfmin.vf:
    opcode:
    - vfmin.vf
    - 31..26=0x04
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_floating_point_min_max_instructions"
    desc:
      v:
        "#_vector_floating_point_min_max_instructions":
          text:
          - The vector floating-point vfmin and vfmax instructions have the same behavior
            as the corresponding scalar floating-point instructions in version 2.2
            of the RISC-V F/D/Q extension.
          - 'vfmin.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfmin.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfmin
  vfmax.vf:
    opcode:
    - vfmax.vf
    - 31..26=0x06
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_floating_point_min_max_instructions"
    desc:
      v:
        "#_vector_floating_point_min_max_instructions":
          text:
          - 'vfmax.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfmax.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfmax
  vfsgnj.vf:
    opcode:
    - vfsgnj.vf
    - 31..26=0x08
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_floating_point_sign_injection_instructions"
    desc:
      v:
        "#_vector_floating_point_sign_injection_instructions":
          text:
          - 'vfsgnj.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfsgnj.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfsgnj
  vfsgnjn.vf:
    opcode:
    - vfsgnjn.vf
    - 31..26=0x09
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_floating_point_sign_injection_instructions"
    desc:
      v:
        "#_vector_floating_point_sign_injection_instructions":
          text:
          - 'vfsgnjn.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfsgnjn.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfsgnjn
  vfsgnjx.vf:
    opcode:
    - vfsgnjx.vf
    - 31..26=0x0a
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_floating_point_sign_injection_instructions"
    desc:
      v:
        "#_vector_floating_point_sign_injection_instructions":
          text:
          - 'vfsgnjx.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfsgnjx.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfsgnjx
  vfmv.s.f:
    opcode:
    - vfmv.s.f
    - 31..26=0x0d
    - 25=1
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_vector_floating_point_move_instruction"
    desc:
      v:
        "#_vector_floating_point_move_instruction":
          text:
          - Note vfmv.v.f instruction shares the encoding with the vfmerge.vfm vm=1
            and vs2=v0
          - Note vfmv.v.f substitutes a canonical NaN for f[rs1] if the latter is
            not properly NaN-boxed
          - 'vfmv.v.f vd, rs1  # vd[i] = f[rs1]'
        "#_floating_point_scalar_move_instructions":
          text:
          - The vfmv.f.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination scalar floating-point register
          - If SEW > FLEN, vfmv.f.s substitutes an FLEN-bit canonical NaN if the element
            value is not correctly NaN-boxed for FLEN
          - The vfmv.s.f instruction copies the scalar floating-point register to
            element 0 of the destination vector register
          - The encodings corresponding to the masked versions ( vm=0 ) of vfmv.f.s
            vfmv.s.f are reserved.
          - 'vfmv.f.s rd, vs2  # f[rd] = vs2[0] (rs1=0)'
          - 'vfmv.s.f vd, rs1  # vd[0] = f[rs1] (vs2=0)'
        "#_vector_instruction_listing":
          text:
          - vfmv.s.f
          - vfmv.f.s
  vfmerge.vfm:
    opcode:
    - vfmerge.vfm
    - 31..26=0x17
    - 25=0
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_floating_point_merge_instruction"
    desc:
      v:
        "#_vector_floating_point_merge_instruction":
          text:
          - The vfmerge.vfm instruction is always masked ( vm=0 )
          - Note vfmerge.vfm substitutes a canonical NaN for f[rs1] if the latter
            is not properly NaN-boxed
          - 'vfmerge.vfm vd, vs2, rs1, v0  # vd[i] = v0[i].LSB ? f[rs1] : vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfmerge.vf/vfmv
  vfmv.v.f:
    opcode:
    - vfmv.v.f
    - 31..26=0x17
    - 25=1
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_vector_floating_point_move_instruction"
    desc:
      v:
        "#_vector_floating_point_move_instruction":
          text:
          - Note vfmv.v.f instruction shares the encoding with the vfmerge.vfm vm=1
            and vs2=v0
          - Note vfmv.v.f substitutes a canonical NaN for f[rs1] if the latter is
            not properly NaN-boxed
          - 'vfmv.v.f vd, rs1  # vd[i] = f[rs1]'
        "#_floating_point_scalar_move_instructions":
          text:
          - The vfmv.f.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination scalar floating-point register
          - If SEW > FLEN, vfmv.f.s substitutes an FLEN-bit canonical NaN if the element
            value is not correctly NaN-boxed for FLEN
          - The vfmv.s.f instruction copies the scalar floating-point register to
            element 0 of the destination vector register
          - The encodings corresponding to the masked versions ( vm=0 ) of vfmv.f.s
            vfmv.s.f are reserved.
          - 'vfmv.f.s rd, vs2  # f[rd] = vs2[0] (rs1=0)'
          - 'vfmv.s.f vd, rs1  # vd[0] = f[rs1] (vs2=0)'
        "#_vector_instruction_listing":
          text:
          - vfmv.s.f
          - vfmv.f.s
  vfeq.vf:
    opcode:
    - vfeq.vf
    - 31..26=0x18
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vfle.vf:
    opcode:
    - vfle.vf
    - 31..26=0x19
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vford.vf:
    opcode:
    - vford.vf
    - 31..26=0x1a
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vflt.vf:
    opcode:
    - vflt.vf
    - 31..26=0x1b
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vfne.vf:
    opcode:
    - vfne.vf
    - 31..26=0x1c
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vfgt.vf:
    opcode:
    - vfgt.vf
    - 31..26=0x1d
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vfge.vf:
    opcode:
    - vfge.vf
    - 31..26=0x1f
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vfdiv.vf:
    opcode:
    - vfdiv.vf
    - 31..26=0x20
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_multiply_divide_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_multiply_divide_instructions":
          text:
          - 'vfdiv.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfdiv.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfdiv
  vfrdiv.vf:
    opcode:
    - vfrdiv.vf
    - 31..26=0x21
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_multiply_divide_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_multiply_divide_instructions":
          text:
          - 'vfrdiv.vf vd, vs2, rs1, vm  # scalar-vector, vd[i] = f[rs1]/vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfrdiv
  vfmul.vf:
    opcode:
    - vfmul.vf
    - 31..26=0x24
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_multiply_divide_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_multiply_divide_instructions":
          text:
          - 'vfmul.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfmul.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfmul
  vfmadd.vf:
    opcode:
    - vfmadd.vf
    - 31..26=0x28
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfmadd.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vd[i]) + vs2[i]'
          - 'vfmadd.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vd[i]) + vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfmadd
  vfnmadd.vf:
    opcode:
    - vfnmadd.vf
    - 31..26=0x29
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfnmadd.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vd[i]) - vs2[i]'
          - 'vfnmadd.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vd[i]) - vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfnmadd
  vfmsub.vf:
    opcode:
    - vfmsub.vf
    - 31..26=0x2a
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfmsub.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vd[i]) - vs2[i]'
          - 'vfmsub.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vd[i]) - vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfmsub
  vfnmsub.vf:
    opcode:
    - vfnmsub.vf
    - 31..26=0x2b
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfnmsub.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vd[i]) + vs2[i]'
          - 'vfnmsub.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vd[i]) + vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfnmsub
  vfmacc.vf:
    opcode:
    - vfmacc.vf
    - 31..26=0x2c
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]'
          - 'vfmacc.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfmacc
        "#_saxpy_example":
          text:
          - vfmacc.vf v8, fa0, v0
        "#_sgemm_example":
          text:
          - "# Inner loop scheduled assuming 4-clock occupancy of vfmacc instruction
            and single-issue pipeline"
          - vfmacc.vf v0, ft0, v16
          - vfmacc.vf v1, ft1, v16
          - vfmacc.vf v2, ft2, v16
          - vfmacc.vf v3, ft3, v16
          - vfmacc.vf v4, ft4, v16
          - vfmacc.vf v5, ft5, v16
          - vfmacc.vf v6, ft6, v16
          - vfmacc.vf v7, ft7, v16
          - vfmacc.vf v8, ft8, v16
          - vfmacc.vf v9, ft9, v16
          - vfmacc.vf v10, ft10, v16
          - vfmacc.vf v11, ft11, v16
          - '1:  vfmacc.vf v12, ft12, v16'
          - '1:  vfmacc.vf v13, ft13, v16'
          - '1:  vfmacc.vf v14, ft14, v16'
          - vfmacc.vf v15, ft15, v16
          - '1:  vfmacc.vf v15, ft15, v16'
  vfnmacc.vf:
    opcode:
    - vfnmacc.vf
    - 31..26=0x2d
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfnmacc.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) - vd[i]'
          - 'vfnmacc.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) - vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfnmacc
  vfmsac.vf:
    opcode:
    - vfmsac.vf
    - 31..26=0x2e
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfmsac.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) - vd[i]'
          - 'vfmsac.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) - vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfmsac
  vfnmsac.vf:
    opcode:
    - vfnmsac.vf
    - 31..26=0x2f
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfnmsac.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) + vd[i]'
          - 'vfnmsac.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfnmsac
  vfwadd.vf:
    opcode:
    - vfwadd.vf
    - 31..26=0x30
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_add_subtract_instructions":
          text:
          - 'vfwadd.vv vd, vs2, vs1, vm  # vector-vector'
          - 'vfwadd.vf vd, vs2, rs1, vm  # vector-scalar'
          - 'vfwadd.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vfwadd.wf  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfwadd
          - vfwadd.w
  vfwsub.vf:
    opcode:
    - vfwsub.vf
    - 31..26=0x32
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_add_subtract_instructions":
          text:
          - 'vfwsub.vv vd, vs2, vs1, vm  # vector-vector'
          - 'vfwsub.vf vd, vs2, rs1, vm  # vector-scalar'
          - 'vfwsub.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vfwsub.wf  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfwsub
          - vfwsub.w
  vfwadd.wf:
    opcode:
    - vfwadd.wf
    - 31..26=0x34
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_add_subtract_instructions":
          text:
          - 'vfwadd.vv vd, vs2, vs1, vm  # vector-vector'
          - 'vfwadd.vf vd, vs2, rs1, vm  # vector-scalar'
          - 'vfwadd.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vfwadd.wf  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfwadd
          - vfwadd.w
  vfwsub.wf:
    opcode:
    - vfwsub.wf
    - 31..26=0x36
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_add_subtract_instructions":
          text:
          - 'vfwsub.vv vd, vs2, vs1, vm  # vector-vector'
          - 'vfwsub.vf vd, vs2, rs1, vm  # vector-scalar'
          - 'vfwsub.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vfwsub.wf  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfwsub
          - vfwsub.w
  vfwmul.vf:
    opcode:
    - vfwmul.vf
    - 31..26=0x38
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_floating_point_multiply"
    desc:
      v:
        "#_vector_widening_floating_point_multiply":
          text:
          - 'vfwmul.vv    vd, vs2, vs1, vm # vector-vector'
          - 'vfwmul.vf    vd, vs2, rs1, vm # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfwmul
  vfwmacc.vf:
    opcode:
    - vfwmacc.vf
    - 31..26=0x3c
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfwmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]'
          - 'vfwmacc.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfwmacc
  vfwnmacc.vf:
    opcode:
    - vfwnmacc.vf
    - 31..26=0x3d
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfwnmacc.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) - vd[i]'
          - 'vfwnmacc.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) - vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfwnmacc
  vfwmsac.vf:
    opcode:
    - vfwmsac.vf
    - 31..26=0x3e
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfwmsac.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) - vd[i]'
          - 'vfwmsac.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) - vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfwmsac
  vfwnmsac.vf:
    opcode:
    - vfwnmsac.vf
    - 31..26=0x3f
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfwnmsac.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) + vd[i]'
          - 'vfwnmsac.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfwnmsac
  vfadd.vv:
    opcode:
    - vfadd.vv
    - 31..26=0x00
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: &18
    - vs2
    - vs1
    - vd
    main_desc: v
    main_id: "#_vector_single_width_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_add_subtract_instructions":
          text:
          - 'vfadd.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfadd.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfadd
  vfredsum.vs:
    opcode:
    - vfredsum.vs
    - 31..26=0x01
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_reduction_instructions":
          text:
          - 'vfredsum.vs  vd, vs2, vs1, vm # Unordered sum'
        "#_vector_unordered_single_width_floating_point_sum_reduction":
          text:
          - The unordered sum reduction instruction, vfredsum , provides an implementation
            more freedom in performing the reduction.
        "#_vector_instruction_listing":
          text:
          - vfredsum
  vfsub.vv:
    opcode:
    - vfsub.vv
    - 31..26=0x02
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_add_subtract_instructions":
          text:
          - 'vfsub.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfsub.vf vd, vs2, rs1, vm   # Vector-scalar vd[i] = vs2[i] - f[rs1]'
        "#_vector_instruction_listing":
          text:
          - vfsub
  vfredosum.vs:
    opcode:
    - vfredosum.vs
    - 31..26=0x03
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_reduction_instructions":
          text:
          - 'vfredosum.vs vd, vs2, vs1, vm # Ordered sum'
        "#_vector_ordered_single_width_floating_point_sum_reduction":
          text:
          - 'The vfredosum instruction must sum the floating-point values in element
            order, starting with the scalar in vs1[0] --that is, it performs the computation:
            (((vs1[0] + vs2[0]) + vs2[1]) + &hellip;​) , where each addition operates
            identically to the scalar floating-point instructions in terms of raising
            exception flags and generating or propagating special values.'
        "#_vector_unordered_single_width_floating_point_sum_reduction":
          text:
          - Note vfredosum
          - Note vfredosum instruction is a valid implementation of the vfredsum instruction
        "#_vector_instruction_listing":
          text:
          - vfredosum
  vfmin.vv:
    opcode:
    - vfmin.vv
    - 31..26=0x04
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_floating_point_min_max_instructions"
    desc:
      v:
        "#_vector_floating_point_min_max_instructions":
          text:
          - The vector floating-point vfmin and vfmax instructions have the same behavior
            as the corresponding scalar floating-point instructions in version 2.2
            of the RISC-V F/D/Q extension.
          - 'vfmin.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfmin.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfmin
  vfredmin.vs:
    opcode:
    - vfredmin.vs
    - 31..26=0x05
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_reduction_instructions":
          text:
          - 'vfredmin.vs  vd, vs2, vs1, vm # Minimum value'
        "#_vector_instruction_listing":
          text:
          - vfredmin
  vfmax.vv:
    opcode:
    - vfmax.vv
    - 31..26=0x06
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_floating_point_min_max_instructions"
    desc:
      v:
        "#_vector_floating_point_min_max_instructions":
          text:
          - 'vfmax.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfmax.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfmax
  vfredmax.vs:
    opcode:
    - vfredmax.vs
    - 31..26=0x07
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_reduction_instructions":
          text:
          - 'vfredmax.vs  vd, vs2, vs1, vm # Maximum value'
        "#_vector_instruction_listing":
          text:
          - vfredmax
  vfsgnj.vv:
    opcode:
    - vfsgnj.vv
    - 31..26=0x08
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_floating_point_sign_injection_instructions"
    desc:
      v:
        "#_vector_floating_point_sign_injection_instructions":
          text:
          - 'vfsgnj.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfsgnj.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfsgnj
  vfsgnjn.vv:
    opcode:
    - vfsgnjn.vv
    - 31..26=0x09
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_floating_point_sign_injection_instructions"
    desc:
      v:
        "#_vector_floating_point_sign_injection_instructions":
          text:
          - 'vfsgnjn.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfsgnjn.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfsgnjn
  vfsgnjx.vv:
    opcode:
    - vfsgnjx.vv
    - 31..26=0x0a
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_floating_point_sign_injection_instructions"
    desc:
      v:
        "#_vector_floating_point_sign_injection_instructions":
          text:
          - 'vfsgnjx.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfsgnjx.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfsgnjx
  vfmv.f.s:
    opcode:
    - vfmv.f.s
    - 31..26=0x0c
    - 25=1
    - vs2
    - 19..15=0
    - 14..12=0x1
    - rd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: &32
    - vs2
    - rd
    main_desc: v
    main_id: "#_vector_floating_point_move_instruction"
    desc:
      v:
        "#_vector_floating_point_move_instruction":
          text:
          - Note vfmv.v.f instruction shares the encoding with the vfmerge.vfm vm=1
            and vs2=v0
          - Note vfmv.v.f substitutes a canonical NaN for f[rs1] if the latter is
            not properly NaN-boxed
          - 'vfmv.v.f vd, rs1  # vd[i] = f[rs1]'
        "#_floating_point_scalar_move_instructions":
          text:
          - The vfmv.f.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination scalar floating-point register
          - If SEW > FLEN, vfmv.f.s substitutes an FLEN-bit canonical NaN if the element
            value is not correctly NaN-boxed for FLEN
          - The vfmv.s.f instruction copies the scalar floating-point register to
            element 0 of the destination vector register
          - The encodings corresponding to the masked versions ( vm=0 ) of vfmv.f.s
            vfmv.s.f are reserved.
          - 'vfmv.f.s rd, vs2  # f[rd] = vs2[0] (rs1=0)'
          - 'vfmv.s.f vd, rs1  # vd[0] = f[rs1] (vs2=0)'
        "#_vector_instruction_listing":
          text:
          - vfmv.s.f
          - vfmv.f.s
  vfeq.vv:
    opcode:
    - vfeq.vv
    - 31..26=0x18
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vfle.vv:
    opcode:
    - vfle.vv
    - 31..26=0x19
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vford.vv:
    opcode:
    - vford.vv
    - 31..26=0x1a
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vflt.vv:
    opcode:
    - vflt.vv
    - 31..26=0x1b
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vfne.vv:
    opcode:
    - vfne.vv
    - 31..26=0x1c
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vfdiv.vv:
    opcode:
    - vfdiv.vv
    - 31..26=0x20
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_multiply_divide_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_multiply_divide_instructions":
          text:
          - 'vfdiv.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfdiv.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfdiv
  vfunary0.vv:
    opcode:
    - vfunary0.vv
    - 31..26=0x22
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vfunary1.vv:
    opcode:
    - vfunary1.vv
    - 31..26=0x23
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vfmul.vv:
    opcode:
    - vfmul.vv
    - 31..26=0x24
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_multiply_divide_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_multiply_divide_instructions":
          text:
          - 'vfmul.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfmul.vf vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfmul
  vfmadd.vv:
    opcode:
    - vfmadd.vv
    - 31..26=0x28
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfmadd.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vd[i]) + vs2[i]'
          - 'vfmadd.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vd[i]) + vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfmadd
  vfnmadd.vv:
    opcode:
    - vfnmadd.vv
    - 31..26=0x29
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfnmadd.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vd[i]) - vs2[i]'
          - 'vfnmadd.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vd[i]) - vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfnmadd
  vfmsub.vv:
    opcode:
    - vfmsub.vv
    - 31..26=0x2a
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfmsub.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vd[i]) - vs2[i]'
          - 'vfmsub.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vd[i]) - vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfmsub
  vfnmsub.vv:
    opcode:
    - vfnmsub.vv
    - 31..26=0x2b
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfnmsub.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vd[i]) + vs2[i]'
          - 'vfnmsub.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vd[i]) + vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfnmsub
  vfmacc.vv:
    opcode:
    - vfmacc.vv
    - 31..26=0x2c
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]'
          - 'vfmacc.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfmacc
        "#_saxpy_example":
          text:
          - vfmacc.vf v8, fa0, v0
        "#_sgemm_example":
          text:
          - "# Inner loop scheduled assuming 4-clock occupancy of vfmacc instruction
            and single-issue pipeline"
          - vfmacc.vf v0, ft0, v16
          - vfmacc.vf v1, ft1, v16
          - vfmacc.vf v2, ft2, v16
          - vfmacc.vf v3, ft3, v16
          - vfmacc.vf v4, ft4, v16
          - vfmacc.vf v5, ft5, v16
          - vfmacc.vf v6, ft6, v16
          - vfmacc.vf v7, ft7, v16
          - vfmacc.vf v8, ft8, v16
          - vfmacc.vf v9, ft9, v16
          - vfmacc.vf v10, ft10, v16
          - vfmacc.vf v11, ft11, v16
          - '1:  vfmacc.vf v12, ft12, v16'
          - '1:  vfmacc.vf v13, ft13, v16'
          - '1:  vfmacc.vf v14, ft14, v16'
          - vfmacc.vf v15, ft15, v16
          - '1:  vfmacc.vf v15, ft15, v16'
  vfnmacc.vv:
    opcode:
    - vfnmacc.vv
    - 31..26=0x2d
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfnmacc.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) - vd[i]'
          - 'vfnmacc.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) - vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfnmacc
  vfmsac.vv:
    opcode:
    - vfmsac.vv
    - 31..26=0x2e
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfmsac.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) - vd[i]'
          - 'vfmsac.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) - vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfmsac
  vfnmsac.vv:
    opcode:
    - vfnmsac.vv
    - 31..26=0x2f
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfnmsac.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) + vd[i]'
          - 'vfnmsac.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfnmsac
  vfwadd.vv:
    opcode:
    - vfwadd.vv
    - 31..26=0x30
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_add_subtract_instructions":
          text:
          - 'vfwadd.vv vd, vs2, vs1, vm  # vector-vector'
          - 'vfwadd.vf vd, vs2, rs1, vm  # vector-scalar'
          - 'vfwadd.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vfwadd.wf  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfwadd
          - vfwadd.w
  vfwredsum.vs:
    opcode:
    - vfwredsum.vs
    - 31..26=0x31
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_reduction_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_reduction_instructions":
          text:
          - 'vfwredsum.vs vd, vs2, vs1, vm  # Unordered sum'
        "#_vector_instruction_listing":
          text:
          - vfwredsum
  vfwsub.vv:
    opcode:
    - vfwsub.vv
    - 31..26=0x32
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_add_subtract_instructions":
          text:
          - 'vfwsub.vv vd, vs2, vs1, vm  # vector-vector'
          - 'vfwsub.vf vd, vs2, rs1, vm  # vector-scalar'
          - 'vfwsub.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vfwsub.wf  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfwsub
          - vfwsub.w
  vfwredosum.vs:
    opcode:
    - vfwredosum.vs
    - 31..26=0x33
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_reduction_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_reduction_instructions":
          text:
          - 'vfwredosum.vs vd, vs2, vs1, vm # Ordered sum'
        "#_vector_instruction_listing":
          text:
          - vfwredosum
  vfwadd.wv:
    opcode:
    - vfwadd.wv
    - 31..26=0x34
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_add_subtract_instructions":
          text:
          - 'vfwadd.vv vd, vs2, vs1, vm  # vector-vector'
          - 'vfwadd.vf vd, vs2, rs1, vm  # vector-scalar'
          - 'vfwadd.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vfwadd.wf  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfwadd
          - vfwadd.w
  vfwsub.wv:
    opcode:
    - vfwsub.wv
    - 31..26=0x36
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_add_subtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_add_subtract_instructions":
          text:
          - 'vfwsub.vv vd, vs2, vs1, vm  # vector-vector'
          - 'vfwsub.vf vd, vs2, rs1, vm  # vector-scalar'
          - 'vfwsub.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vfwsub.wf  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfwsub
          - vfwsub.w
  vfwmul.vv:
    opcode:
    - vfwmul.vv
    - 31..26=0x38
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_multiply"
    desc:
      v:
        "#_vector_widening_floating_point_multiply":
          text:
          - 'vfwmul.vv    vd, vs2, vs1, vm # vector-vector'
          - 'vfwmul.vf    vd, vs2, rs1, vm # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfwmul
  vfdot.vv:
    opcode:
    - vfdot.vv
    - 31..26=0x39
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_floating_point_dot_product_instruction"
    desc:
      v:
        "#_vector_floating_point_dot_product_instruction":
          text:
          - The floating-point dot-product reduction vfdot.vv performs an element-wise
            multiplication between the source sub-elements then accumulates the results
            into the destination vector element
          - 'vfdot.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vfdot.vv  vd, vs2, vs1, vm # vd[i][31:0] += vs2[i][31:16] * vs1[i][31:16]'
          - 'vfdot.vv v1, v2, v3   # v1[i][31:0] +=  v2[i][31:16]*v3[i][31:16] + v2[i][16:0]*v3[i][16:0]'
          - vfdot.vv v1, v2, v3
        "#_vector_instruction_listing":
          text:
          - vfdot
  vfwmacc.vv:
    opcode:
    - vfwmacc.vv
    - 31..26=0x3c
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfwmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]'
          - 'vfwmacc.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfwmacc
  vfwnmacc.vv:
    opcode:
    - vfwnmacc.vv
    - 31..26=0x3d
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfwnmacc.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) - vd[i]'
          - 'vfwnmacc.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) - vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfwnmacc
  vfwmsac.vv:
    opcode:
    - vfwmsac.vv
    - 31..26=0x3e
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfwmsac.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) - vd[i]'
          - 'vfwmsac.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) - vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfwmsac
  vfwnmsac.vv:
    opcode:
    - vfwnmsac.vv
    - 31..26=0x3f
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_fused_multiply_add_instructions":
          text:
          - 'vfwnmsac.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) + vd[i]'
          - 'vfwnmsac.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vfwnmsac
  vadd.vx:
    opcode:
    - vadd.vx
    - 31..26=0x00
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_integer_add_and_subtract":
          text:
          - 'vadd.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vadd.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vadd.vi vd, vs2, imm, vm   # vector-immediate'
        "#_regular_vector_arithmetic_instructions_under_ediv":
          text:
          - 'vadd.vv v1,v2,v3                     # Performs a vector of 4*vl 8-bit
            additions.'
        "#_vector_instruction_listing":
          text:
          - vadd
        "#_vector_vector_add_example":
          text:
          - 'vadd.vv v2, v0, v1        # Sum vectors'
  vsub.vx:
    opcode:
    - vsub.vx
    - 31..26=0x02
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_integer_add_and_subtract":
          text:
          - 'vsub.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsub.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vsub
  vrsub.vx:
    opcode:
    - vrsub.vx
    - 31..26=0x03
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_integer_add_and_subtract":
          text:
          - 'vrsub.vx vd, vs2, rs1, vm   # vd[i] = rs1 - vs2[i]'
          - 'vrsub.vi vd, vs2, imm, vm   # vd[i] = imm - vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vrsub
  vminu.vx:
    opcode:
    - vminu.vx
    - 31..26=0x04
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_min_max_instructions"
    desc:
      v:
        "#_vector_integer_min_max_instructions":
          text:
          - 'vminu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vminu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vminu
  vmin.vx:
    opcode:
    - vmin.vx
    - 31..26=0x05
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_min_max_instructions"
    desc:
      v:
        "#_vector_integer_min_max_instructions":
          text:
          - 'vmin.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmin.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmin
  vmaxu.vx:
    opcode:
    - vmaxu.vx
    - 31..26=0x06
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_min_max_instructions"
    desc:
      v:
        "#_vector_integer_min_max_instructions":
          text:
          - 'vmaxu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmaxu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmaxu
  vmax.vx:
    opcode:
    - vmax.vx
    - 31..26=0x07
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_min_max_instructions"
    desc:
      v:
        "#_vector_integer_min_max_instructions":
          text:
          - 'vmax.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmax.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmax
  vand.vx:
    opcode:
    - vand.vx
    - 31..26=0x09
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - 'vand.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vand.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vand.vi vd, vs2, imm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vand
  vor.vx:
    opcode:
    - vor.vx
    - 31..26=0x0a
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - 'vor.vv vd, vs2, vs1, vm    # Vector-vector'
          - 'vor.vx vd, vs2, rs1, vm    # vector-scalar'
          - 'vor.vi vd, vs2, imm, vm    # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vor
  vxor.vx:
    opcode:
    - vxor.vx
    - 31..26=0x0b
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - Note vxor vnot.v
          - 'vxor.vv vd, vs2, vs1, vm    # Vector-vector'
          - 'vxor.vx vd, vs2, rs1, vm    # vector-scalar'
          - 'vxor.vi vd, vs2, imm, vm    # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vxor
  vrgather.vx:
    opcode:
    - vrgather.vx
    - 31..26=0x0c
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_register_gather_instruction"
    desc:
      v:
        "#_vector_register_gather_instruction":
          text:
          - For any vrgather instruction, the destination vector register group cannot
            overlap with the source vector register groups, including the mask register
            if the operation is masked, otherwise an illegal instruction exception
            is raised.
          - Note vrgather.vv can only reference vector elements 0-255.
          - 'vrgather.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];'
          - 'vrgather.vx vd, vs2, rs1, vm # vd[i] = (x[rs1] &gt;= VLMAX) ? 0 : vs2[x[rs1]]'
          - 'vrgather.vi vd, vs2, uimm, vm # vd[i] = (uimm &gt;= VLMAX) ? 0 : vs2[uimm]'
        "#_vector_register_gather_instructions_under_ediv":
          text:
          - vrgather.vv v3, v1, v2
          - vrgather.vi v4, v1, 1
        "#_vector_instruction_listing":
          text:
          - vrgather
  vslideup.vx:
    opcode:
    - vslideup.vx
    - 31..26=0x0e
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_slide_instructions"
    desc:
      v:
        "#_vector_slide_instructions":
          text:
          - Note vslideup and vslidedown
          - For all of the vslideup , vslidedown , vslide1up , and vslide1down instructions,
            if vstart &ge; vl , the instruction performs no operation and leaves the
            destination vector register unchanged.
        "#_vector_slideup_instructions":
          text:
          - For vslideup , the value in vl specifies the maximum number of destination
            elements that are written
          - The destination vector register group for vslideup cannot overlap the
            vector register group of the source vector register group or the mask
            register, otherwise an illegal instruction exception is raised.
          - 'vslideup.vx vd, vs2, rs1, vm        # vd[i+rs1] = vs2[i]'
          - 'vslideup.vi vd, vs2, uimm[4:0], vm  # vd[i+uimm] = vs2[i]'
          - vslideup behavior for destination elements
        "#_vector_instruction_listing":
          text:
          - vslideup
  vslidedown.vx:
    opcode:
    - vslidedown.vx
    - 31..26=0x0f
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_slidedown_instructions"
    desc:
      v:
        "#_vector_slidedown_instructions":
          text:
          - For vslidedown , the value in vl specifies the number of destination elements
            that are written.
          - 'vslidedown.vx vd, vs2, rs1, vm       # vd[i] = vs2[i+rs1]'
          - 'vslidedown.vi vd, vs2, uimm[4:0], vm # vd[i] = vs2[i+uimm]'
          - vslidedown behavior for source elements for element i in slide
          - vslidedown behavior for destination element i in slide
        "#_vector_instruction_listing":
          text:
          - vslidedown
  vadc.vxm:
    opcode:
    - vadc.vxm
    - 31..26=0x10
    - 25=1
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - ". Due to encoding constraints, the carry input must come from the implicit
            v0 vadc and vsbc add or subtract the source operands and the carry-in
            or borrow-in, and write the result to vector register vd"
          - For vadc and vsbc , an illegal instruction exception is raised if the
            destination vector register is v0 and LMUL > 1.
          - 'vadc.vvm   vd, vs2, vs1, v0  # Vector-vector'
          - 'vadc.vxm   vd, vs2, rs1, v0  # Vector-scalar'
          - 'vadc.vim   vd, vs2, imm, v0  # Vector-immediate'
          - 'vadc.vvm v4, v4, v8, v0   # Calc new sum'
        "#_vector_add_with_carry_subtract_with_borrow_reserved_under_ediv_1":
          text:
          - For EDIV > 1, vadc , vmadc , vsbc , vmsbc are reserved.
        "#_vector_instruction_listing":
          text:
          - vadc
  vmadc.vxm:
    opcode:
    - vmadc.vxm
    - 31..26=0x11
    - 25=1
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vmadc and vmsbc add or subtract the source operands, optionally add the
            carry-in or subtract the borrow-in if masked ( vm=0 ), and write the result
            back to mask register vd
          - For vmadc and vmsbc , an illegal instruction exception is raised if the
            destination vector register overlaps a source vector register group and
            LMUL > 1.
          - 'vmadc.vvm   vd, vs2, vs1, v0  # Vector-vector'
          - 'vmadc.vxm   vd, vs2, rs1, v0  # Vector-scalar'
          - 'vmadc.vim   vd, vs2, imm, v0  # Vector-immediate'
          - 'vmadc.vv    vd, vs2, vs1      # Vector-vector, no carry-in'
          - 'vmadc.vx    vd, vs2, rs1      # Vector-scalar, no carry-in'
          - 'vmadc.vi    vd, vs2, imm      # Vector-immediate, no carry-in'
          - 'vmadc.vvm v1, v4, v8, v0  # Get carry into temp register v1'
        "#_vector_instruction_listing":
          text:
          - vmadc
  vsbc.vxm:
    opcode:
    - vsbc.vxm
    - 31..26=0x12
    - 25=1
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - The subtract with borrow instruction vsbc performs the equivalent function
            to support long word arithmetic for subtraction
          - 'vsbc.vvm   vd, vs2, vs1, v0  # Vector-vector'
          - 'vsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vsbc
  vmsbc.vxm:
    opcode:
    - vmsbc.vxm
    - 31..26=0x13
    - 25=1
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - For vmsbc , the borrow is defined to be 1 iff the difference, prior to
            truncation, is negative.
          - 'vmsbc.vvm   vd, vs2, vs1, v0  # Vector-vector'
          - 'vmsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar'
          - 'vmsbc.vv    vd, vs2, vs1      # Vector-vector, no borrow-in'
          - 'vmsbc.vx    vd, vs2, rs1      # Vector-scalar, no borrow-in'
        "#_vector_instruction_listing":
          text:
          - vmsbc
  vmerge.vxm:
    opcode:
    - vmerge.vxm
    - 31..26=0x17
    - 25=0
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_merge_instructions"
    desc:
      v:
        "#_vector_integer_merge_instructions":
          text:
          - The vmerge instructions are always masked ( vm=0 )
          - 'vmerge.vvm vd, vs2, vs1, v0  # vd[i] = v0[i].LSB ? vs1[i] : vs2[i]'
          - 'vmerge.vxm vd, vs2, rs1, v0  # vd[i] = v0[i].LSB ? x[rs1] : vs2[i]'
          - 'vmerge.vim vd, vs2, imm, v0  # vd[i] = v0[i].LSB ? imm    : vs2[i]'
        "#_whole_vector_register_move":
          text:
          - This encoding is chosen as it is close to the related vmerge encoding,
            and it is unlikely the vsmul instruction would benefit from an immediate
            form
        "#_vector_instruction_listing":
          text:
          - vmerge/vmv
  vmv.v.x:
    opcode:
    - vmv.v.x
    - 31..26=0x17
    - 25=1
    - 24..20=0
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_vector_integer_move_instructions"
    desc:
      v:
        "#_vector_integer_move_instructions":
          text:
          - This instruction copies the vs1 , rs1 , or immediate operand to the first
            vl Note vmv.v.i vd, 0; vmerge.vim vd, vd, 1, v0
          - 'vmv.v.v vd, vs1 # vd[i] = vs1[i]'
          - 'vmv.v.x vd, rs1 # vd[i] = rs1'
          - 'vmv.v.i vd, imm # vd[i] = imm'
        "#_example_using_vector_mask_instructions":
          text:
          - 'vmv.v.i v0, 0           # Splat zero.'
        "#_integer_scalar_move_instructions":
          text:
          - The vmv.x.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination integer register
          - The vmv.s.x instruction copies the scalar integer register to element
            0 of the destination vector register
          - The encodings corresponding to the masked versions ( vm=0 ) of vmv.x.s
            vmv.s.x are reserved.
          - 'vmv.x.s rd, vs2  # x[rd] = vs2[0] (rs1=0)'
          - 'vmv.s.x vd, rs1  # vd[0] = x[rs1] (vs2=0)'
        "#_whole_vector_register_move":
          text:
          - The vmv<nf>r.v instructions copy whole vector registers (i.e., all VLEN
            bits) ignoring the current settings of the vl and vtype Note vl or vtype
          - 'vmv&lt;nf&gt;r.v vd, vs2  # General form'
        "#_vector_instruction_listing":
          text:
          - vmv<nf>r
          - vmv.s.x
          - vmv.x.s
        "#_example_with_mixed_width_mask_and_compute":
          text:
          - 'vmv.v.i v4, 1                 # Splat immediate to destination'
  vseq.vx:
    opcode:
    - vseq.vx
    - 31..26=0x18
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsne.vx:
    opcode:
    - vsne.vx
    - 31..26=0x19
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsltu.vx:
    opcode:
    - vsltu.vx
    - 31..26=0x1a
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vslt.vx:
    opcode:
    - vslt.vx
    - 31..26=0x1b
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsleu.vx:
    opcode:
    - vsleu.vx
    - 31..26=0x1c
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsle.vx:
    opcode:
    - vsle.vx
    - 31..26=0x1d
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsgtu.vx:
    opcode:
    - vsgtu.vx
    - 31..26=0x1e
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsgt.vx:
    opcode:
    - vsgt.vx
    - 31..26=0x1f
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsaddu.vx:
    opcode:
    - vsaddu.vx
    - 31..26=0x20
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - 'vsaddu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsaddu.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsaddu.vi vd, vs2, imm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsaddu
  vsadd.vx:
    opcode:
    - vsadd.vx
    - 31..26=0x21
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - 'vsadd.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsadd.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsadd.vi vd, vs2, imm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsadd
  vssubu.vx:
    opcode:
    - vssubu.vx
    - 31..26=0x22
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - 'vssubu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vssubu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vssubu
  vssub.vx:
    opcode:
    - vssub.vx
    - 31..26=0x23
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - 'vssub.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vssub.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vssub
  vaadd.vx:
    opcode:
    - vaadd.vx
    - 31..26=0x24
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_averaging_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_averaging_add_and_subtract":
          text:
          - For vaaddu , vaadd , and vasub , there can be no overflow in the result
          - 'vaadd.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] + vs1[i], 1)'
          - 'vaadd.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] + x[rs1], 1)'
        "#_vector_instruction_listing":
          text:
          - vaadd
  vsll.vx:
    opcode:
    - vsll.vx
    - 31..26=0x25
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_bit_shift_instructions"
    desc:
      v:
        "#_vector_single_width_bit_shift_instructions":
          text:
          - 'vsll.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsll.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsll.vi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_iota_instruction":
          text:
          - 'vsll.vi v16, v16, 2, v0.t     # Multiply offsets by four bytes'
        "#_regular_vector_arithmetic_instructions_under_ediv":
          text:
          - 'vsll.vx v1,v2,x1                     # Performs a vector of 4*vl 8-bit
            shifts.'
        "#_vector_instruction_listing":
          text:
          - vsll
  vasub.vx:
    opcode:
    - vasub.vx
    - 31..26=0x26
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_averaging_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_averaging_add_and_subtract":
          text:
          - 'vasub.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] - vs1[i], 1)'
          - 'vasub.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] - x[rs1], 1)'
        "#_vector_instruction_listing":
          text:
          - vasub
  vsmul.vx:
    opcode:
    - vsmul.vx
    - 31..26=0x27
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_fractional_multiply_with_rounding_and_saturation"
    desc:
      v:
        "#_vector_single_width_fractional_multiply_with_rounding_and_saturation":
          text:
          - 'vsmul.vv vd, vs2, vs1, vm  # vd[i] = clip(roundoff_signed(vs2[i]*vs1[i],
            SEW-1))'
          - 'vsmul.vx vd, vs2, rs1, vm  # vd[i] = clip(roundoff_signed(vs2[i]*x[rs1],
            SEW-1))'
        "#_whole_vector_register_move":
          text:
          - Note vsmul vm=1 )
        "#_vector_instruction_listing":
          text:
          - vsmul
  vsrl.vx:
    opcode:
    - vsrl.vx
    - 31..26=0x28
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_examples"
    desc:
      v:
        "#_examples":
          text:
          - 'vsrl.vi  v8, v8, 3      # Shift elements'
          - vsrl.vi v8, v8, 3
        "#_vector_single_width_bit_shift_instructions":
          text:
          - 'vsrl.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsrl.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsrl.vi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsrl
  vsra.vx:
    opcode:
    - vsra.vx
    - 31..26=0x29
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_bit_shift_instructions"
    desc:
      v:
        "#_vector_single_width_bit_shift_instructions":
          text:
          - 'vsra.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsra.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsra.vi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsra
  vssrl.vx:
    opcode:
    - vssrl.vx
    - 31..26=0x2a
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_scaling_shift_instructions"
    desc:
      v:
        "#_vector_single_width_scaling_shift_instructions":
          text:
          - The scaling right shifts have both zero-extending ( vssrl ) and sign-extending
            ( vssra ) forms
          - 'vssrl.vv vd, vs2, vs1, vm   # vd[i] = roundoff_unsigned(vs2[i], vs1[i])'
          - 'vssrl.vx vd, vs2, rs1, vm   # vd[i] = roundoff_unsigned(vs2[i], x[rs1])'
          - 'vssrl.vi vd, vs2, uimm, vm   # vd[i] = roundoff_unsigned(vs2[i], uimm)'
        "#_vector_instruction_listing":
          text:
          - vssrl
  vssra.vx:
    opcode:
    - vssra.vx
    - 31..26=0x2b
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_scaling_shift_instructions"
    desc:
      v:
        "#_vector_single_width_scaling_shift_instructions":
          text:
          - 'vssra.vv vd, vs2, vs1, vm   # vd[i] = roundoff_signed(vs2[i],vs1[i])'
          - 'vssra.vx vd, vs2, rs1, vm   # vd[i] = roundoff_signed(vs2[i], x[rs1])'
          - 'vssra.vi vd, vs2, uimm, vm   # vd[i] = roundoff_signed(vs2[i], uimm)'
        "#_vector_instruction_listing":
          text:
          - vssra
  vnsrl.vx:
    opcode:
    - vnsrl.vx
    - 31..26=0x2c
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_narrowing_integer_right_shift_instructions"
    desc:
      v:
        "#_vector_narrowing_integer_right_shift_instructions":
          text:
          - 'vnsrl.wv vd, vs2, vs1, vm   # vector-vector'
          - 'vnsrl.wx vd, vs2, rs1, vm   # vector-scalar'
          - 'vnsrl.wi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vnsrl
  vnsra.vx:
    opcode:
    - vnsra.vx
    - 31..26=0x2d
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#sec-narrowing"
    desc:
      v:
        "#sec-narrowing":
          text:
          - The double-width source vector register group is signified by a w in the
            source operand suffix (e.g., vnsra.wv )
        "#_vector_narrowing_integer_right_shift_instructions":
          text:
          - 'vnsra.wv vd, vs2, vs1, vm   # vector-vector'
          - 'vnsra.wx vd, vs2, rs1, vm   # vector-scalar'
          - 'vnsra.wi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vnsra
  vnclipu.vx:
    opcode:
    - vnclipu.vx
    - 31..26=0x2e
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - For vnclipu / vnclip , the rounding mode is specified in the vxrm For
            vnclipu , the shifted rounded source value is treated as an unsigned integer
            and saturates if the result would overflow the destination viewed as an
            unsigned integer.
          - 'vnclipu.wv vd, vs2, vs1, vm   # vd[i] = clip(roundoff_unsigned(vs2[i],
            vs1[i]))'
          - 'vnclipu.wx vd, vs2, rs1, vm   # vd[i] = clip(roundoff_unsigned(vs2[i],
            x[rs1]))'
          - 'vnclipu.wi vd, vs2, uimm, vm  # vd[i] = clip(roundoff_unsigned(vs2[i],
            uimm5))'
        "#_vector_instruction_listing":
          text:
          - vnclipu
  vnclip.vx:
    opcode:
    - vnclip.vx
    - 31..26=0x2f
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - The vnclip instructions are used to pack a fixed-point value into a narrower
            destination
          - For vnclip , the shifted rounded source value is treated as a signed integer
            and saturates if the result would overflow the destination viewed as a
            signed integer.
          - 'vnclip.wv vd, vs2, vs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], vs1[i]))'
          - 'vnclip.wx vd, vs2, rs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], x[rs1]))'
          - 'vnclip.wi vd, vs2, uimm, vm  # vd[i] = clip(roundoff_signed(vs2[i], uimm5))'
        "#_vector_instruction_listing":
          text:
          - vnclip
  vwsmaccu.vx:
    opcode:
    - vwsmaccu.vx
    - 31..26=0x3c
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vwsmacc.vx:
    opcode:
    - vwsmacc.vx
    - 31..26=0x3d
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vwsmaccsu.vx:
    opcode:
    - vwsmaccsu.vx
    - 31..26=0x3e
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vwsmaccus.vx:
    opcode:
    - vwsmaccus.vx
    - 31..26=0x3f
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vadd.vv:
    opcode:
    - vadd.vv
    - 31..26=0x00
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_integer_add_and_subtract":
          text:
          - 'vadd.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vadd.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vadd.vi vd, vs2, imm, vm   # vector-immediate'
        "#_regular_vector_arithmetic_instructions_under_ediv":
          text:
          - 'vadd.vv v1,v2,v3                     # Performs a vector of 4*vl 8-bit
            additions.'
        "#_vector_instruction_listing":
          text:
          - vadd
        "#_vector_vector_add_example":
          text:
          - 'vadd.vv v2, v0, v1        # Sum vectors'
  vsub.vv:
    opcode:
    - vsub.vv
    - 31..26=0x02
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_integer_add_and_subtract":
          text:
          - 'vsub.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsub.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vsub
  vminu.vv:
    opcode:
    - vminu.vv
    - 31..26=0x04
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_min_max_instructions"
    desc:
      v:
        "#_vector_integer_min_max_instructions":
          text:
          - 'vminu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vminu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vminu
  vmin.vv:
    opcode:
    - vmin.vv
    - 31..26=0x05
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_min_max_instructions"
    desc:
      v:
        "#_vector_integer_min_max_instructions":
          text:
          - 'vmin.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmin.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmin
  vmaxu.vv:
    opcode:
    - vmaxu.vv
    - 31..26=0x06
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_min_max_instructions"
    desc:
      v:
        "#_vector_integer_min_max_instructions":
          text:
          - 'vmaxu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmaxu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmaxu
  vmax.vv:
    opcode:
    - vmax.vv
    - 31..26=0x07
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_min_max_instructions"
    desc:
      v:
        "#_vector_integer_min_max_instructions":
          text:
          - 'vmax.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmax.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmax
  vand.vv:
    opcode:
    - vand.vv
    - 31..26=0x09
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - 'vand.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vand.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vand.vi vd, vs2, imm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vand
  vor.vv:
    opcode:
    - vor.vv
    - 31..26=0x0a
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - 'vor.vv vd, vs2, vs1, vm    # Vector-vector'
          - 'vor.vx vd, vs2, rs1, vm    # vector-scalar'
          - 'vor.vi vd, vs2, imm, vm    # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vor
  vxor.vv:
    opcode:
    - vxor.vv
    - 31..26=0x0b
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - Note vxor vnot.v
          - 'vxor.vv vd, vs2, vs1, vm    # Vector-vector'
          - 'vxor.vx vd, vs2, rs1, vm    # vector-scalar'
          - 'vxor.vi vd, vs2, imm, vm    # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vxor
  vrgather.vv:
    opcode:
    - vrgather.vv
    - 31..26=0x0c
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_register_gather_instruction"
    desc:
      v:
        "#_vector_register_gather_instruction":
          text:
          - For any vrgather instruction, the destination vector register group cannot
            overlap with the source vector register groups, including the mask register
            if the operation is masked, otherwise an illegal instruction exception
            is raised.
          - Note vrgather.vv can only reference vector elements 0-255.
          - 'vrgather.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];'
          - 'vrgather.vx vd, vs2, rs1, vm # vd[i] = (x[rs1] &gt;= VLMAX) ? 0 : vs2[x[rs1]]'
          - 'vrgather.vi vd, vs2, uimm, vm # vd[i] = (uimm &gt;= VLMAX) ? 0 : vs2[uimm]'
        "#_vector_register_gather_instructions_under_ediv":
          text:
          - vrgather.vv v3, v1, v2
          - vrgather.vi v4, v1, 1
        "#_vector_instruction_listing":
          text:
          - vrgather
  vadc.vvm:
    opcode:
    - vadc.vvm
    - 31..26=0x10
    - 25=1
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - ". Due to encoding constraints, the carry input must come from the implicit
            v0 vadc and vsbc add or subtract the source operands and the carry-in
            or borrow-in, and write the result to vector register vd"
          - For vadc and vsbc , an illegal instruction exception is raised if the
            destination vector register is v0 and LMUL > 1.
          - 'vadc.vvm   vd, vs2, vs1, v0  # Vector-vector'
          - 'vadc.vxm   vd, vs2, rs1, v0  # Vector-scalar'
          - 'vadc.vim   vd, vs2, imm, v0  # Vector-immediate'
          - 'vadc.vvm v4, v4, v8, v0   # Calc new sum'
        "#_vector_add_with_carry_subtract_with_borrow_reserved_under_ediv_1":
          text:
          - For EDIV > 1, vadc , vmadc , vsbc , vmsbc are reserved.
        "#_vector_instruction_listing":
          text:
          - vadc
  vmadc.vvm:
    opcode:
    - vmadc.vvm
    - 31..26=0x11
    - 25=1
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vmadc and vmsbc add or subtract the source operands, optionally add the
            carry-in or subtract the borrow-in if masked ( vm=0 ), and write the result
            back to mask register vd
          - For vmadc and vmsbc , an illegal instruction exception is raised if the
            destination vector register overlaps a source vector register group and
            LMUL > 1.
          - 'vmadc.vvm   vd, vs2, vs1, v0  # Vector-vector'
          - 'vmadc.vxm   vd, vs2, rs1, v0  # Vector-scalar'
          - 'vmadc.vim   vd, vs2, imm, v0  # Vector-immediate'
          - 'vmadc.vv    vd, vs2, vs1      # Vector-vector, no carry-in'
          - 'vmadc.vx    vd, vs2, rs1      # Vector-scalar, no carry-in'
          - 'vmadc.vi    vd, vs2, imm      # Vector-immediate, no carry-in'
          - 'vmadc.vvm v1, v4, v8, v0  # Get carry into temp register v1'
        "#_vector_instruction_listing":
          text:
          - vmadc
  vsbc.vvm:
    opcode:
    - vsbc.vvm
    - 31..26=0x12
    - 25=1
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - The subtract with borrow instruction vsbc performs the equivalent function
            to support long word arithmetic for subtraction
          - 'vsbc.vvm   vd, vs2, vs1, v0  # Vector-vector'
          - 'vsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vsbc
  vmsbc.vvm:
    opcode:
    - vmsbc.vvm
    - 31..26=0x13
    - 25=1
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - For vmsbc , the borrow is defined to be 1 iff the difference, prior to
            truncation, is negative.
          - 'vmsbc.vvm   vd, vs2, vs1, v0  # Vector-vector'
          - 'vmsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar'
          - 'vmsbc.vv    vd, vs2, vs1      # Vector-vector, no borrow-in'
          - 'vmsbc.vx    vd, vs2, rs1      # Vector-scalar, no borrow-in'
        "#_vector_instruction_listing":
          text:
          - vmsbc
  vmerge.vvm:
    opcode:
    - vmerge.vvm
    - 31..26=0x17
    - 25=0
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_merge_instructions"
    desc:
      v:
        "#_vector_integer_merge_instructions":
          text:
          - The vmerge instructions are always masked ( vm=0 )
          - 'vmerge.vvm vd, vs2, vs1, v0  # vd[i] = v0[i].LSB ? vs1[i] : vs2[i]'
          - 'vmerge.vxm vd, vs2, rs1, v0  # vd[i] = v0[i].LSB ? x[rs1] : vs2[i]'
          - 'vmerge.vim vd, vs2, imm, v0  # vd[i] = v0[i].LSB ? imm    : vs2[i]'
        "#_whole_vector_register_move":
          text:
          - This encoding is chosen as it is close to the related vmerge encoding,
            and it is unlikely the vsmul instruction would benefit from an immediate
            form
        "#_vector_instruction_listing":
          text:
          - vmerge/vmv
  vmv.v.v:
    opcode:
    - vmv.v.v
    - 31..26=0x17
    - 25=1
    - 24..20=0
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_vector_integer_move_instructions"
    desc:
      v:
        "#_vector_integer_move_instructions":
          text:
          - This instruction copies the vs1 , rs1 , or immediate operand to the first
            vl Note vmv.v.i vd, 0; vmerge.vim vd, vd, 1, v0
          - 'vmv.v.v vd, vs1 # vd[i] = vs1[i]'
          - 'vmv.v.x vd, rs1 # vd[i] = rs1'
          - 'vmv.v.i vd, imm # vd[i] = imm'
        "#_example_using_vector_mask_instructions":
          text:
          - 'vmv.v.i v0, 0           # Splat zero.'
        "#_integer_scalar_move_instructions":
          text:
          - The vmv.x.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination integer register
          - The vmv.s.x instruction copies the scalar integer register to element
            0 of the destination vector register
          - The encodings corresponding to the masked versions ( vm=0 ) of vmv.x.s
            vmv.s.x are reserved.
          - 'vmv.x.s rd, vs2  # x[rd] = vs2[0] (rs1=0)'
          - 'vmv.s.x vd, rs1  # vd[0] = x[rs1] (vs2=0)'
        "#_whole_vector_register_move":
          text:
          - The vmv<nf>r.v instructions copy whole vector registers (i.e., all VLEN
            bits) ignoring the current settings of the vl and vtype Note vl or vtype
          - 'vmv&lt;nf&gt;r.v vd, vs2  # General form'
        "#_vector_instruction_listing":
          text:
          - vmv<nf>r
          - vmv.s.x
          - vmv.x.s
        "#_example_with_mixed_width_mask_and_compute":
          text:
          - 'vmv.v.i v4, 1                 # Splat immediate to destination'
  vseq.vv:
    opcode:
    - vseq.vv
    - 31..26=0x18
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsne.vv:
    opcode:
    - vsne.vv
    - 31..26=0x19
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsltu.vv:
    opcode:
    - vsltu.vv
    - 31..26=0x1a
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vslt.vv:
    opcode:
    - vslt.vv
    - 31..26=0x1b
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsleu.vv:
    opcode:
    - vsleu.vv
    - 31..26=0x1c
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsle.vv:
    opcode:
    - vsle.vv
    - 31..26=0x1d
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsaddu.vv:
    opcode:
    - vsaddu.vv
    - 31..26=0x20
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - 'vsaddu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsaddu.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsaddu.vi vd, vs2, imm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsaddu
  vsadd.vv:
    opcode:
    - vsadd.vv
    - 31..26=0x21
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - 'vsadd.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsadd.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsadd.vi vd, vs2, imm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsadd
  vssubu.vv:
    opcode:
    - vssubu.vv
    - 31..26=0x22
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - 'vssubu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vssubu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vssubu
  vssub.vv:
    opcode:
    - vssub.vv
    - 31..26=0x23
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - 'vssub.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vssub.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vssub
  vaadd.vv:
    opcode:
    - vaadd.vv
    - 31..26=0x24
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_averaging_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_averaging_add_and_subtract":
          text:
          - For vaaddu , vaadd , and vasub , there can be no overflow in the result
          - 'vaadd.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] + vs1[i], 1)'
          - 'vaadd.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] + x[rs1], 1)'
        "#_vector_instruction_listing":
          text:
          - vaadd
  vsll.vv:
    opcode:
    - vsll.vv
    - 31..26=0x25
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_bit_shift_instructions"
    desc:
      v:
        "#_vector_single_width_bit_shift_instructions":
          text:
          - 'vsll.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsll.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsll.vi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_iota_instruction":
          text:
          - 'vsll.vi v16, v16, 2, v0.t     # Multiply offsets by four bytes'
        "#_regular_vector_arithmetic_instructions_under_ediv":
          text:
          - 'vsll.vx v1,v2,x1                     # Performs a vector of 4*vl 8-bit
            shifts.'
        "#_vector_instruction_listing":
          text:
          - vsll
  vasub.vv:
    opcode:
    - vasub.vv
    - 31..26=0x26
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_averaging_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_averaging_add_and_subtract":
          text:
          - 'vasub.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] - vs1[i], 1)'
          - 'vasub.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] - x[rs1], 1)'
        "#_vector_instruction_listing":
          text:
          - vasub
  vsmul.vv:
    opcode:
    - vsmul.vv
    - 31..26=0x27
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_fractional_multiply_with_rounding_and_saturation"
    desc:
      v:
        "#_vector_single_width_fractional_multiply_with_rounding_and_saturation":
          text:
          - 'vsmul.vv vd, vs2, vs1, vm  # vd[i] = clip(roundoff_signed(vs2[i]*vs1[i],
            SEW-1))'
          - 'vsmul.vx vd, vs2, rs1, vm  # vd[i] = clip(roundoff_signed(vs2[i]*x[rs1],
            SEW-1))'
        "#_whole_vector_register_move":
          text:
          - Note vsmul vm=1 )
        "#_vector_instruction_listing":
          text:
          - vsmul
  vsrl.vv:
    opcode:
    - vsrl.vv
    - 31..26=0x28
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_examples"
    desc:
      v:
        "#_examples":
          text:
          - 'vsrl.vi  v8, v8, 3      # Shift elements'
          - vsrl.vi v8, v8, 3
        "#_vector_single_width_bit_shift_instructions":
          text:
          - 'vsrl.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsrl.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsrl.vi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsrl
  vsra.vv:
    opcode:
    - vsra.vv
    - 31..26=0x29
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_bit_shift_instructions"
    desc:
      v:
        "#_vector_single_width_bit_shift_instructions":
          text:
          - 'vsra.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsra.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsra.vi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsra
  vssrl.vv:
    opcode:
    - vssrl.vv
    - 31..26=0x2a
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_scaling_shift_instructions"
    desc:
      v:
        "#_vector_single_width_scaling_shift_instructions":
          text:
          - The scaling right shifts have both zero-extending ( vssrl ) and sign-extending
            ( vssra ) forms
          - 'vssrl.vv vd, vs2, vs1, vm   # vd[i] = roundoff_unsigned(vs2[i], vs1[i])'
          - 'vssrl.vx vd, vs2, rs1, vm   # vd[i] = roundoff_unsigned(vs2[i], x[rs1])'
          - 'vssrl.vi vd, vs2, uimm, vm   # vd[i] = roundoff_unsigned(vs2[i], uimm)'
        "#_vector_instruction_listing":
          text:
          - vssrl
  vssra.vv:
    opcode:
    - vssra.vv
    - 31..26=0x2b
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_scaling_shift_instructions"
    desc:
      v:
        "#_vector_single_width_scaling_shift_instructions":
          text:
          - 'vssra.vv vd, vs2, vs1, vm   # vd[i] = roundoff_signed(vs2[i],vs1[i])'
          - 'vssra.vx vd, vs2, rs1, vm   # vd[i] = roundoff_signed(vs2[i], x[rs1])'
          - 'vssra.vi vd, vs2, uimm, vm   # vd[i] = roundoff_signed(vs2[i], uimm)'
        "#_vector_instruction_listing":
          text:
          - vssra
  vnsrl.vv:
    opcode:
    - vnsrl.vv
    - 31..26=0x2c
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_narrowing_integer_right_shift_instructions"
    desc:
      v:
        "#_vector_narrowing_integer_right_shift_instructions":
          text:
          - 'vnsrl.wv vd, vs2, vs1, vm   # vector-vector'
          - 'vnsrl.wx vd, vs2, rs1, vm   # vector-scalar'
          - 'vnsrl.wi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vnsrl
  vnsra.vv:
    opcode:
    - vnsra.vv
    - 31..26=0x2d
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#sec-narrowing"
    desc:
      v:
        "#sec-narrowing":
          text:
          - The double-width source vector register group is signified by a w in the
            source operand suffix (e.g., vnsra.wv )
        "#_vector_narrowing_integer_right_shift_instructions":
          text:
          - 'vnsra.wv vd, vs2, vs1, vm   # vector-vector'
          - 'vnsra.wx vd, vs2, rs1, vm   # vector-scalar'
          - 'vnsra.wi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vnsra
  vnclipu.vv:
    opcode:
    - vnclipu.vv
    - 31..26=0x2e
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - For vnclipu / vnclip , the rounding mode is specified in the vxrm For
            vnclipu , the shifted rounded source value is treated as an unsigned integer
            and saturates if the result would overflow the destination viewed as an
            unsigned integer.
          - 'vnclipu.wv vd, vs2, vs1, vm   # vd[i] = clip(roundoff_unsigned(vs2[i],
            vs1[i]))'
          - 'vnclipu.wx vd, vs2, rs1, vm   # vd[i] = clip(roundoff_unsigned(vs2[i],
            x[rs1]))'
          - 'vnclipu.wi vd, vs2, uimm, vm  # vd[i] = clip(roundoff_unsigned(vs2[i],
            uimm5))'
        "#_vector_instruction_listing":
          text:
          - vnclipu
  vnclip.vv:
    opcode:
    - vnclip.vv
    - 31..26=0x2f
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - The vnclip instructions are used to pack a fixed-point value into a narrower
            destination
          - For vnclip , the shifted rounded source value is treated as a signed integer
            and saturates if the result would overflow the destination viewed as a
            signed integer.
          - 'vnclip.wv vd, vs2, vs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], vs1[i]))'
          - 'vnclip.wx vd, vs2, rs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], x[rs1]))'
          - 'vnclip.wi vd, vs2, uimm, vm  # vd[i] = clip(roundoff_signed(vs2[i], uimm5))'
        "#_vector_instruction_listing":
          text:
          - vnclip
  vwredsumu.vs:
    opcode:
    - vwredsumu.vs
    - 31..26=0x30
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_reduction_instructions"
    desc:
      v:
        "#_vector_widening_integer_reduction_instructions":
          text:
          - The unsigned vwredsumu.vs instruction zero-extends the SEW-wide vector
            elements before summing them, then adds the 2*SEW-width scalar element,
            and stores the result in a 2*SEW-width scalar element.
          - 'vwredsumu.vs vd, vs2, vs1, vm   # 2*SEW = 2*SEW + sum(zero-extend(SEW))'
        "#_vector_instruction_listing":
          text:
          - vwredsumu
  vwredsum.vs:
    opcode:
    - vwredsum.vs
    - 31..26=0x31
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_reduction_instructions"
    desc:
      v:
        "#_vector_widening_integer_reduction_instructions":
          text:
          - The vwredsum.vs instruction sign-extends the SEW-wide vector elements
            before summing them.
          - 'vwredsum.vs  vd, vs2, vs1, vm   # 2*SEW = 2*SEW + sum(sign-extend(SEW))'
        "#_vector_reduction_instructions_under_ediv":
          text:
          - 'vwredsum.vs v1, v2, v3 # v1[i][15:0] = v2[i][31:24] + v2[i][23:16]'
        "#_vector_instruction_listing":
          text:
          - vwredsum
  vdotu.vv:
    opcode:
    - vdotu.vv
    - 31..26=0x38
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_dot_product_instruction"
    desc:
      v:
        "#_vector_integer_dot_product_instruction":
          text:
          - 'vdotu.vv vd, vs2, vs1, vm  # Vector-vector'
        "#_vector_instruction_listing":
          text:
          - vdotu
  vdot.vv:
    opcode:
    - vdot.vv
    - 31..26=0x39
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_dot_product_instruction"
    desc:
      v:
        "#_vector_integer_dot_product_instruction":
          text:
          - The integer dot-product reduction vdot.vv performs an element-wise multiplication
            between the source sub-elements then accumulates the results into the
            destination vector element
          - 'vdot.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vdot.vv  vd, vs2, vs1, vm   # vd[i][31:0] += vs2[i][31:0] * vs1[i][31:0]'
          - 'vdot.vv vd, vs2, vs1, vm # vd[i][31:0] += vs2[i][31:16] * vs1[i][31:16]'
          - 'vdot.vv vd, vs2, vs1, vm # vd[i][31:0] += vs2[i][31:24] * vs1[i][31:24]'
        "#_vector_instruction_listing":
          text:
          - vdot
  vwsmaccu.vv:
    opcode:
    - vwsmaccu.vv
    - 31..26=0x3c
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vwsmacc.vv:
    opcode:
    - vwsmacc.vv
    - 31..26=0x3d
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vwsmaccsu.vv:
    opcode:
    - vwsmaccsu.vv
    - 31..26=0x3e
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vadd.vi:
    opcode:
    - vadd.vi
    - 31..26=0x00
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: &19
    - vs2
    - simm5
    - vd
    main_desc: v
    main_id: "#_vector_single_width_integer_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_integer_add_and_subtract":
          text:
          - 'vadd.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vadd.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vadd.vi vd, vs2, imm, vm   # vector-immediate'
        "#_regular_vector_arithmetic_instructions_under_ediv":
          text:
          - 'vadd.vv v1,v2,v3                     # Performs a vector of 4*vl 8-bit
            additions.'
        "#_vector_instruction_listing":
          text:
          - vadd
        "#_vector_vector_add_example":
          text:
          - 'vadd.vv v2, v0, v1        # Sum vectors'
  vrsub.vi:
    opcode:
    - vrsub.vi
    - 31..26=0x03
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_single_width_integer_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_integer_add_and_subtract":
          text:
          - 'vrsub.vx vd, vs2, rs1, vm   # vd[i] = rs1 - vs2[i]'
          - 'vrsub.vi vd, vs2, imm, vm   # vd[i] = imm - vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vrsub
  vand.vi:
    opcode:
    - vand.vi
    - 31..26=0x09
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - 'vand.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vand.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vand.vi vd, vs2, imm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vand
  vor.vi:
    opcode:
    - vor.vi
    - 31..26=0x0a
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - 'vor.vv vd, vs2, vs1, vm    # Vector-vector'
          - 'vor.vx vd, vs2, rs1, vm    # vector-scalar'
          - 'vor.vi vd, vs2, imm, vm    # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vor
  vxor.vi:
    opcode:
    - vxor.vi
    - 31..26=0x0b
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - Note vxor vnot.v
          - 'vxor.vv vd, vs2, vs1, vm    # Vector-vector'
          - 'vxor.vx vd, vs2, rs1, vm    # vector-scalar'
          - 'vxor.vi vd, vs2, imm, vm    # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vxor
  vrgather.vi:
    opcode:
    - vrgather.vi
    - 31..26=0x0c
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_register_gather_instruction"
    desc:
      v:
        "#_vector_register_gather_instruction":
          text:
          - For any vrgather instruction, the destination vector register group cannot
            overlap with the source vector register groups, including the mask register
            if the operation is masked, otherwise an illegal instruction exception
            is raised.
          - Note vrgather.vv can only reference vector elements 0-255.
          - 'vrgather.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];'
          - 'vrgather.vx vd, vs2, rs1, vm # vd[i] = (x[rs1] &gt;= VLMAX) ? 0 : vs2[x[rs1]]'
          - 'vrgather.vi vd, vs2, uimm, vm # vd[i] = (uimm &gt;= VLMAX) ? 0 : vs2[uimm]'
        "#_vector_register_gather_instructions_under_ediv":
          text:
          - vrgather.vv v3, v1, v2
          - vrgather.vi v4, v1, 1
        "#_vector_instruction_listing":
          text:
          - vrgather
  vslideup.vi:
    opcode:
    - vslideup.vi
    - 31..26=0x0e
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_slide_instructions"
    desc:
      v:
        "#_vector_slide_instructions":
          text:
          - Note vslideup and vslidedown
          - For all of the vslideup , vslidedown , vslide1up , and vslide1down instructions,
            if vstart &ge; vl , the instruction performs no operation and leaves the
            destination vector register unchanged.
        "#_vector_slideup_instructions":
          text:
          - For vslideup , the value in vl specifies the maximum number of destination
            elements that are written
          - The destination vector register group for vslideup cannot overlap the
            vector register group of the source vector register group or the mask
            register, otherwise an illegal instruction exception is raised.
          - 'vslideup.vx vd, vs2, rs1, vm        # vd[i+rs1] = vs2[i]'
          - 'vslideup.vi vd, vs2, uimm[4:0], vm  # vd[i+uimm] = vs2[i]'
          - vslideup behavior for destination elements
        "#_vector_instruction_listing":
          text:
          - vslideup
  vslidedown.vi:
    opcode:
    - vslidedown.vi
    - 31..26=0x0f
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_slidedown_instructions"
    desc:
      v:
        "#_vector_slidedown_instructions":
          text:
          - For vslidedown , the value in vl specifies the number of destination elements
            that are written.
          - 'vslidedown.vx vd, vs2, rs1, vm       # vd[i] = vs2[i+rs1]'
          - 'vslidedown.vi vd, vs2, uimm[4:0], vm # vd[i] = vs2[i+uimm]'
          - vslidedown behavior for source elements for element i in slide
          - vslidedown behavior for destination element i in slide
        "#_vector_instruction_listing":
          text:
          - vslidedown
  vadc.vim:
    opcode:
    - vadc.vim
    - 31..26=0x10
    - 25=1
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - ". Due to encoding constraints, the carry input must come from the implicit
            v0 vadc and vsbc add or subtract the source operands and the carry-in
            or borrow-in, and write the result to vector register vd"
          - For vadc and vsbc , an illegal instruction exception is raised if the
            destination vector register is v0 and LMUL > 1.
          - 'vadc.vvm   vd, vs2, vs1, v0  # Vector-vector'
          - 'vadc.vxm   vd, vs2, rs1, v0  # Vector-scalar'
          - 'vadc.vim   vd, vs2, imm, v0  # Vector-immediate'
          - 'vadc.vvm v4, v4, v8, v0   # Calc new sum'
        "#_vector_add_with_carry_subtract_with_borrow_reserved_under_ediv_1":
          text:
          - For EDIV > 1, vadc , vmadc , vsbc , vmsbc are reserved.
        "#_vector_instruction_listing":
          text:
          - vadc
  vmadc.vim:
    opcode:
    - vmadc.vim
    - 31..26=0x11
    - 25=1
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vmadc and vmsbc add or subtract the source operands, optionally add the
            carry-in or subtract the borrow-in if masked ( vm=0 ), and write the result
            back to mask register vd
          - For vmadc and vmsbc , an illegal instruction exception is raised if the
            destination vector register overlaps a source vector register group and
            LMUL > 1.
          - 'vmadc.vvm   vd, vs2, vs1, v0  # Vector-vector'
          - 'vmadc.vxm   vd, vs2, rs1, v0  # Vector-scalar'
          - 'vmadc.vim   vd, vs2, imm, v0  # Vector-immediate'
          - 'vmadc.vv    vd, vs2, vs1      # Vector-vector, no carry-in'
          - 'vmadc.vx    vd, vs2, rs1      # Vector-scalar, no carry-in'
          - 'vmadc.vi    vd, vs2, imm      # Vector-immediate, no carry-in'
          - 'vmadc.vvm v1, v4, v8, v0  # Get carry into temp register v1'
        "#_vector_instruction_listing":
          text:
          - vmadc
  vmerge.vim:
    opcode:
    - vmerge.vim
    - 31..26=0x17
    - 25=0
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_integer_merge_instructions"
    desc:
      v:
        "#_vector_integer_merge_instructions":
          text:
          - The vmerge instructions are always masked ( vm=0 )
          - 'vmerge.vvm vd, vs2, vs1, v0  # vd[i] = v0[i].LSB ? vs1[i] : vs2[i]'
          - 'vmerge.vxm vd, vs2, rs1, v0  # vd[i] = v0[i].LSB ? x[rs1] : vs2[i]'
          - 'vmerge.vim vd, vs2, imm, v0  # vd[i] = v0[i].LSB ? imm    : vs2[i]'
        "#_whole_vector_register_move":
          text:
          - This encoding is chosen as it is close to the related vmerge encoding,
            and it is unlikely the vsmul instruction would benefit from an immediate
            form
        "#_vector_instruction_listing":
          text:
          - vmerge/vmv
  vmv.v.i:
    opcode:
    - vmv.v.i
    - 31..26=0x17
    - 25=1
    - 24..20=0
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: &33
    - simm5
    - vd
    main_desc: v
    main_id: "#_vector_integer_move_instructions"
    desc:
      v:
        "#_vector_integer_move_instructions":
          text:
          - This instruction copies the vs1 , rs1 , or immediate operand to the first
            vl Note vmv.v.i vd, 0; vmerge.vim vd, vd, 1, v0
          - 'vmv.v.v vd, vs1 # vd[i] = vs1[i]'
          - 'vmv.v.x vd, rs1 # vd[i] = rs1'
          - 'vmv.v.i vd, imm # vd[i] = imm'
        "#_example_using_vector_mask_instructions":
          text:
          - 'vmv.v.i v0, 0           # Splat zero.'
        "#_integer_scalar_move_instructions":
          text:
          - The vmv.x.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination integer register
          - The vmv.s.x instruction copies the scalar integer register to element
            0 of the destination vector register
          - The encodings corresponding to the masked versions ( vm=0 ) of vmv.x.s
            vmv.s.x are reserved.
          - 'vmv.x.s rd, vs2  # x[rd] = vs2[0] (rs1=0)'
          - 'vmv.s.x vd, rs1  # vd[0] = x[rs1] (vs2=0)'
        "#_whole_vector_register_move":
          text:
          - The vmv<nf>r.v instructions copy whole vector registers (i.e., all VLEN
            bits) ignoring the current settings of the vl and vtype Note vl or vtype
          - 'vmv&lt;nf&gt;r.v vd, vs2  # General form'
        "#_vector_instruction_listing":
          text:
          - vmv<nf>r
          - vmv.s.x
          - vmv.x.s
        "#_example_with_mixed_width_mask_and_compute":
          text:
          - 'vmv.v.i v4, 1                 # Splat immediate to destination'
  vseq.vi:
    opcode:
    - vseq.vi
    - 31..26=0x18
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsne.vi:
    opcode:
    - vsne.vi
    - 31..26=0x19
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsleu.vi:
    opcode:
    - vsleu.vi
    - 31..26=0x1c
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsle.vi:
    opcode:
    - vsle.vi
    - 31..26=0x1d
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsgtu.vi:
    opcode:
    - vsgtu.vi
    - 31..26=0x1e
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsgt.vi:
    opcode:
    - vsgt.vi
    - 31..26=0x1f
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsaddu.vi:
    opcode:
    - vsaddu.vi
    - 31..26=0x20
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - 'vsaddu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsaddu.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsaddu.vi vd, vs2, imm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsaddu
  vsadd.vi:
    opcode:
    - vsadd.vi
    - 31..26=0x21
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - 'vsadd.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsadd.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsadd.vi vd, vs2, imm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsadd
  vaadd.vi:
    opcode:
    - vaadd.vi
    - 31..26=0x24
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_single_width_averaging_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_averaging_add_and_subtract":
          text:
          - For vaaddu , vaadd , and vasub , there can be no overflow in the result
          - 'vaadd.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] + vs1[i], 1)'
          - 'vaadd.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] + x[rs1], 1)'
        "#_vector_instruction_listing":
          text:
          - vaadd
  vsll.vi:
    opcode:
    - vsll.vi
    - 31..26=0x25
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_single_width_bit_shift_instructions"
    desc:
      v:
        "#_vector_single_width_bit_shift_instructions":
          text:
          - 'vsll.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsll.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsll.vi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_iota_instruction":
          text:
          - 'vsll.vi v16, v16, 2, v0.t     # Multiply offsets by four bytes'
        "#_regular_vector_arithmetic_instructions_under_ediv":
          text:
          - 'vsll.vx v1,v2,x1                     # Performs a vector of 4*vl 8-bit
            shifts.'
        "#_vector_instruction_listing":
          text:
          - vsll
  vsrl.vi:
    opcode:
    - vsrl.vi
    - 31..26=0x28
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_examples"
    desc:
      v:
        "#_examples":
          text:
          - 'vsrl.vi  v8, v8, 3      # Shift elements'
          - vsrl.vi v8, v8, 3
        "#_vector_single_width_bit_shift_instructions":
          text:
          - 'vsrl.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsrl.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsrl.vi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsrl
  vsra.vi:
    opcode:
    - vsra.vi
    - 31..26=0x29
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_single_width_bit_shift_instructions"
    desc:
      v:
        "#_vector_single_width_bit_shift_instructions":
          text:
          - 'vsra.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vsra.vx vd, vs2, rs1, vm   # vector-scalar'
          - 'vsra.vi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vsra
  vssrl.vi:
    opcode:
    - vssrl.vi
    - 31..26=0x2a
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_single_width_scaling_shift_instructions"
    desc:
      v:
        "#_vector_single_width_scaling_shift_instructions":
          text:
          - The scaling right shifts have both zero-extending ( vssrl ) and sign-extending
            ( vssra ) forms
          - 'vssrl.vv vd, vs2, vs1, vm   # vd[i] = roundoff_unsigned(vs2[i], vs1[i])'
          - 'vssrl.vx vd, vs2, rs1, vm   # vd[i] = roundoff_unsigned(vs2[i], x[rs1])'
          - 'vssrl.vi vd, vs2, uimm, vm   # vd[i] = roundoff_unsigned(vs2[i], uimm)'
        "#_vector_instruction_listing":
          text:
          - vssrl
  vssra.vi:
    opcode:
    - vssra.vi
    - 31..26=0x2b
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_single_width_scaling_shift_instructions"
    desc:
      v:
        "#_vector_single_width_scaling_shift_instructions":
          text:
          - 'vssra.vv vd, vs2, vs1, vm   # vd[i] = roundoff_signed(vs2[i],vs1[i])'
          - 'vssra.vx vd, vs2, rs1, vm   # vd[i] = roundoff_signed(vs2[i], x[rs1])'
          - 'vssra.vi vd, vs2, uimm, vm   # vd[i] = roundoff_signed(vs2[i], uimm)'
        "#_vector_instruction_listing":
          text:
          - vssra
  vnsrl.vi:
    opcode:
    - vnsrl.vi
    - 31..26=0x2c
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_narrowing_integer_right_shift_instructions"
    desc:
      v:
        "#_vector_narrowing_integer_right_shift_instructions":
          text:
          - 'vnsrl.wv vd, vs2, vs1, vm   # vector-vector'
          - 'vnsrl.wx vd, vs2, rs1, vm   # vector-scalar'
          - 'vnsrl.wi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vnsrl
  vnsra.vi:
    opcode:
    - vnsra.vi
    - 31..26=0x2d
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#sec-narrowing"
    desc:
      v:
        "#sec-narrowing":
          text:
          - The double-width source vector register group is signified by a w in the
            source operand suffix (e.g., vnsra.wv )
        "#_vector_narrowing_integer_right_shift_instructions":
          text:
          - 'vnsra.wv vd, vs2, vs1, vm   # vector-vector'
          - 'vnsra.wx vd, vs2, rs1, vm   # vector-scalar'
          - 'vnsra.wi vd, vs2, uimm, vm   # vector-immediate'
        "#_vector_instruction_listing":
          text:
          - vnsra
  vnclipu.vi:
    opcode:
    - vnclipu.vi
    - 31..26=0x2e
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - For vnclipu / vnclip , the rounding mode is specified in the vxrm For
            vnclipu , the shifted rounded source value is treated as an unsigned integer
            and saturates if the result would overflow the destination viewed as an
            unsigned integer.
          - 'vnclipu.wv vd, vs2, vs1, vm   # vd[i] = clip(roundoff_unsigned(vs2[i],
            vs1[i]))'
          - 'vnclipu.wx vd, vs2, rs1, vm   # vd[i] = clip(roundoff_unsigned(vs2[i],
            x[rs1]))'
          - 'vnclipu.wi vd, vs2, uimm, vm  # vd[i] = clip(roundoff_unsigned(vs2[i],
            uimm5))'
        "#_vector_instruction_listing":
          text:
          - vnclipu
  vnclip.vi:
    opcode:
    - vnclip.vi
    - 31..26=0x2f
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *19
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - The vnclip instructions are used to pack a fixed-point value into a narrower
            destination
          - For vnclip , the shifted rounded source value is treated as a signed integer
            and saturates if the result would overflow the destination viewed as a
            signed integer.
          - 'vnclip.wv vd, vs2, vs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], vs1[i]))'
          - 'vnclip.wx vd, vs2, rs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], x[rs1]))'
          - 'vnclip.wi vd, vs2, uimm, vm  # vd[i] = clip(roundoff_signed(vs2[i], uimm5))'
        "#_vector_instruction_listing":
          text:
          - vnclip
  vredsum.vs:
    opcode:
    - vredsum.vs
    - 31..26=0x00
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_integer_reduction_instructions":
          text:
          - 'vredsum.vs  vd, vs2, vs1, vm   # vd[0] =  sum( vs1[0] , vs2[*] )'
        "#_vector_instruction_listing":
          text:
          - vredsum
  vredand.vs:
    opcode:
    - vredand.vs
    - 31..26=0x01
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_integer_reduction_instructions":
          text:
          - 'vredand.vs  vd, vs2, vs1, vm   # vd[0] =  and( vs1[0] , vs2[*] )'
        "#_vector_instruction_listing":
          text:
          - vredand
  vredor.vs:
    opcode:
    - vredor.vs
    - 31..26=0x02
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_integer_reduction_instructions":
          text:
          - 'vredor.vs   vd, vs2, vs1, vm   # vd[0] =   or( vs1[0] , vs2[*] )'
        "#_vector_instruction_listing":
          text:
          - vredor
  vredxor.vs:
    opcode:
    - vredxor.vs
    - 31..26=0x03
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_integer_reduction_instructions":
          text:
          - 'vredxor.vs  vd, vs2, vs1, vm   # vd[0] =  xor( vs1[0] , vs2[*] )'
        "#_vector_instruction_listing":
          text:
          - vredxor
  vredminu.vs:
    opcode:
    - vredminu.vs
    - 31..26=0x04
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_integer_reduction_instructions":
          text:
          - 'vredminu.vs vd, vs2, vs1, vm   # vd[0] = minu( vs1[0] , vs2[*] )'
        "#_vector_instruction_listing":
          text:
          - vredminu
  vredmin.vs:
    opcode:
    - vredmin.vs
    - 31..26=0x05
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_integer_reduction_instructions":
          text:
          - 'vredmin.vs  vd, vs2, vs1, vm   # vd[0] =  min( vs1[0] , vs2[*] )'
        "#_vector_instruction_listing":
          text:
          - vredmin
  vredmaxu.vs:
    opcode:
    - vredmaxu.vs
    - 31..26=0x06
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_integer_reduction_instructions":
          text:
          - 'vredmaxu.vs vd, vs2, vs1, vm   # vd[0] = maxu( vs1[0] , vs2[*] )'
        "#_vector_instruction_listing":
          text:
          - vredmaxu
  vredmax.vs:
    opcode:
    - vredmax.vs
    - 31..26=0x07
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_reduction_instructions"
    desc:
      v:
        "#_vector_single_width_integer_reduction_instructions":
          text:
          - 'vredmax.vs  vd, vs2, vs1, vm   # vd[0] =  max( vs1[0] , vs2[*] )'
        "#_vector_reduction_instructions_under_ediv":
          text:
          - 'vredmax.vs v5, v6, v7 # v5[i][7:0] = max(v6[i][31:24], v6[i][23:16],'
        "#_vector_instruction_listing":
          text:
          - vredmax
  vext.x.v:
    opcode:
    - vext.x.v
    - 31..26=0x0c
    - 25=1
    - vs2
    - rs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vmpopc.m:
    opcode:
    - vmpopc.m
    - 31..26=0x14
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - rd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: &20
    - vs2
    - vs1
    - rd
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vmfirst.m:
    opcode:
    - vmfirst.m
    - 31..26=0x15
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - rd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *20
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vcompress.vm:
    opcode:
    - vcompress.vm
    - 31..26=0x17
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_compress_instruction"
    desc:
      v:
        "#_vector_compress_instruction":
          text:
          - vcompress is encoded as an unmasked instruction ( vm=1 )
          - A trap on a vcompress instruction is always reported with a vstart of
            0. Executing a vcompress instruction with a non-zero vstart raises an
            illegal instruction exception.
          - Note vcompress is one of the more difficult instructions to restart with
            a non-zero vstart , so assumption is implementations will choose not do
            that but will instead restart from element 0. This does mean elements
            in destination register after vstart will already have been updated
          - 'vcompress.vm vd, vs2, vs1  # Compress into vd elements of vs2 where vs1
            is enabled'
          - Example use of vcompress instruction
          - vcompress.vm v2, v1, v0
        "#_vector_instruction_listing":
          text:
          - vcompress
  vmandnot.mm:
    opcode:
    - vmandnot.mm
    - 31..26=0x18
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_integer_comparison_instructions"
    desc:
      v:
        "#_vector_integer_comparison_instructions":
          text:
          - 'expansion: vmslt{u}.vx vt, va, x;  vmandnot.mm vd, vd, vt'
        "#sec-mask-register-logical":
          text:
          - vmandnot.mm vd, src2, src1
          - vmandnot.mm vd, src1, src2
          - 'vmandnot.mm vd, vs2, vs1  # vd[i] =   vs2[i].LSB &amp;&amp; !vs1[i].LSB'
        "#_vector_instruction_listing":
          text:
          - vmandnot
  vmand.mm:
    opcode:
    - vmand.mm
    - 31..26=0x19
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_floating_point_compare_instructions"
    desc:
      v:
        "#_vector_floating_point_compare_instructions":
          text:
          - Note vmfeq vmand instruction, but this more efficient sequence incorrectly
            fails to raise the invalid exception when an element of va contains a
            quiet NaN and the corresponding element in vb contains a signaling NaN
          - 'vmand.mm v0, v0, v1        # Only set where A and B are ordered,'
        "#sec-mask-register-logical":
          text:
          - vmand.mm vd, src1, src2
          - vmand.mm vd, src2, src2
          - vmand.mm vd, src1, src1
          - 'vmand.mm vd, vs2, vs1     # vd[i] =   vs2[i].LSB &amp;&amp;  vs1[i].LSB'
          - 'vmcpy.m vd, vs  =&gt; vmand.mm vd, vs, vs  # Copy mask register'
        "#_vector_instruction_listing":
          text:
          - vmand
  vmor.mm:
    opcode:
    - vmor.mm
    - 31..26=0x1a
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - 'vmor.mm  vd, vs2, vs1     # vd[i] =   vs2[i].LSB ||  vs1[i].LSB'
        "#_vector_instruction_listing":
          text:
          - vmor
  vmxor.mm:
    opcode:
    - vmxor.mm
    - 31..26=0x1b
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_integer_comparison_instructions"
    desc:
      v:
        "#_vector_integer_comparison_instructions":
          text:
          - 'expansion: vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0'
        "#sec-mask-register-logical":
          text:
          - vmxor.mm vd, vd, vd
          - vmxor.mm vd, src1, src2
          - 'vmxor.mm  vd, vs2, vs1    # vd[i] =   vs2[i].LSB ^^  vs1[i].LSB'
          - 'vmclr.m vd     =&gt; vmxor.mm vd, vd, vd   # Clear mask register'
        "#_vector_instruction_listing":
          text:
          - vmxor
  vmornot.mm:
    opcode:
    - vmornot.mm
    - 31..26=0x1c
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - vmornot.mm vd, src2, src1
          - vmornot.mm vd, src1, src2
          - 'vmornot.mm  vd, vs2, vs1  # vd[i] =   vs2[i].LSB || !vs1[i].LSB'
        "#_vector_instruction_listing":
          text:
          - vmornot
  vmnand.mm:
    opcode:
    - vmnand.mm
    - 31..26=0x1d
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_integer_comparison_instructions"
    desc:
      v:
        "#_vector_integer_comparison_instructions":
          text:
          - 'expansion: vmslt{u}.vx vd, va, x; vmnand.mm vd, vd, vd'
        "#sec-mask-register-logical":
          text:
          - vmnand.mm vd, src1, src1
          - vmnand.mm vd, src2, src2
          - vmnand.mm vd, src1, src2
          - 'vmnand.mm vd, vs2, vs1    # vd[i] = !(vs2[i].LSB &amp;&amp;  vs1[i].LSB)'
          - 'vmnot.m vd, vs =&gt; vmnand.mm vd, vs, vs  # Invert bits'
        "#_vector_instruction_listing":
          text:
          - vmnand
  vmnor.mm:
    opcode:
    - vmnor.mm
    - 31..26=0x1e
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - vmnor.mm vd, src1, src2
          - 'vmnor.mm  vd, vs2, vs1    # vd[i] = !(vs2[i[.LSB ||  vs1[i].LSB)'
        "#_vector_instruction_listing":
          text:
          - vmnor
  vmxnor.mm:
    opcode:
    - vmxnor.mm
    - 31..26=0x1f
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - vmxnor.mm vd, src1, src2
          - vmxnor.mm vd, vd, vd
          - 'vmxnor.mm vd, vs2, vs1    # vd[i] = !(vs2[i].LSB ^^  vs1[i].LSB)'
          - 'vmset.m vd     =&gt; vmxnor.mm vd, vd, vd  # Set mask register'
        "#_vector_instruction_listing":
          text:
          - vmxnor
  vmsbf.m:
    opcode:
    - vmsbf.m
    - 31..26=0x16
    - vm
    - vs2
    - 19..15=0x01
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: &21
    - vs2
    - vd
    main_desc: v
    main_id: "#__code_vfirst_code_find_first_set_mask_bit"
    desc:
      v:
        "#__code_vfirst_code_find_first_set_mask_bit":
          text:
          - vmsbf.m
        "#__code_vmsbf_m_code_set_before_first_mask_bit":
          text:
          - The vmsbf.m instruction takes a mask register as input and writes results
            to a mask register
          - Traps on vmsbf.m are always reported with a vstart of 0. The vmsbf instruction
            will raise an illegal instruction exception if vstart is non-zero.
          - vmsbf.m vd, vs2, vm
          - vmsbf.m v2, v3
          - vmsbf.m v2, v3
          - vmsbf.m v2, v3
          - vmsbf.m v2, v3, v0.t
        "#_instructions_not_affected_by_ediv":
          text:
          - Vector mask population count ( vpopc ), find-first and related instructions
            ( vfirst , vmsbf , vmsif , vmsof ), iota ( viota ), and element index
            ( vid ) instructions are unaffected by EDIV.
        "#_vector_instruction_listing":
          text:
          - vmsbf
  vmsof.m:
    opcode:
    - vmsof.m
    - 31..26=0x16
    - vm
    - vs2
    - 19..15=0x02
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *21
    main_desc: v
    main_id: "#__code_vmsif_m_code_set_including_first_mask_bit"
    desc:
      v:
        "#__code_vmsif_m_code_set_including_first_mask_bit":
          text:
          - vmsof.m
        "#__code_vmsof_m_code_set_only_first_mask_bit":
          text:
          - Traps on vmsof.m are always reported with a vstart of 0. The vmsof instruction
            will raise an illegal instruction exception if vstart is non-zero.
          - vmsof.m vd, vs2, vm
          - vmsof.m v2, v3
          - vmsof.m v2, v3
          - vmsof.m v2, v3, v0.t
        "#_vector_instruction_listing":
          text:
          - vmsof
  vmsif.m:
    opcode:
    - vmsif.m
    - 31..26=0x16
    - vm
    - vs2
    - 19..15=0x03
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *21
    main_desc: v
    main_id: "#__code_vmsbf_m_code_set_before_first_mask_bit"
    desc:
      v:
        "#__code_vmsbf_m_code_set_before_first_mask_bit":
          text:
          - vmsif.m
        "#__code_vmsif_m_code_set_including_first_mask_bit":
          text:
          - Traps on vmsif.m are always reported with a vstart of 0. The vmsif instruction
            will raise an illegal instruction exception if vstart is non-zero.
          - vmsif.m vd, vs2, vm
          - vmsif.m v2, v3
          - vmsif.m v2, v3
          - vmsif.m v2, v3, v0.t
        "#_example_using_vector_mask_instructions":
          text:
          - 'vmsif.m v0, v0          # Set mask up to and including zero byte.'
          - 'vmsif.m v0, v0          # Set mask up to and including zero byte.'
        "#_vector_instruction_listing":
          text:
          - vmsif
  viota.m:
    opcode:
    - viota.m
    - 31..26=0x16
    - vm
    - vs2
    - 19..15=0x10
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *21
    main_desc: v
    main_id: "#_vector_iota_instruction"
    desc:
      v:
        "#_vector_iota_instruction":
          text:
          - The viota.m instruction reads a source vector mask register and writes
            to each element of the destination vector register group the sum of all
            the least-significant bits of elements in the mask register whose index
            is less than the element, e.g., a parallel prefix sum of the mask values.
          - Traps on viota.m are always reported with a vstart of 0, and execution
            is always restarted from the beginning when resuming after a trap handler
          - The viota.m instruction can be combined with memory scatter instructions
            (indexed stores) to perform vector compress functions.
          - viota.m vd, vs2, vm
          - 'viota.m v4, v2 # Unmasked'
          - 'viota.m v4, v2, v0.t # Masked'
          - 'viota.m v16, v0               # Get destination offsets of active elements'
        "#_vector_instruction_listing":
          text:
          - viota
  vid.v:
    opcode:
    - vid.v
    - 31..26=0x16
    - vm
    - vs2
    - 19..15=0x11
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *21
    main_desc: v
    main_id: "#_vector_element_index_instruction"
    desc:
      v:
        "#_vector_element_index_instruction":
          text:
          - The vid.v instruction writes each element&rsquo;s index to the destination
            vector register group, from 0 to vl -1.
          - Note vid.v instruction using the same datapath as viota.m but with an
            implicit set mask source
          - 'vid.v vd, vm  # Write element ID to destination.'
        "#_vector_instruction_listing":
          text:
          - vid
  vdivu.vv:
    opcode:
    - vdivu.vv
    - 31..26=0x20
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_integer_divide_instructions"
    desc:
      v:
        "#_vector_integer_divide_instructions":
          text:
          - 'vdivu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vdivu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vdivu
  vdiv.vv:
    opcode:
    - vdiv.vv
    - 31..26=0x21
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_integer_divide_instructions"
    desc:
      v:
        "#_vector_integer_divide_instructions":
          text:
          - 'vdiv.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vdiv.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vdiv
  vremu.vv:
    opcode:
    - vremu.vv
    - 31..26=0x22
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_integer_divide_instructions"
    desc:
      v:
        "#_vector_integer_divide_instructions":
          text:
          - 'vremu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vremu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vremu
  vrem.vv:
    opcode:
    - vrem.vv
    - 31..26=0x23
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_integer_divide_instructions"
    desc:
      v:
        "#_vector_integer_divide_instructions":
          text:
          - 'vrem.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vrem.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vrem
  vmulhu.vv:
    opcode:
    - vmulhu.vv
    - 31..26=0x24
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_instructions":
          text:
          - 'vmulhu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmulhu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmulhu
  vmul.vv:
    opcode:
    - vmul.vv
    - 31..26=0x25
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_examples"
    desc:
      v:
        "#_examples":
          text:
          - 'vmul.vx  v8, v8, x10    # 32b multiply result'
        "#_vector_single_width_integer_multiply_instructions":
          text:
          - 'vmul.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmul.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmul
  vmulhsu.vv:
    opcode:
    - vmulhsu.vv
    - 31..26=0x26
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_instructions":
          text:
          - 'vmulhsu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmulhsu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmulhsu
  vmulh.vv:
    opcode:
    - vmulh.vv
    - 31..26=0x27
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_instructions":
          text:
          - Note vmulh* opcodes perform simple fractional multiplies, but with no
            option to scale, round, and/or saturate the result
          - Can consider changing definition of vmulh , vmulhu , vmulhsu to use vxrm
            rounding mode when discarding low half of product
          - 'vmulh.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmulh.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmulh
  vmadd.vv:
    opcode:
    - vmadd.vv
    - 31..26=0x29
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_add_instructions":
          text:
          - 'vmadd.vv vd, vs1, vs2, vm    # vd[i] = (vs1[i] * vd[i]) + vs2[i]'
          - 'vmadd.vx vd, rs1, vs2, vm    # vd[i] = (x[rs1] * vd[i]) + vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vmadd
  vnmsub.vv:
    opcode:
    - vnmsub.vv
    - 31..26=0x2b
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_add_instructions":
          text:
          - Similarly for the "vnmsub" opcode
          - 'vnmsub.vv vd, vs1, vs2, vm    # vd[i] = -(vs1[i] * vd[i]) + vs2[i]'
          - 'vnmsub.vx vd, rs1, vs2, vm    # vd[i] = -(x[rs1] * vd[i]) + vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vnmsub
  vmacc.vv:
    opcode:
    - vmacc.vv
    - 31..26=0x2d
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_add_instructions":
          text:
          - The integer multiply-add instructions are destructive and are provided
            in two forms, one that overwrites the addend or minuend ( vmacc , vnmsac
            ) and one that overwrites the first multiplicand ( vmadd , vnmsub ).
          - 'vmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]'
          - 'vmacc.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vmacc
  vnmsac.vv:
    opcode:
    - vnmsac.vv
    - 31..26=0x2f
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_add_instructions":
          text:
          - 'vnmsac.vv vd, vs1, vs2, vm    # vd[i] = -(vs1[i] * vs2[i]) + vd[i]'
          - 'vnmsac.vx vd, rs1, vs2, vm    # vd[i] = -(x[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vnmsac
  vwaddu.vv:
    opcode:
    - vwaddu.vv
    - 31..26=0x30
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwaddu.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwaddu.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwaddu.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwaddu.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwaddu
          - vwaddu.w
  vwadd.vv:
    opcode:
    - vwadd.vv
    - 31..26=0x31
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - Can define assembly pseudoinstructions vwcvt.x.x.v vd,vs,vm = vwadd.vx
            vd,vs,x0,vm and vwcvtu.x.x.v vd,vs,vm = vwaddu.vx vd,vs,x0,vm
          - 'vwadd.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwadd.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwadd.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwadd.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwadd
          - vwadd.w
  vwsubu.vv:
    opcode:
    - vwsubu.vv
    - 31..26=0x32
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwsubu.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsubu.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwsubu.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsubu.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwsubu
          - vwsubu.w
  vwsub.vv:
    opcode:
    - vwsub.vv
    - 31..26=0x33
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwsub.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsub.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwsub.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsub.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwsub
          - vwsub.w
  vwaddu.wv:
    opcode:
    - vwaddu.wv
    - 31..26=0x34
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwaddu.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwaddu.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwaddu.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwaddu.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwaddu
          - vwaddu.w
  vwadd.wv:
    opcode:
    - vwadd.wv
    - 31..26=0x35
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - Can define assembly pseudoinstructions vwcvt.x.x.v vd,vs,vm = vwadd.vx
            vd,vs,x0,vm and vwcvtu.x.x.v vd,vs,vm = vwaddu.vx vd,vs,x0,vm
          - 'vwadd.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwadd.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwadd.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwadd.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwadd
          - vwadd.w
  vwsubu.wv:
    opcode:
    - vwsubu.wv
    - 31..26=0x36
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwsubu.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsubu.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwsubu.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsubu.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwsubu
          - vwsubu.w
  vwsub.wv:
    opcode:
    - vwsub.wv
    - 31..26=0x37
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwsub.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsub.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwsub.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsub.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwsub
          - vwsub.w
  vwmulu.vv:
    opcode:
    - vwmulu.vv
    - 31..26=0x38
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_instructions":
          text:
          - 'vwmulu.vv vd, vs2, vs1, vm # vector-vector'
          - 'vwmulu.vx vd, vs2, rs1, vm # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwmulu
  vwmulsu.vv:
    opcode:
    - vwmulsu.vv
    - 31..26=0x3a
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_instructions":
          text:
          - 'vwmulsu.vv vd, vs2, vs1, vm # vector-vector'
          - 'vwmulsu.vx vd, vs2, rs1, vm # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwmulsu
  vwmul.vv:
    opcode:
    - vwmul.vv
    - 31..26=0x3b
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_examples"
    desc:
      v:
        "#_examples":
          text:
          - 'vwmul.vx v8, v4, x10    # 32b in &lt;v8--v15&gt;'
        "#_vector_widening_integer_multiply_instructions":
          text:
          - vwmul.vv  vd, vs2, vs1, vm# vector-vector
          - 'vwmul.vx  vd, vs2, rs1, vm # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwmul
  vwmaccu.vv:
    opcode:
    - vwmaccu.vv
    - 31..26=0x3c
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_add_instructions":
          text:
          - 'vwmaccu.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]'
          - 'vwmaccu.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vwmaccu
  vwmacc.vv:
    opcode:
    - vwmacc.vv
    - 31..26=0x3d
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_add_instructions":
          text:
          - 'vwmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]'
          - 'vwmacc.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vwmacc
  vwmaccsu.vv:
    opcode:
    - vwmaccsu.vv
    - 31..26=0x3e
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *18
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_add_instructions":
          text:
          - 'vwmaccsu.vv vd, vs1, vs2, vm    # vd[i] = +(signed(vs1[i]) * unsigned(vs2[i]))
            + vd[i]'
          - 'vwmaccsu.vx vd, rs1, vs2, vm    # vd[i] = +(signed(x[rs1]) * unsigned(vs2[i]))
            + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vwmaccsu
  vmv.s.x:
    opcode:
    - vmv.s.x
    - 31..26=0x0d
    - 25=1
    - 24..20=0
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *12
    main_desc: v
    main_id: "#_vector_integer_move_instructions"
    desc:
      v:
        "#_vector_integer_move_instructions":
          text:
          - This instruction copies the vs1 , rs1 , or immediate operand to the first
            vl Note vmv.v.i vd, 0; vmerge.vim vd, vd, 1, v0
          - 'vmv.v.v vd, vs1 # vd[i] = vs1[i]'
          - 'vmv.v.x vd, rs1 # vd[i] = rs1'
          - 'vmv.v.i vd, imm # vd[i] = imm'
        "#_example_using_vector_mask_instructions":
          text:
          - 'vmv.v.i v0, 0           # Splat zero.'
        "#_integer_scalar_move_instructions":
          text:
          - The vmv.x.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination integer register
          - The vmv.s.x instruction copies the scalar integer register to element
            0 of the destination vector register
          - The encodings corresponding to the masked versions ( vm=0 ) of vmv.x.s
            vmv.s.x are reserved.
          - 'vmv.x.s rd, vs2  # x[rd] = vs2[0] (rs1=0)'
          - 'vmv.s.x vd, rs1  # vd[0] = x[rs1] (vs2=0)'
        "#_whole_vector_register_move":
          text:
          - The vmv<nf>r.v instructions copy whole vector registers (i.e., all VLEN
            bits) ignoring the current settings of the vl and vtype Note vl or vtype
          - 'vmv&lt;nf&gt;r.v vd, vs2  # General form'
        "#_vector_instruction_listing":
          text:
          - vmv<nf>r
          - vmv.s.x
          - vmv.x.s
        "#_example_with_mixed_width_mask_and_compute":
          text:
          - 'vmv.v.i v4, 1                 # Splat immediate to destination'
  vslide1up.vx:
    opcode:
    - vslide1up.vx
    - 31..26=0x0e
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_slide1up"
    desc:
      v:
        "#_vector_slide1up":
          text:
          - The vslide1up instruction places the x register argument at location 0
            of the destination vector register group, provided that element 0 is active,
            otherwise the destination element is unchanged
          - The vslide1up instruction requires that the destination vector register
            group does not overlap the source vector register group or the mask register
          - 'vslide1up.vx vd, vs2, rs1, vm        # vd[0]=x[rs1], vd[i+1] = vs2[i]'
          - vslide1up behavior
        "#_vector_instruction_listing":
          text:
          - vslide1up
  vslide1down.vx:
    opcode:
    - vslide1down.vx
    - 31..26=0x0f
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_slide1down_instruction"
    desc:
      v:
        "#_vector_slide1down_instruction":
          text:
          - The vslide1down instruction copies the first vl -1 active elements values
            from index i +1 in the source vector register group to index i in the
            destination vector register group.
          - The vslide1down instruction places the x register argument at location
            vl -1 in the destination vector register, provided that element vl-1 is
            active, otherwise the destination element is unchanged
          - Note vslide1down instruction can be used to load values into a vector
            register without using memory and without disturbing other vector registers
          - This provides a path for debuggers to modify the contents of a vector
            register, albeit slowly, with multiple repeated vslide1down invocations
          - 'vslide1down.vx vd, vs2, rs1, vm      # vd[i] = vs2[i+1], vd[vl-1]=x[rs1]'
          - vslide1down behavior
        "#_vector_instruction_listing":
          text:
          - vslide1down
  vdivu.vx:
    opcode:
    - vdivu.vx
    - 31..26=0x20
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_divide_instructions"
    desc:
      v:
        "#_vector_integer_divide_instructions":
          text:
          - 'vdivu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vdivu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vdivu
  vdiv.vx:
    opcode:
    - vdiv.vx
    - 31..26=0x21
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_divide_instructions"
    desc:
      v:
        "#_vector_integer_divide_instructions":
          text:
          - 'vdiv.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vdiv.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vdiv
  vremu.vx:
    opcode:
    - vremu.vx
    - 31..26=0x22
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_divide_instructions"
    desc:
      v:
        "#_vector_integer_divide_instructions":
          text:
          - 'vremu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vremu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vremu
  vrem.vx:
    opcode:
    - vrem.vx
    - 31..26=0x23
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_integer_divide_instructions"
    desc:
      v:
        "#_vector_integer_divide_instructions":
          text:
          - 'vrem.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vrem.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vrem
  vmulhu.vx:
    opcode:
    - vmulhu.vx
    - 31..26=0x24
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_instructions":
          text:
          - 'vmulhu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmulhu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmulhu
  vmul.vx:
    opcode:
    - vmul.vx
    - 31..26=0x25
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_examples"
    desc:
      v:
        "#_examples":
          text:
          - 'vmul.vx  v8, v8, x10    # 32b multiply result'
        "#_vector_single_width_integer_multiply_instructions":
          text:
          - 'vmul.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmul.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmul
  vmulhsu.vx:
    opcode:
    - vmulhsu.vx
    - 31..26=0x26
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_instructions":
          text:
          - 'vmulhsu.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmulhsu.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmulhsu
  vmulh.vx:
    opcode:
    - vmulh.vx
    - 31..26=0x27
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_instructions":
          text:
          - Note vmulh* opcodes perform simple fractional multiplies, but with no
            option to scale, round, and/or saturate the result
          - Can consider changing definition of vmulh , vmulhu , vmulhsu to use vxrm
            rounding mode when discarding low half of product
          - 'vmulh.vv vd, vs2, vs1, vm   # Vector-vector'
          - 'vmulh.vx vd, vs2, rs1, vm   # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vmulh
  vmadd.vx:
    opcode:
    - vmadd.vx
    - 31..26=0x29
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_add_instructions":
          text:
          - 'vmadd.vv vd, vs1, vs2, vm    # vd[i] = (vs1[i] * vd[i]) + vs2[i]'
          - 'vmadd.vx vd, rs1, vs2, vm    # vd[i] = (x[rs1] * vd[i]) + vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vmadd
  vnmsub.vx:
    opcode:
    - vnmsub.vx
    - 31..26=0x2b
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_add_instructions":
          text:
          - Similarly for the "vnmsub" opcode
          - 'vnmsub.vv vd, vs1, vs2, vm    # vd[i] = -(vs1[i] * vd[i]) + vs2[i]'
          - 'vnmsub.vx vd, rs1, vs2, vm    # vd[i] = -(x[rs1] * vd[i]) + vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vnmsub
  vmacc.vx:
    opcode:
    - vmacc.vx
    - 31..26=0x2d
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_add_instructions":
          text:
          - The integer multiply-add instructions are destructive and are provided
            in two forms, one that overwrites the addend or minuend ( vmacc , vnmsac
            ) and one that overwrites the first multiplicand ( vmadd , vnmsub ).
          - 'vmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]'
          - 'vmacc.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vmacc
  vnmsac.vx:
    opcode:
    - vnmsac.vx
    - 31..26=0x2f
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_add_instructions":
          text:
          - 'vnmsac.vv vd, vs1, vs2, vm    # vd[i] = -(vs1[i] * vs2[i]) + vd[i]'
          - 'vnmsac.vx vd, rs1, vs2, vm    # vd[i] = -(x[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vnmsac
  vwaddu.vx:
    opcode:
    - vwaddu.vx
    - 31..26=0x30
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwaddu.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwaddu.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwaddu.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwaddu.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwaddu
          - vwaddu.w
  vwadd.vx:
    opcode:
    - vwadd.vx
    - 31..26=0x31
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - Can define assembly pseudoinstructions vwcvt.x.x.v vd,vs,vm = vwadd.vx
            vd,vs,x0,vm and vwcvtu.x.x.v vd,vs,vm = vwaddu.vx vd,vs,x0,vm
          - 'vwadd.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwadd.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwadd.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwadd.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwadd
          - vwadd.w
  vwsubu.vx:
    opcode:
    - vwsubu.vx
    - 31..26=0x32
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwsubu.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsubu.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwsubu.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsubu.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwsubu
          - vwsubu.w
  vwsub.vx:
    opcode:
    - vwsub.vx
    - 31..26=0x33
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwsub.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsub.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwsub.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsub.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwsub
          - vwsub.w
  vwaddu.wx:
    opcode:
    - vwaddu.wx
    - 31..26=0x34
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwaddu.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwaddu.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwaddu.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwaddu.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwaddu
          - vwaddu.w
  vwadd.wx:
    opcode:
    - vwadd.wx
    - 31..26=0x35
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - Can define assembly pseudoinstructions vwcvt.x.x.v vd,vs,vm = vwadd.vx
            vd,vs,x0,vm and vwcvtu.x.x.v vd,vs,vm = vwaddu.vx vd,vs,x0,vm
          - 'vwadd.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwadd.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwadd.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwadd.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwadd
          - vwadd.w
  vwsubu.wx:
    opcode:
    - vwsubu.wx
    - 31..26=0x36
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwsubu.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsubu.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwsubu.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsubu.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwsubu
          - vwsubu.w
  vwsub.wx:
    opcode:
    - vwsub.wx
    - 31..26=0x37
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_add_subtract"
    desc:
      v:
        "#_vector_widening_integer_add_subtract":
          text:
          - 'vwsub.vv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsub.vx  vd, vs2, rs1, vm  # vector-scalar'
          - 'vwsub.wv  vd, vs2, vs1, vm  # vector-vector'
          - 'vwsub.wx  vd, vs2, rs1, vm  # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwsub
          - vwsub.w
  vwmulu.vx:
    opcode:
    - vwmulu.vx
    - 31..26=0x38
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_instructions":
          text:
          - 'vwmulu.vv vd, vs2, vs1, vm # vector-vector'
          - 'vwmulu.vx vd, vs2, rs1, vm # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwmulu
  vwmulsu.vx:
    opcode:
    - vwmulsu.vx
    - 31..26=0x3a
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_instructions":
          text:
          - 'vwmulsu.vv vd, vs2, vs1, vm # vector-vector'
          - 'vwmulsu.vx vd, vs2, rs1, vm # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwmulsu
  vwmul.vx:
    opcode:
    - vwmul.vx
    - 31..26=0x3b
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_examples"
    desc:
      v:
        "#_examples":
          text:
          - 'vwmul.vx v8, v4, x10    # 32b in &lt;v8--v15&gt;'
        "#_vector_widening_integer_multiply_instructions":
          text:
          - vwmul.vv  vd, vs2, vs1, vm# vector-vector
          - 'vwmul.vx  vd, vs2, rs1, vm # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vwmul
  vwmaccu.vx:
    opcode:
    - vwmaccu.vx
    - 31..26=0x3c
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_add_instructions":
          text:
          - 'vwmaccu.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]'
          - 'vwmaccu.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vwmaccu
  vwmacc.vx:
    opcode:
    - vwmacc.vx
    - 31..26=0x3d
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_add_instructions":
          text:
          - 'vwmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]'
          - 'vwmacc.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vwmacc
  vwmaccsu.vx:
    opcode:
    - vwmaccsu.vx
    - 31..26=0x3e
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_add_instructions":
          text:
          - 'vwmaccsu.vv vd, vs1, vs2, vm    # vd[i] = +(signed(vs1[i]) * unsigned(vs2[i]))
            + vd[i]'
          - 'vwmaccsu.vx vd, rs1, vs2, vm    # vd[i] = +(signed(x[rs1]) * unsigned(vs2[i]))
            + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vwmaccsu
  vwmaccus.vx:
    opcode:
    - vwmaccus.vx
    - 31..26=0x3f
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: opcodes-rvv
    opcode_args: *16
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_add_instructions":
          text:
          - 'vwmaccus.vx vd, rs1, vs2, vm    # vd[i] = +(unsigned(x[rs1]) * signed(vs2[i]))
            + vd[i]'
        "#_vector_instruction_listing":
          text:
          - vwmaccus
groups:
  opcodes:
  - beq
  - bne
  - blt
  - bge
  - bltu
  - bgeu
  - jalr
  - jal
  - lui
  - auipc
  - addi
  - slli
  - slti
  - sltiu
  - xori
  - srli
  - srai
  - ori
  - andi
  - add
  - sub
  - sll
  - slt
  - sltu
  - xor
  - srl
  - sra
  - or
  - and
  - addiw
  - slliw
  - srliw
  - sraiw
  - addw
  - subw
  - sllw
  - srlw
  - sraw
  - lb
  - lh
  - lw
  - ld
  - lbu
  - lhu
  - lwu
  - sb
  - sh
  - sw
  - sd
  - fence
  - fence.i
  - mul
  - mulh
  - mulhsu
  - mulhu
  - div
  - divu
  - rem
  - remu
  - mulw
  - divw
  - divuw
  - remw
  - remuw
  - amoadd.w
  - amoxor.w
  - amoor.w
  - amoand.w
  - amomin.w
  - amomax.w
  - amominu.w
  - amomaxu.w
  - amoswap.w
  - lr.w
  - sc.w
  - amoadd.d
  - amoxor.d
  - amoor.d
  - amoand.d
  - amomin.d
  - amomax.d
  - amominu.d
  - amomaxu.d
  - amoswap.d
  - lr.d
  - sc.d
  - ecall
  - ebreak
  - uret
  - sret
  - mret
  - dret
  - sfence.vma
  - wfi
  - csrrw
  - csrrs
  - csrrc
  - csrrwi
  - csrrsi
  - csrrci
  - hfence.bvma
  - hfence.gvma
  - fadd.s
  - fsub.s
  - fmul.s
  - fdiv.s
  - fsgnj.s
  - fsgnjn.s
  - fsgnjx.s
  - fmin.s
  - fmax.s
  - fsqrt.s
  - fadd.d
  - fsub.d
  - fmul.d
  - fdiv.d
  - fsgnj.d
  - fsgnjn.d
  - fsgnjx.d
  - fmin.d
  - fmax.d
  - fcvt.s.d
  - fcvt.d.s
  - fsqrt.d
  - fadd.q
  - fsub.q
  - fmul.q
  - fdiv.q
  - fsgnj.q
  - fsgnjn.q
  - fsgnjx.q
  - fmin.q
  - fmax.q
  - fcvt.s.q
  - fcvt.q.s
  - fcvt.d.q
  - fcvt.q.d
  - fsqrt.q
  - fle.s
  - flt.s
  - feq.s
  - fle.d
  - flt.d
  - feq.d
  - fle.q
  - flt.q
  - feq.q
  - fcvt.w.s
  - fcvt.wu.s
  - fcvt.l.s
  - fcvt.lu.s
  - fmv.x.w
  - fclass.s
  - fcvt.w.d
  - fcvt.wu.d
  - fcvt.l.d
  - fcvt.lu.d
  - fmv.x.d
  - fclass.d
  - fcvt.w.q
  - fcvt.wu.q
  - fcvt.l.q
  - fcvt.lu.q
  - fmv.x.q
  - fclass.q
  - fcvt.s.w
  - fcvt.s.wu
  - fcvt.s.l
  - fcvt.s.lu
  - fmv.w.x
  - fcvt.d.w
  - fcvt.d.wu
  - fcvt.d.l
  - fcvt.d.lu
  - fmv.d.x
  - fcvt.q.w
  - fcvt.q.wu
  - fcvt.q.l
  - fcvt.q.lu
  - fmv.q.x
  - flw
  - fld
  - flq
  - fsw
  - fsd
  - fsq
  - fmadd.s
  - fmsub.s
  - fnmsub.s
  - fnmadd.s
  - fmadd.d
  - fmsub.d
  - fnmsub.d
  - fnmadd.d
  - fmadd.q
  - fmsub.q
  - fnmsub.q
  - fnmadd.q
  opcodes-custom:
  - "@custom0"
  - "@custom0.rs1"
  - "@custom0.rs1.rs2"
  - "@custom0.rd"
  - "@custom0.rd.rs1"
  - "@custom0.rd.rs1.rs2"
  - "@custom1"
  - "@custom1.rs1"
  - "@custom1.rs1.rs2"
  - "@custom1.rd"
  - "@custom1.rd.rs1"
  - "@custom1.rd.rs1.rs2"
  - "@custom2"
  - "@custom2.rs1"
  - "@custom2.rs1.rs2"
  - "@custom2.rd"
  - "@custom2.rd.rs1"
  - "@custom2.rd.rs1.rs2"
  - "@custom3"
  - "@custom3.rs1"
  - "@custom3.rs1.rs2"
  - "@custom3.rd"
  - "@custom3.rd.rs1"
  - "@custom3.rd.rs1.rs2"
  opcodes-pseudo:
  - "@slli.rv32"
  - "@srli.rv32"
  - "@srai.rv32"
  - "@frflags"
  - "@fsflags"
  - "@fsflagsi"
  - "@frrm"
  - "@fsrm"
  - "@fsrmi"
  - "@fscsr"
  - "@frcsr"
  - "@rdcycle"
  - "@rdtime"
  - "@rdinstret"
  - "@rdcycleh"
  - "@rdtimeh"
  - "@rdinstreth"
  - "@scall"
  - "@sbreak"
  - "@fmv.x.s"
  - "@fmv.s.x"
  - "@fence.tso"
  opcodes-rvc:
  - c.addi4spn
  - c.fld
  - c.lw
  - c.flw
  - c.fsd
  - c.sw
  - c.fsw
  - c.addi
  - c.jal
  - c.li
  - c.lui
  - c.srli
  - c.srai
  - c.andi
  - c.sub
  - c.xor
  - c.or
  - c.and
  - c.subw
  - c.addw
  - c.j
  - c.beqz
  - c.bnez
  - c.slli
  - c.fldsp
  - c.lwsp
  - c.flwsp
  - c.mv
  - c.add
  - c.fsdsp
  - c.swsp
  - c.fswsp
  opcodes-rvc-pseudo:
  - "@c.nop"
  - "@c.addi16sp"
  - "@c.jr"
  - "@c.jalr"
  - "@c.ebreak"
  - "@c.ld"
  - "@c.sd"
  - "@c.addiw"
  - "@c.ldsp"
  - "@c.sdsp"
  - "@c.lq"
  - "@c.sq"
  - "@c.lqsp"
  - "@c.sqsp"
  opcodes-rvv:
  - vsetvli
  - vsetvl
  - vlb.v
  - vlh.v
  - vlw.v
  - vle.v
  - vlbu.v
  - vlhu.v
  - vlwu.v
  - vsb.v
  - vsh.v
  - vsw.v
  - vse.v
  - vlsb.v
  - vlsh.v
  - vlsw.v
  - vlse.v
  - vlsbu.v
  - vlshu.v
  - vlswu.v
  - vssb.v
  - vssh.v
  - vssw.v
  - vsse.v
  - vlxb.v
  - vlxh.v
  - vlxw.v
  - vlxe.v
  - vlxbu.v
  - vlxhu.v
  - vlxwu.v
  - vsxb.v
  - vsxh.v
  - vsxw.v
  - vsxe.v
  - vsuxb.v
  - vsuxh.v
  - vsuxw.v
  - vsuxe.v
  - vlbff.v
  - vlhff.v
  - vlwff.v
  - vleff.v
  - vlbuff.v
  - vlhuff.v
  - vlwuff.v
  - vfadd.vf
  - vfsub.vf
  - vfmin.vf
  - vfmax.vf
  - vfsgnj.vf
  - vfsgnjn.vf
  - vfsgnjx.vf
  - vfmv.s.f
  - vfmerge.vfm
  - vfmv.v.f
  - vfeq.vf
  - vfle.vf
  - vford.vf
  - vflt.vf
  - vfne.vf
  - vfgt.vf
  - vfge.vf
  - vfdiv.vf
  - vfrdiv.vf
  - vfmul.vf
  - vfmadd.vf
  - vfnmadd.vf
  - vfmsub.vf
  - vfnmsub.vf
  - vfmacc.vf
  - vfnmacc.vf
  - vfmsac.vf
  - vfnmsac.vf
  - vfwadd.vf
  - vfwsub.vf
  - vfwadd.wf
  - vfwsub.wf
  - vfwmul.vf
  - vfwmacc.vf
  - vfwnmacc.vf
  - vfwmsac.vf
  - vfwnmsac.vf
  - vfadd.vv
  - vfredsum.vs
  - vfsub.vv
  - vfredosum.vs
  - vfmin.vv
  - vfredmin.vs
  - vfmax.vv
  - vfredmax.vs
  - vfsgnj.vv
  - vfsgnjn.vv
  - vfsgnjx.vv
  - vfmv.f.s
  - vfeq.vv
  - vfle.vv
  - vford.vv
  - vflt.vv
  - vfne.vv
  - vfdiv.vv
  - vfunary0.vv
  - vfunary1.vv
  - vfmul.vv
  - vfmadd.vv
  - vfnmadd.vv
  - vfmsub.vv
  - vfnmsub.vv
  - vfmacc.vv
  - vfnmacc.vv
  - vfmsac.vv
  - vfnmsac.vv
  - vfwadd.vv
  - vfwredsum.vs
  - vfwsub.vv
  - vfwredosum.vs
  - vfwadd.wv
  - vfwsub.wv
  - vfwmul.vv
  - vfdot.vv
  - vfwmacc.vv
  - vfwnmacc.vv
  - vfwmsac.vv
  - vfwnmsac.vv
  - vadd.vx
  - vsub.vx
  - vrsub.vx
  - vminu.vx
  - vmin.vx
  - vmaxu.vx
  - vmax.vx
  - vand.vx
  - vor.vx
  - vxor.vx
  - vrgather.vx
  - vslideup.vx
  - vslidedown.vx
  - vadc.vxm
  - vmadc.vxm
  - vsbc.vxm
  - vmsbc.vxm
  - vmerge.vxm
  - vmv.v.x
  - vseq.vx
  - vsne.vx
  - vsltu.vx
  - vslt.vx
  - vsleu.vx
  - vsle.vx
  - vsgtu.vx
  - vsgt.vx
  - vsaddu.vx
  - vsadd.vx
  - vssubu.vx
  - vssub.vx
  - vaadd.vx
  - vsll.vx
  - vasub.vx
  - vsmul.vx
  - vsrl.vx
  - vsra.vx
  - vssrl.vx
  - vssra.vx
  - vnsrl.vx
  - vnsra.vx
  - vnclipu.vx
  - vnclip.vx
  - vwsmaccu.vx
  - vwsmacc.vx
  - vwsmaccsu.vx
  - vwsmaccus.vx
  - vadd.vv
  - vsub.vv
  - vminu.vv
  - vmin.vv
  - vmaxu.vv
  - vmax.vv
  - vand.vv
  - vor.vv
  - vxor.vv
  - vrgather.vv
  - vadc.vvm
  - vmadc.vvm
  - vsbc.vvm
  - vmsbc.vvm
  - vmerge.vvm
  - vmv.v.v
  - vseq.vv
  - vsne.vv
  - vsltu.vv
  - vslt.vv
  - vsleu.vv
  - vsle.vv
  - vsaddu.vv
  - vsadd.vv
  - vssubu.vv
  - vssub.vv
  - vaadd.vv
  - vsll.vv
  - vasub.vv
  - vsmul.vv
  - vsrl.vv
  - vsra.vv
  - vssrl.vv
  - vssra.vv
  - vnsrl.vv
  - vnsra.vv
  - vnclipu.vv
  - vnclip.vv
  - vwredsumu.vs
  - vwredsum.vs
  - vdotu.vv
  - vdot.vv
  - vwsmaccu.vv
  - vwsmacc.vv
  - vwsmaccsu.vv
  - vadd.vi
  - vrsub.vi
  - vand.vi
  - vor.vi
  - vxor.vi
  - vrgather.vi
  - vslideup.vi
  - vslidedown.vi
  - vadc.vim
  - vmadc.vim
  - vmerge.vim
  - vmv.v.i
  - vseq.vi
  - vsne.vi
  - vsleu.vi
  - vsle.vi
  - vsgtu.vi
  - vsgt.vi
  - vsaddu.vi
  - vsadd.vi
  - vaadd.vi
  - vsll.vi
  - vsrl.vi
  - vsra.vi
  - vssrl.vi
  - vssra.vi
  - vnsrl.vi
  - vnsra.vi
  - vnclipu.vi
  - vnclip.vi
  - vredsum.vs
  - vredand.vs
  - vredor.vs
  - vredxor.vs
  - vredminu.vs
  - vredmin.vs
  - vredmaxu.vs
  - vredmax.vs
  - vext.x.v
  - vmpopc.m
  - vmfirst.m
  - vcompress.vm
  - vmandnot.mm
  - vmand.mm
  - vmor.mm
  - vmxor.mm
  - vmornot.mm
  - vmnand.mm
  - vmnor.mm
  - vmxnor.mm
  - vmsbf.m
  - vmsof.m
  - vmsif.m
  - viota.m
  - vid.v
  - vdivu.vv
  - vdiv.vv
  - vremu.vv
  - vrem.vv
  - vmulhu.vv
  - vmul.vv
  - vmulhsu.vv
  - vmulh.vv
  - vmadd.vv
  - vnmsub.vv
  - vmacc.vv
  - vnmsac.vv
  - vwaddu.vv
  - vwadd.vv
  - vwsubu.vv
  - vwsub.vv
  - vwaddu.wv
  - vwadd.wv
  - vwsubu.wv
  - vwsub.wv
  - vwmulu.vv
  - vwmulsu.vv
  - vwmul.vv
  - vwmaccu.vv
  - vwmacc.vv
  - vwmaccsu.vv
  - vmv.s.x
  - vslide1up.vx
  - vslide1down.vx
  - vdivu.vx
  - vdiv.vx
  - vremu.vx
  - vrem.vx
  - vmulhu.vx
  - vmul.vx
  - vmulhsu.vx
  - vmulh.vx
  - vmadd.vx
  - vnmsub.vx
  - vmacc.vx
  - vnmsac.vx
  - vwaddu.vx
  - vwadd.vx
  - vwsubu.vx
  - vwsub.vx
  - vwaddu.wx
  - vwadd.wx
  - vwsubu.wx
  - vwsub.wx
  - vwmulu.vx
  - vwmulsu.vx
  - vwmul.vx
  - vwmaccu.vx
  - vwmacc.vx
  - vwmaccsu.vx
  - vwmaccus.vx
sections:
  rv32:
    "#conditional-branches":
    - beq
    - blt
    - bge
    - bltu
    "#unconditional-jumps":
    - jalr
    "#programmers-model-for-base-integer-isa":
    - jal
    "#integer-register-immediate-instructions":
    - lui
    - auipc
    - addi
    - slli
    - slti
    - sltiu
    - xori
    - andi
    "#integer-computational-instructions":
    - add
    "#integer-register-register-operations":
    - sub
    - sll
    - slt
    - sltu
    - and
    "#load-and-store-instructions":
    - lb
    - lh
    - lw
    - lhu
    - sw
    "#sec:fence":
    - fence
    "#rv32":
    - ecall
    "#environment-call-and-breakpoints":
    - ebreak
  rv32e: {}
  rv64:
    "#integer-register-immediate-instructions":
    - addiw
    - slliw
    "#integer-register-register-operations":
    - addw
    - sllw
    "#load-and-store-instructions":
    - ld
    - lwu
    - sd
  rv128:
    "#rv128":
    - fmv.x.q
  a:
    "#sec:amo":
    - amoadd.w
    - amoxor.w
    - amoor.w
    - amoand.w
    - amomin.w
    - amomax.w
    - amominu.w
    - amomaxu.w
    - amoswap.w
    - amoadd.d
    - amoxor.d
    - amoor.d
    - amoand.d
    - amomin.d
    - amomax.d
    - amominu.d
    - amomaxu.d
    - amoswap.d
    "#sec:lrsc":
    - lr.w
    - sc.w
    - lr.d
  b: {}
  c:
    "#integer-register-immediate-operations":
    - c.addi4spn
    - c.addi
    - c.srli
    - c.srai
    - c.andi
    - c.slli
    "#register-based-loads-and-stores":
    - c.fld
    - c.lw
    - c.flw
    - c.fsd
    - c.sw
    - c.fsw
    "#control-transfer-instructions":
    - c.jal
    - c.j
    - c.beqz
    - c.bnez
    "#integer-constant-generation-instructions":
    - c.li
    - c.lui
    "#integer-register-register-operations":
    - c.sub
    - c.xor
    - c.or
    - c.and
    - c.subw
    - c.addw
    - c.mv
    - c.add
    "#stack-pointer-based-loads-and-stores":
    - c.fldsp
    - c.lwsp
    - c.flwsp
    - c.fsdsp
    - c.swsp
    - c.fswsp
    "#compressed":
    - "@c.nop"
    - "@c.addi16sp"
    - "@c.jr"
    - "@c.jalr"
    - "@c.ebreak"
    - "@c.ld"
    - "@c.sd"
    - "@c.addiw"
    - "@c.ldsp"
    - "@c.sdsp"
    - "@c.lq"
    - "@c.sq"
    - "@c.lqsp"
    - "@c.sqsp"
  m:
    "#multiplication-operations":
    - mul
    - mulh
    - mulhsu
    - mulw
    "#division-operations":
    - div
    - divu
    - rem
    - remu
    - divw
    - remw
  n:
    "#user-status-register-ustatus":
    - uret
  f:
    "#single-precision-floating-point-conversion-and-move-instructions":
    - xor
    - fsgnj.s
    - fcvt.w.s
    - fcvt.wu.s
    - fcvt.l.s
    - fcvt.lu.s
    - fmv.x.w
    - fcvt.s.w
    - fcvt.s.l
    - fmv.w.x
    "#sec:single-float-compute":
    - fadd.s
    - fsub.s
    - fdiv.s
    - fmin.s
    - fsqrt.s
    - fmadd.s
    - fmsub.s
    - fnmsub.s
    - fnmadd.s
    "#single-precision-floating-point-compare-instructions":
    - flt.s
    - feq.s
    "#single-precision-floating-point-classify-instruction":
    - fclass.s
    "#single-precision-load-and-store-instructions":
    - flw
    - fsw
  d:
    "#sec:single-float-compute":
    - fadd.d
    - fsub.d
    - fdiv.d
    - fmin.d
    - fsqrt.d
    - fmadd.d
    - fmsub.d
    - fnmsub.d
    - fnmadd.d
    "#double-precision-floating-point-conversion-and-move-instructions":
    - fsgnj.d
    - fcvt.s.d
    - fcvt.w.d
    - fcvt.wu.d
    - fmv.x.d
    - fcvt.d.w
    - fcvt.d.l
    - fmv.d.x
    "#single-precision-floating-point-compare-instructions":
    - flt.d
    - feq.d
    "#double-precision-floating-point-classify-instruction":
    - fclass.d
    "#fld_fsd":
    - fld
    - fsd
  q:
    "#sec:single-float-compute":
    - fadd.q
    - fsub.q
    - fdiv.q
    - fmin.q
    - fsqrt.q
    - fmadd.q
    - fmsub.q
    - fnmsub.q
    - fnmadd.q
    "#quad-precision-convert-and-move-instructions":
    - fsgnj.q
    - fcvt.s.q
    - fcvt.d.q
    - fcvt.w.q
    - fcvt.wu.q
    - fcvt.q.w
    - fcvt.q.l
    "#single-precision-floating-point-compare-instructions":
    - flt.q
    - feq.q
    "#quad-precision-floating-point-classify-instruction":
    - fclass.q
    "#quad-precision-load-and-store-instructions":
    - flq
  v:
    "#_vector_length_register_code_vl_code":
    - vsetvli
    "#_vector_type_register_code_vtype_code":
    - vsetvl
    "#_vector_unit_stride_instructions":
    - vlb.v
    - vlw.v
    - vle.v
    - vlbu.v
    - vlhu.v
    - vlwu.v
    - vsb.v
    - vsh.v
    - vse.v
    "#_examples":
    - vlh.v
    - vsw.v
    - vsrl.vx
    - vsrl.vv
    - vsrl.vi
    - vmul.vv
    - vwmul.vv
    - vmul.vx
    - vwmul.vx
    "#_vector_strided_instructions":
    - vlsb.v
    - vlsh.v
    - vlsw.v
    - vlse.v
    - vlsbu.v
    - vlshu.v
    - vlswu.v
    - vssb.v
    - vssh.v
    - vssw.v
    - vsse.v
    "#_vector_indexed_instructions":
    - vlxb.v
    - vlxh.v
    - vlxw.v
    - vlxe.v
    - vlxbu.v
    - vlxhu.v
    - vlxwu.v
    - vsxb.v
    - vsxh.v
    - vsxw.v
    - vsxe.v
    - vsuxb.v
    - vsuxh.v
    - vsuxw.v
    - vsuxe.v
    "#_unit_stride_fault_only_first_loads":
    - vlbff.v
    - vlhff.v
    - vlwff.v
    - vleff.v
    - vlbuff.v
    - vlhuff.v
    - vlwuff.v
    "#_vector_single_width_floating_point_add_subtract_instructions":
    - vfadd.vf
    - vfsub.vf
    - vfadd.vv
    - vfsub.vv
    "#_vector_floating_point_min_max_instructions":
    - vfmin.vf
    - vfmax.vf
    - vfmin.vv
    - vfmax.vv
    "#_vector_floating_point_sign_injection_instructions":
    - vfsgnj.vf
    - vfsgnjn.vf
    - vfsgnjx.vf
    - vfsgnj.vv
    - vfsgnjn.vv
    - vfsgnjx.vv
    "#_vector_floating_point_move_instruction":
    - vfmv.s.f
    - vfmv.v.f
    - vfmv.f.s
    "#_vector_floating_point_merge_instruction":
    - vfmerge.vfm
    "#_introduction":
    - vfeq.vf
    - vfle.vf
    - vford.vf
    - vflt.vf
    - vfne.vf
    - vfgt.vf
    - vfge.vf
    - vfeq.vv
    - vfle.vv
    - vford.vv
    - vflt.vv
    - vfne.vv
    - vfunary0.vv
    - vfunary1.vv
    - vseq.vx
    - vsne.vx
    - vsltu.vx
    - vslt.vx
    - vsleu.vx
    - vsle.vx
    - vsgtu.vx
    - vsgt.vx
    - vwsmaccu.vx
    - vwsmacc.vx
    - vwsmaccsu.vx
    - vwsmaccus.vx
    - vseq.vv
    - vsne.vv
    - vsltu.vv
    - vslt.vv
    - vsleu.vv
    - vsle.vv
    - vwsmaccu.vv
    - vwsmacc.vv
    - vwsmaccsu.vv
    - vseq.vi
    - vsne.vi
    - vsleu.vi
    - vsle.vi
    - vsgtu.vi
    - vsgt.vi
    - vext.x.v
    - vmpopc.m
    - vmfirst.m
    "#_vector_single_width_floating_point_multiply_divide_instructions":
    - vfdiv.vf
    - vfrdiv.vf
    - vfmul.vf
    - vfdiv.vv
    - vfmul.vv
    "#_vector_single_width_floating_point_fused_multiply_add_instructions":
    - vfmadd.vf
    - vfnmadd.vf
    - vfmsub.vf
    - vfnmsub.vf
    - vfmacc.vf
    - vfnmacc.vf
    - vfmsac.vf
    - vfnmsac.vf
    - vfmadd.vv
    - vfnmadd.vv
    - vfmsub.vv
    - vfnmsub.vv
    - vfmacc.vv
    - vfnmacc.vv
    - vfmsac.vv
    - vfnmsac.vv
    "#_vector_widening_floating_point_add_subtract_instructions":
    - vfwadd.vf
    - vfwsub.vf
    - vfwadd.wf
    - vfwsub.wf
    - vfwadd.vv
    - vfwsub.vv
    - vfwadd.wv
    - vfwsub.wv
    "#_vector_widening_floating_point_multiply":
    - vfwmul.vf
    - vfwmul.vv
    "#_vector_widening_floating_point_fused_multiply_add_instructions":
    - vfwmacc.vf
    - vfwnmacc.vf
    - vfwmsac.vf
    - vfwnmsac.vf
    - vfwmacc.vv
    - vfwnmacc.vv
    - vfwmsac.vv
    - vfwnmsac.vv
    "#_vector_single_width_floating_point_reduction_instructions":
    - vfredsum.vs
    - vfredosum.vs
    - vfredmin.vs
    - vfredmax.vs
    "#_vector_widening_floating_point_reduction_instructions":
    - vfwredsum.vs
    - vfwredosum.vs
    "#_vector_floating_point_dot_product_instruction":
    - vfdot.vv
    "#_vector_single_width_integer_add_and_subtract":
    - vadd.vx
    - vsub.vx
    - vrsub.vx
    - vadd.vv
    - vsub.vv
    - vadd.vi
    - vrsub.vi
    "#_vector_integer_min_max_instructions":
    - vminu.vx
    - vmin.vx
    - vmaxu.vx
    - vmax.vx
    - vminu.vv
    - vmin.vv
    - vmaxu.vv
    - vmax.vv
    "#_vector_bitwise_logical_instructions":
    - vand.vx
    - vor.vx
    - vxor.vx
    - vand.vv
    - vor.vv
    - vxor.vv
    - vand.vi
    - vor.vi
    - vxor.vi
    "#_vector_register_gather_instruction":
    - vrgather.vx
    - vrgather.vv
    - vrgather.vi
    "#_vector_slide_instructions":
    - vslideup.vx
    - vslideup.vi
    "#_vector_slidedown_instructions":
    - vslidedown.vx
    - vslidedown.vi
    "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
    - vadc.vxm
    - vmadc.vxm
    - vsbc.vxm
    - vmsbc.vxm
    - vadc.vvm
    - vmadc.vvm
    - vsbc.vvm
    - vmsbc.vvm
    - vadc.vim
    - vmadc.vim
    "#_vector_integer_merge_instructions":
    - vmerge.vxm
    - vmerge.vvm
    - vmerge.vim
    "#_vector_integer_move_instructions":
    - vmv.v.x
    - vmv.v.v
    - vmv.v.i
    - vmv.s.x
    "#_vector_single_width_saturating_add_and_subtract":
    - vsaddu.vx
    - vsadd.vx
    - vssubu.vx
    - vssub.vx
    - vsaddu.vv
    - vsadd.vv
    - vssubu.vv
    - vssub.vv
    - vsaddu.vi
    - vsadd.vi
    "#_vector_single_width_averaging_add_and_subtract":
    - vaadd.vx
    - vasub.vx
    - vaadd.vv
    - vasub.vv
    - vaadd.vi
    "#_vector_single_width_bit_shift_instructions":
    - vsll.vx
    - vsra.vx
    - vsll.vv
    - vsra.vv
    - vsll.vi
    - vsra.vi
    "#_vector_single_width_fractional_multiply_with_rounding_and_saturation":
    - vsmul.vx
    - vsmul.vv
    "#_vector_single_width_scaling_shift_instructions":
    - vssrl.vx
    - vssra.vx
    - vssrl.vv
    - vssra.vv
    - vssrl.vi
    - vssra.vi
    "#_vector_narrowing_integer_right_shift_instructions":
    - vnsrl.vx
    - vnsrl.vv
    - vnsrl.vi
    "#sec-narrowing":
    - vnsra.vx
    - vnsra.vv
    - vnsra.vi
    "#_vector_narrowing_fixed_point_clip_instructions":
    - vnclipu.vx
    - vnclip.vx
    - vnclipu.vv
    - vnclip.vv
    - vnclipu.vi
    - vnclip.vi
    "#_vector_widening_integer_reduction_instructions":
    - vwredsumu.vs
    - vwredsum.vs
    "#_vector_integer_dot_product_instruction":
    - vdotu.vv
    - vdot.vv
    "#_vector_single_width_integer_reduction_instructions":
    - vredsum.vs
    - vredand.vs
    - vredor.vs
    - vredxor.vs
    - vredminu.vs
    - vredmin.vs
    - vredmaxu.vs
    - vredmax.vs
    "#_vector_compress_instruction":
    - vcompress.vm
    "#_vector_integer_comparison_instructions":
    - vmandnot.mm
    - vmxor.mm
    - vmnand.mm
    "#_vector_floating_point_compare_instructions":
    - vmand.mm
    "#sec-mask-register-logical":
    - vmor.mm
    - vmornot.mm
    - vmnor.mm
    - vmxnor.mm
    "#__code_vfirst_code_find_first_set_mask_bit":
    - vmsbf.m
    "#__code_vmsif_m_code_set_including_first_mask_bit":
    - vmsof.m
    "#__code_vmsbf_m_code_set_before_first_mask_bit":
    - vmsif.m
    "#_vector_iota_instruction":
    - viota.m
    "#_vector_element_index_instruction":
    - vid.v
    "#_vector_integer_divide_instructions":
    - vdivu.vv
    - vdiv.vv
    - vremu.vv
    - vrem.vv
    - vdivu.vx
    - vdiv.vx
    - vremu.vx
    - vrem.vx
    "#_vector_single_width_integer_multiply_instructions":
    - vmulhu.vv
    - vmulhsu.vv
    - vmulh.vv
    - vmulhu.vx
    - vmulhsu.vx
    - vmulh.vx
    "#_vector_single_width_integer_multiply_add_instructions":
    - vmadd.vv
    - vnmsub.vv
    - vmacc.vv
    - vnmsac.vv
    - vmadd.vx
    - vnmsub.vx
    - vmacc.vx
    - vnmsac.vx
    "#_vector_widening_integer_add_subtract":
    - vwaddu.vv
    - vwadd.vv
    - vwsubu.vv
    - vwsub.vv
    - vwaddu.wv
    - vwadd.wv
    - vwsubu.wv
    - vwsub.wv
    - vwaddu.vx
    - vwadd.vx
    - vwsubu.vx
    - vwsub.vx
    - vwaddu.wx
    - vwadd.wx
    - vwsubu.wx
    - vwsub.wx
    "#_vector_widening_integer_multiply_instructions":
    - vwmulu.vv
    - vwmulsu.vv
    - vwmulu.vx
    - vwmulsu.vx
    "#_vector_widening_integer_multiply_add_instructions":
    - vwmaccu.vv
    - vwmacc.vv
    - vwmaccsu.vv
    - vwmaccu.vx
    - vwmacc.vx
    - vwmaccsu.vx
    - vwmaccus.vx
    "#_vector_slide1up":
    - vslide1up.vx
    "#_vector_slide1down_instruction":
    - vslide1down.vx
  csr:
    "#csr-instructions":
    - csrrw
    - csrrs
    - csrrc
    - csrrwi
    - csrrsi
  supervisor:
    "#sstatus":
    - sret
    "#sec:satp":
    - sfence.vma
  hypervisor:
    "#sec:hinterruptregs":
    - or
    "#sec:tinst-vals":
    - sb
    "#hypervisor-status-register-hstatus":
    - mret
    "#wfi-in-virtual-operating-modes":
    - wfi
    "#sec:hgatp":
    - hfence.gvma
  machine: {}
  custom:
    "#":
    - "@custom0"
    - "@custom0.rs1"
    - "@custom0.rs1.rs2"
    - "@custom0.rd"
    - "@custom0.rd.rs1"
    - "@custom0.rd.rs1.rs2"
    - "@custom1"
    - "@custom1.rs1"
    - "@custom1.rs1.rs2"
    - "@custom1.rd"
    - "@custom1.rd.rs1"
    - "@custom1.rd.rs1.rs2"
    - "@custom2"
    - "@custom2.rs1"
    - "@custom2.rs1.rs2"
    - "@custom2.rd"
    - "@custom2.rd.rs1"
    - "@custom2.rd.rs1.rs2"
    - "@custom3"
    - "@custom3.rs1"
    - "@custom3.rs1.rs2"
    - "@custom3.rd"
    - "@custom3.rd.rs1"
    - "@custom3.rd.rs1.rs2"
sections_labels:
  rv32:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/rv32.html"
    "#rv32":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      url: "/riscv-isa-manual/latest/rv32.html#rv32"
    "#programmers-model-for-base-integer-isa":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - "Programmers&acirc;\x80\x99 Model for Base Integer ISA"
      url: "/riscv-isa-manual/latest/rv32.html#programmers-model-for-base-integer-isa"
    "#base-instruction-formats":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Base Instruction Formats
      url: "/riscv-isa-manual/latest/rv32.html#base-instruction-formats"
    "#immediate-encoding-variants":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Immediate Encoding Variants
      url: "/riscv-isa-manual/latest/rv32.html#immediate-encoding-variants"
    "#integer-computational-instructions":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Integer Computational Instructions
      url: "/riscv-isa-manual/latest/rv32.html#integer-computational-instructions"
    "#integer-register-immediate-instructions":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Integer Computational Instructions
      - Integer Register-Immediate Instructions
      url: "/riscv-isa-manual/latest/rv32.html#integer-register-immediate-instructions"
    "#integer-register-register-operations":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Integer Computational Instructions
      - Integer Register-Register Operations
      url: "/riscv-isa-manual/latest/rv32.html#integer-register-register-operations"
    "#nop-instruction":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Integer Computational Instructions
      - NOP Instruction
      url: "/riscv-isa-manual/latest/rv32.html#nop-instruction"
    "#control-transfer-instructions":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Control Transfer Instructions
      url: "/riscv-isa-manual/latest/rv32.html#control-transfer-instructions"
    "#unconditional-jumps":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Control Transfer Instructions
      - Unconditional Jumps
      url: "/riscv-isa-manual/latest/rv32.html#unconditional-jumps"
    "#conditional-branches":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Control Transfer Instructions
      - Conditional Branches
      url: "/riscv-isa-manual/latest/rv32.html#conditional-branches"
    "#load-and-store-instructions":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Load and Store Instructions
      url: "/riscv-isa-manual/latest/rv32.html#load-and-store-instructions"
    "#sec:fence":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Memory Ordering Instructions
      url: "/riscv-isa-manual/latest/rv32.html#sec:fence"
    "#environment-call-and-breakpoints":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - Environment Call and Breakpoints
      url: "/riscv-isa-manual/latest/rv32.html#environment-call-and-breakpoints"
    "#sec:rv32i-hints":
      headers:
      - RV32I Base Integer Instruction Set, Version 2.1
      - HINT Instructions
      url: "/riscv-isa-manual/latest/rv32.html#sec:rv32i-hints"
  rv32e:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/rv32e.html"
    "#rv32e":
      headers:
      - RV32E Base Integer Instruction Set, Version 1.9
      url: "/riscv-isa-manual/latest/rv32e.html#rv32e"
    "#rv32e-programmers-model":
      headers:
      - RV32E Base Integer Instruction Set, Version 1.9
      - "RV32E Programmers&acirc;\x80\x99 Model"
      url: "/riscv-isa-manual/latest/rv32e.html#rv32e-programmers-model"
    "#rv32e-instruction-set":
      headers:
      - RV32E Base Integer Instruction Set, Version 1.9
      - RV32E Instruction Set
      url: "/riscv-isa-manual/latest/rv32e.html#rv32e-instruction-set"
  rv64:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/rv64.html"
    "#rv64":
      headers:
      - RV64I Base Integer Instruction Set, Version 2.1
      url: "/riscv-isa-manual/latest/rv64.html#rv64"
    "#register-state":
      headers:
      - RV64I Base Integer Instruction Set, Version 2.1
      - Register State
      url: "/riscv-isa-manual/latest/rv64.html#register-state"
    "#integer-computational-instructions":
      headers:
      - RV64I Base Integer Instruction Set, Version 2.1
      - Integer Computational Instructions
      url: "/riscv-isa-manual/latest/rv64.html#integer-computational-instructions"
    "#integer-register-immediate-instructions":
      headers:
      - RV64I Base Integer Instruction Set, Version 2.1
      - Integer Computational Instructions
      - Integer Register-Immediate Instructions
      url: "/riscv-isa-manual/latest/rv64.html#integer-register-immediate-instructions"
    "#integer-register-register-operations":
      headers:
      - RV64I Base Integer Instruction Set, Version 2.1
      - Integer Computational Instructions
      - Integer Register-Register Operations
      url: "/riscv-isa-manual/latest/rv64.html#integer-register-register-operations"
    "#load-and-store-instructions":
      headers:
      - RV64I Base Integer Instruction Set, Version 2.1
      - Load and Store Instructions
      url: "/riscv-isa-manual/latest/rv64.html#load-and-store-instructions"
    "#sec:rv64i-hints":
      headers:
      - RV64I Base Integer Instruction Set, Version 2.1
      - HINT Instructions
      url: "/riscv-isa-manual/latest/rv64.html#sec:rv64i-hints"
  rv128:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/rv128.html"
    "#rv128":
      headers:
      - RV128I Base Integer Instruction Set, Version 1.7
      url: "/riscv-isa-manual/latest/rv128.html#rv128"
  a:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/a.html"
    "#atomics":
      headers:
      - '"A" Standard Extension for Atomic Instructions, Version 2.1'
      url: "/riscv-isa-manual/latest/a.html#atomics"
    "#specifying-ordering-of-atomic-instructions":
      headers:
      - '"A" Standard Extension for Atomic Instructions, Version 2.1'
      - Specifying Ordering of Atomic Instructions
      url: "/riscv-isa-manual/latest/a.html#specifying-ordering-of-atomic-instructions"
    "#sec:lrsc":
      headers:
      - '"A" Standard Extension for Atomic Instructions, Version 2.1'
      - Load-Reserved/Store-Conditional Instructions
      url: "/riscv-isa-manual/latest/a.html#sec:lrsc"
    "#sec:lrscseq":
      headers:
      - '"A" Standard Extension for Atomic Instructions, Version 2.1'
      - Eventual Success of Store-Conditional Instructions
      url: "/riscv-isa-manual/latest/a.html#sec:lrscseq"
    "#sec:amo":
      headers:
      - '"A" Standard Extension for Atomic Instructions, Version 2.1'
      - Atomic Memory Operations
      url: "/riscv-isa-manual/latest/a.html#sec:amo"
  b:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/b.html"
    "#sec:bits":
      headers:
      - '"B" Standard Extension for Bit Manipulation, Version 0.0'
      url: "/riscv-isa-manual/latest/b.html#sec:bits"
  c:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/c.html"
    "#compressed":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      url: "/riscv-isa-manual/latest/c.html#compressed"
    "#overview":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Overview
      url: "/riscv-isa-manual/latest/c.html#overview"
    "#compressed-instruction-formats":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Compressed Instruction Formats
      url: "/riscv-isa-manual/latest/c.html#compressed-instruction-formats"
    "#load-and-store-instructions":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Load and Store Instructions
      url: "/riscv-isa-manual/latest/c.html#load-and-store-instructions"
    "#stack-pointer-based-loads-and-stores":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Load and Store Instructions
      - Stack-Pointer-Based Loads and Stores
      url: "/riscv-isa-manual/latest/c.html#stack-pointer-based-loads-and-stores"
    "#register-based-loads-and-stores":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Load and Store Instructions
      - Register-Based Loads and Stores
      url: "/riscv-isa-manual/latest/c.html#register-based-loads-and-stores"
    "#control-transfer-instructions":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Control Transfer Instructions
      url: "/riscv-isa-manual/latest/c.html#control-transfer-instructions"
    "#integer-computational-instructions":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Integer Computational Instructions
      url: "/riscv-isa-manual/latest/c.html#integer-computational-instructions"
    "#integer-constant-generation-instructions":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Integer Computational Instructions
      - Integer Constant-Generation Instructions
      url: "/riscv-isa-manual/latest/c.html#integer-constant-generation-instructions"
    "#integer-register-immediate-operations":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Integer Computational Instructions
      - Integer Register-Immediate Operations
      url: "/riscv-isa-manual/latest/c.html#integer-register-immediate-operations"
    "#integer-register-register-operations":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Integer Computational Instructions
      - Integer Register-Register Operations
      url: "/riscv-isa-manual/latest/c.html#integer-register-register-operations"
    "#defined-illegal-instruction":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Integer Computational Instructions
      - Defined Illegal Instruction
      url: "/riscv-isa-manual/latest/c.html#defined-illegal-instruction"
    "#nop-instruction":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Integer Computational Instructions
      - NOP Instruction
      url: "/riscv-isa-manual/latest/c.html#nop-instruction"
    "#breakpoint-instruction":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Integer Computational Instructions
      - Breakpoint Instruction
      url: "/riscv-isa-manual/latest/c.html#breakpoint-instruction"
    "#usage-of-c-instructions-in-lrsc-sequences":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - Usage of C Instructions in LR/SC Sequences
      url: "/riscv-isa-manual/latest/c.html#usage-of-c-instructions-in-lrsc-sequences"
    "#sec:rvc-hints":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - HINT Instructions
      url: "/riscv-isa-manual/latest/c.html#sec:rvc-hints"
    "#rvc-instruction-set-listings":
      headers:
      - '"C" Standard Extension for Compressed Instructions, Version 2.0'
      - RVC Instruction Set Listings
      url: "/riscv-isa-manual/latest/c.html#rvc-instruction-set-listings"
  m:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/m.html"
    "#m-standard-extension-for-integer-multiplication-and-division-version-2.0":
      headers:
      - '"M" Standard Extension for Integer Multiplication and Division, Version 2.0'
      url: "/riscv-isa-manual/latest/m.html#m-standard-extension-for-integer-multiplication-and-division-version-2.0"
    "#multiplication-operations":
      headers:
      - '"M" Standard Extension for Integer Multiplication and Division, Version 2.0'
      - Multiplication Operations
      url: "/riscv-isa-manual/latest/m.html#multiplication-operations"
    "#division-operations":
      headers:
      - '"M" Standard Extension for Integer Multiplication and Division, Version 2.0'
      - Division Operations
      url: "/riscv-isa-manual/latest/m.html#division-operations"
  n:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/n.html"
    "#chap:n":
      headers:
      - '"N" Standard Extension for User-Level Interrupts, Version 1.1'
      url: "/riscv-isa-manual/latest/n.html#chap:n"
    "#additional-csrs":
      headers:
      - '"N" Standard Extension for User-Level Interrupts, Version 1.1'
      - Additional CSRs
      url: "/riscv-isa-manual/latest/n.html#additional-csrs"
    "#user-status-register-ustatus":
      headers:
      - '"N" Standard Extension for User-Level Interrupts, Version 1.1'
      - Additional CSRs
      - ")"
      url: "/riscv-isa-manual/latest/n.html#user-status-register-ustatus"
    "#user-interrupt-registers-uip-and-uie":
      headers:
      - '"N" Standard Extension for User-Level Interrupts, Version 1.1'
      - Additional CSRs
      - ")"
      url: "/riscv-isa-manual/latest/n.html#user-interrupt-registers-uip-and-uie"
    "#machine-trap-delegation-registers-medeleg-and-mideleg":
      headers:
      - '"N" Standard Extension for User-Level Interrupts, Version 1.1'
      - Additional CSRs
      - ")"
      url: "/riscv-isa-manual/latest/n.html#machine-trap-delegation-registers-medeleg-and-mideleg"
    "#supervisor-trap-delegation-registers-sedeleg-and-sideleg":
      headers:
      - '"N" Standard Extension for User-Level Interrupts, Version 1.1'
      - Additional CSRs
      - ")"
      url: "/riscv-isa-manual/latest/n.html#supervisor-trap-delegation-registers-sedeleg-and-sideleg"
    "#other-csrs":
      headers:
      - '"N" Standard Extension for User-Level Interrupts, Version 1.1'
      - Additional CSRs
      - Other CSRs
      url: "/riscv-isa-manual/latest/n.html#other-csrs"
    "#n-extension-instructions":
      headers:
      - '"N" Standard Extension for User-Level Interrupts, Version 1.1'
      - N Extension Instructions
      url: "/riscv-isa-manual/latest/n.html#n-extension-instructions"
    "#reducing-context-swap-overhead":
      headers:
      - '"N" Standard Extension for User-Level Interrupts, Version 1.1'
      - Reducing Context-Swap Overhead
      url: "/riscv-isa-manual/latest/n.html#reducing-context-swap-overhead"
  f:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/f.html"
    "#sec:single-float":
      headers:
      - '"F" Standard Extension for Single-Precision Floating-Point, Version 2.2'
      url: "/riscv-isa-manual/latest/f.html#sec:single-float"
    "#f-register-state":
      headers:
      - '"F" Standard Extension for Single-Precision Floating-Point, Version 2.2'
      - F Register State
      url: "/riscv-isa-manual/latest/f.html#f-register-state"
    "#floating-point-control-and-status-register":
      headers:
      - '"F" Standard Extension for Single-Precision Floating-Point, Version 2.2'
      - Floating-Point Control and Status Register
      url: "/riscv-isa-manual/latest/f.html#floating-point-control-and-status-register"
    "#nan-generation-and-propagation":
      headers:
      - '"F" Standard Extension for Single-Precision Floating-Point, Version 2.2'
      - NaN Generation and Propagation
      url: "/riscv-isa-manual/latest/f.html#nan-generation-and-propagation"
    "#subnormal-arithmetic":
      headers:
      - '"F" Standard Extension for Single-Precision Floating-Point, Version 2.2'
      - Subnormal Arithmetic
      url: "/riscv-isa-manual/latest/f.html#subnormal-arithmetic"
    "#single-precision-load-and-store-instructions":
      headers:
      - '"F" Standard Extension for Single-Precision Floating-Point, Version 2.2'
      - Single-Precision Load and Store Instructions
      url: "/riscv-isa-manual/latest/f.html#single-precision-load-and-store-instructions"
    "#sec:single-float-compute":
      headers: &22
      - '"F" Standard Extension for Single-Precision Floating-Point, Version 2.2'
      - Single-Precision Floating-Point Computational Instructions
      url: "/riscv-isa-manual/latest/f.html#sec:single-float-compute"
    "#single-precision-floating-point-conversion-and-move-instructions":
      headers:
      - '"F" Standard Extension for Single-Precision Floating-Point, Version 2.2'
      - ''
      url: "/riscv-isa-manual/latest/f.html#single-precision-floating-point-conversion-and-move-instructions"
    "#single-precision-floating-point-compare-instructions":
      headers: &23
      - '"F" Standard Extension for Single-Precision Floating-Point, Version 2.2'
      - Single-Precision Floating-Point Compare Instructions
      url: "/riscv-isa-manual/latest/f.html#single-precision-floating-point-compare-instructions"
    "#single-precision-floating-point-classify-instruction":
      headers:
      - '"F" Standard Extension for Single-Precision Floating-Point, Version 2.2'
      - Single-Precision Floating-Point Classify Instruction
      url: "/riscv-isa-manual/latest/f.html#single-precision-floating-point-classify-instruction"
  d:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/d.html"
    "#d-standard-extension-for-double-precision-floating-point-version-2.2":
      headers:
      - '"D" Standard Extension for Double-Precision Floating-Point, Version 2.2'
      url: "/riscv-isa-manual/latest/d.html#d-standard-extension-for-double-precision-floating-point-version-2.2"
    "#d-register-state":
      headers:
      - '"D" Standard Extension for Double-Precision Floating-Point, Version 2.2'
      - D Register State
      url: "/riscv-isa-manual/latest/d.html#d-register-state"
    "#nanboxing":
      headers:
      - '"D" Standard Extension for Double-Precision Floating-Point, Version 2.2'
      - NaN Boxing of Narrower Values
      url: "/riscv-isa-manual/latest/d.html#nanboxing"
    "#fld_fsd":
      headers:
      - '"D" Standard Extension for Double-Precision Floating-Point, Version 2.2'
      - Double-Precision Load and Store Instructions
      url: "/riscv-isa-manual/latest/d.html#fld_fsd"
    "#double-precision-floating-point-computational-instructions":
      headers:
      - '"D" Standard Extension for Double-Precision Floating-Point, Version 2.2'
      - Double-Precision Floating-Point Computational Instructions
      url: "/riscv-isa-manual/latest/d.html#double-precision-floating-point-computational-instructions"
    "#double-precision-floating-point-conversion-and-move-instructions":
      headers:
      - '"D" Standard Extension for Double-Precision Floating-Point, Version 2.2'
      - Double-Precision Floating-Point Conversion and Move Instructions
      url: "/riscv-isa-manual/latest/d.html#double-precision-floating-point-conversion-and-move-instructions"
    "#double-precision-floating-point-compare-instructions":
      headers:
      - '"D" Standard Extension for Double-Precision Floating-Point, Version 2.2'
      - Double-Precision Floating-Point Compare Instructions
      url: "/riscv-isa-manual/latest/d.html#double-precision-floating-point-compare-instructions"
    "#double-precision-floating-point-classify-instruction":
      headers:
      - '"D" Standard Extension for Double-Precision Floating-Point, Version 2.2'
      - Double-Precision Floating-Point Classify Instruction
      url: "/riscv-isa-manual/latest/d.html#double-precision-floating-point-classify-instruction"
    "#sec:single-float-compute":
      headers: *22
      url: "/riscv-isa-manual/latest//d.html"
    "#single-precision-floating-point-compare-instructions":
      headers: *23
      url: "/riscv-isa-manual/latest//d.html"
  q:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/q.html"
    "#q-standard-extension-for-quad-precision-floating-point-version-2.2":
      headers:
      - '"Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2'
      url: "/riscv-isa-manual/latest/q.html#q-standard-extension-for-quad-precision-floating-point-version-2.2"
    "#quad-precision-load-and-store-instructions":
      headers:
      - '"Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2'
      - Quad-Precision Load and Store Instructions
      url: "/riscv-isa-manual/latest/q.html#quad-precision-load-and-store-instructions"
    "#quad-precision-computational-instructions":
      headers:
      - '"Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2'
      - Quad-Precision Computational Instructions
      url: "/riscv-isa-manual/latest/q.html#quad-precision-computational-instructions"
    "#quad-precision-convert-and-move-instructions":
      headers:
      - '"Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2'
      - Quad-Precision Convert and Move Instructions
      url: "/riscv-isa-manual/latest/q.html#quad-precision-convert-and-move-instructions"
    "#quad-precision-floating-point-compare-instructions":
      headers:
      - '"Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2'
      - Quad-Precision Floating-Point Compare Instructions
      url: "/riscv-isa-manual/latest/q.html#quad-precision-floating-point-compare-instructions"
    "#quad-precision-floating-point-classify-instruction":
      headers:
      - '"Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2'
      - Quad-Precision Floating-Point Classify Instruction
      url: "/riscv-isa-manual/latest/q.html#quad-precision-floating-point-classify-instruction"
    "#sec:single-float-compute":
      headers: *22
      url: "/riscv-isa-manual/latest//q.html"
    "#single-precision-floating-point-compare-instructions":
      headers: *23
      url: "/riscv-isa-manual/latest//q.html"
  csr:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/csr.html"
    "#csrinsts":
      headers:
      - '"Zicsr", Control and Status Register (CSR) Instructions, Version 2.0'
      url: "/riscv-isa-manual/latest/csr.html#csrinsts"
    "#csr-instructions":
      headers:
      - '"Zicsr", Control and Status Register (CSR) Instructions, Version 2.0'
      - CSR Instructions
      url: "/riscv-isa-manual/latest/csr.html#csr-instructions"
    "#csr-access-ordering":
      headers:
      - '"Zicsr", Control and Status Register (CSR) Instructions, Version 2.0'
      - CSR Instructions
      - CSR Access Ordering
      url: "/riscv-isa-manual/latest/csr.html#csr-access-ordering"
  supervisor:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/supervisor.html"
    "#supervisor":
      headers:
      - Supervisor-Level ISA, Version 1.12
      url: "/riscv-isa-manual/latest/supervisor.html#supervisor"
    "#supervisor-csrs":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      url: "/riscv-isa-manual/latest/supervisor.html#supervisor-csrs"
    "#sstatus":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - Supervisor Status Register (
      url: "/riscv-isa-manual/latest/supervisor.html#sstatus"
    "#base-isa-control-in-sstatus-register":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - Supervisor Status Register (
      - Register
      url: "/riscv-isa-manual/latest/supervisor.html#base-isa-control-in-sstatus-register"
    "#sec:sum":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - Supervisor Status Register (
      - Register
      url: "/riscv-isa-manual/latest/supervisor.html#sec:sum"
    "#endianness-control-in-sstatus-register":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - Supervisor Status Register (
      - Register
      url: "/riscv-isa-manual/latest/supervisor.html#endianness-control-in-sstatus-register"
    "#supervisor-trap-vector-base-address-register-stvec":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"
    "#supervisor-interrupt-registers-sip-and-sie":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"
    "#supervisor-timers-and-performance-counters":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - Supervisor Timers and Performance Counters
      url: "/riscv-isa-manual/latest/supervisor.html#supervisor-timers-and-performance-counters"
    "#counter-enable-register-scounteren":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/supervisor.html#counter-enable-register-scounteren"
    "#supervisor-scratch-register-sscratch":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/supervisor.html#supervisor-scratch-register-sscratch"
    "#supervisor-exception-program-counter-sepc":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/supervisor.html#supervisor-exception-program-counter-sepc"
    "#sec:scause":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/supervisor.html#sec:scause"
    "#supervisor-trap-value-stval-register":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - ") Register"
      url: "/riscv-isa-manual/latest/supervisor.html#supervisor-trap-value-stval-register"
    "#sec:satp":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor CSRs
      - ") Register"
      url: "/riscv-isa-manual/latest/supervisor.html#sec:satp"
    "#supervisor-instructions":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor Instructions
      url: "/riscv-isa-manual/latest/supervisor.html#supervisor-instructions"
    "#sec:sfence.vma":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - Supervisor Instructions
      - Supervisor Memory-Management Fence Instruction
      url: "/riscv-isa-manual/latest/supervisor.html#sec:sfence.vma"
    "#sec:sv32":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - 'Sv32: Page-Based 32-bit Virtual-Memory Systems'
      url: "/riscv-isa-manual/latest/supervisor.html#sec:sv32"
    "#sec:translation":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - 'Sv32: Page-Based 32-bit Virtual-Memory Systems'
      - Addressing and Memory Protection
      url: "/riscv-isa-manual/latest/supervisor.html#sec:translation"
    "#sv32algorithm":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - 'Sv32: Page-Based 32-bit Virtual-Memory Systems'
      - Virtual Address Translation Process
      url: "/riscv-isa-manual/latest/supervisor.html#sv32algorithm"
    "#sec:sv39":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - 'Sv39: Page-Based 39-bit Virtual-Memory System'
      url: "/riscv-isa-manual/latest/supervisor.html#sec:sv39"
    "#addressing-and-memory-protection":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - 'Sv39: Page-Based 39-bit Virtual-Memory System'
      - Addressing and Memory Protection
      url: "/riscv-isa-manual/latest/supervisor.html#addressing-and-memory-protection"
    "#sec:sv48":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - 'Sv48: Page-Based 48-bit Virtual-Memory System'
      url: "/riscv-isa-manual/latest/supervisor.html#sec:sv48"
    "#addressing-and-memory-protection-1":
      headers:
      - Supervisor-Level ISA, Version 1.12
      - 'Sv48: Page-Based 48-bit Virtual-Memory System'
      - Addressing and Memory Protection
      url: "/riscv-isa-manual/latest/supervisor.html#addressing-and-memory-protection-1"
  hypervisor:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/hypervisor.html"
    "#hypervisor":
      headers:
      - Hypervisor Extension, Version 0.5
      url: "/riscv-isa-manual/latest/hypervisor.html#hypervisor"
    "#privilege-modes":
      headers:
      - Hypervisor Extension, Version 0.5
      - Privilege Modes
      url: "/riscv-isa-manual/latest/hypervisor.html#privilege-modes"
    "#hypervisor-and-virtual-supervisor-csrs":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      url: "/riscv-isa-manual/latest/hypervisor.html#hypervisor-and-virtual-supervisor-csrs"
    "#hypervisor-status-register-hstatus":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#hypervisor-status-register-hstatus"
    "#hypervisor-trap-delegation-registers-hedeleg-and-hideleg":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#hypervisor-trap-delegation-registers-hedeleg-and-hideleg"
    "#sec:hinterruptregs":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#sec:hinterruptregs"
    "#sec:hgeinterruptregs":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#sec:hgeinterruptregs"
    "#hypervisor-counter-enable-register-hcounteren":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#hypervisor-counter-enable-register-hcounteren"
    "#hypervisor-time-delta-registers-htimedelta-htimedeltah":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#hypervisor-time-delta-registers-htimedelta-htimedeltah"
    "#hypervisor-trap-value-register-htval":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#hypervisor-trap-value-register-htval"
    "#hypervisor-trap-instruction-register-htinst":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#hypervisor-trap-instruction-register-htinst"
    "#sec:hgatp":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#sec:hgatp"
    "#virtual-supervisor-status-register-vsstatus":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#virtual-supervisor-status-register-vsstatus"
    "#virtual-supervisor-interrupt-registers-vsip-and-vsie":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#virtual-supervisor-interrupt-registers-vsip-and-vsie"
    "#virtual-supervisor-trap-vector-base-address-register-vstvec":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#virtual-supervisor-trap-vector-base-address-register-vstvec"
    "#virtual-supervisor-scratch-register-vsscratch":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#virtual-supervisor-scratch-register-vsscratch"
    "#virtual-supervisor-exception-program-counter-vsepc":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#virtual-supervisor-exception-program-counter-vsepc"
    "#virtual-supervisor-cause-register-vscause":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#virtual-supervisor-cause-register-vscause"
    "#virtual-supervisor-trap-value-register-vstval":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#virtual-supervisor-trap-value-register-vstval"
    "#virtual-supervisor-address-translation-and-protection-register-vsatp":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor and Virtual Supervisor CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#virtual-supervisor-address-translation-and-protection-register-vsatp"
    "#hypervisor-instructions":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor Instructions
      url: "/riscv-isa-manual/latest/hypervisor.html#hypervisor-instructions"
    "#sec:hfence.vma":
      headers:
      - Hypervisor Extension, Version 0.5
      - Hypervisor Instructions
      - Hypervisor Memory-Management Fence Instructions
      url: "/riscv-isa-manual/latest/hypervisor.html#sec:hfence.vma"
    "#machine-level-csrs":
      headers:
      - Hypervisor Extension, Version 0.5
      - Machine-Level CSRs
      url: "/riscv-isa-manual/latest/hypervisor.html#machine-level-csrs"
    "#machine-status-registers-mstatus-and-mstatush":
      headers:
      - Hypervisor Extension, Version 0.5
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#machine-status-registers-mstatus-and-mstatush"
    "#machine-interrupt-delegation-register-mideleg":
      headers:
      - Hypervisor Extension, Version 0.5
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#machine-interrupt-delegation-register-mideleg"
    "#machine-interrupt-registers-mip-and-mie":
      headers:
      - Hypervisor Extension, Version 0.5
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#machine-interrupt-registers-mip-and-mie"
    "#machine-second-trap-value-register-mtval2":
      headers:
      - Hypervisor Extension, Version 0.5
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#machine-second-trap-value-register-mtval2"
    "#machine-trap-instruction-register-mtinst":
      headers:
      - Hypervisor Extension, Version 0.5
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/hypervisor.html#machine-trap-instruction-register-mtinst"
    "#sec:two-stage-translation":
      headers:
      - Hypervisor Extension, Version 0.5
      - Two-Stage Address Translation
      url: "/riscv-isa-manual/latest/hypervisor.html#sec:two-stage-translation"
    "#sec:guest-addr-translation":
      headers:
      - Hypervisor Extension, Version 0.5
      - Two-Stage Address Translation
      - Guest Physical Address Translation
      url: "/riscv-isa-manual/latest/hypervisor.html#sec:guest-addr-translation"
    "#guest-page-faults":
      headers:
      - Hypervisor Extension, Version 0.5
      - Two-Stage Address Translation
      - Guest-Page Faults
      url: "/riscv-isa-manual/latest/hypervisor.html#guest-page-faults"
    "#memory-management-fences":
      headers:
      - Hypervisor Extension, Version 0.5
      - Two-Stage Address Translation
      - Memory-Management Fences
      url: "/riscv-isa-manual/latest/hypervisor.html#memory-management-fences"
    "#wfi-in-virtual-operating-modes":
      headers:
      - Hypervisor Extension, Version 0.5
      - WFI in Virtual Operating Modes
      url: "/riscv-isa-manual/latest/hypervisor.html#wfi-in-virtual-operating-modes"
    "#traps":
      headers:
      - Hypervisor Extension, Version 0.5
      - Traps
      url: "/riscv-isa-manual/latest/hypervisor.html#traps"
    "#trap-cause-codes":
      headers:
      - Hypervisor Extension, Version 0.5
      - Traps
      - Trap Cause Codes
      url: "/riscv-isa-manual/latest/hypervisor.html#trap-cause-codes"
    "#trap-entry":
      headers:
      - Hypervisor Extension, Version 0.5
      - Traps
      - Trap Entry
      url: "/riscv-isa-manual/latest/hypervisor.html#trap-entry"
    "#sec:tinst-vals":
      headers:
      - Hypervisor Extension, Version 0.5
      - Traps
      - or
      url: "/riscv-isa-manual/latest/hypervisor.html#sec:tinst-vals"
    "#trap-return":
      headers:
      - Hypervisor Extension, Version 0.5
      - Traps
      - Trap Return
      url: "/riscv-isa-manual/latest/hypervisor.html#trap-return"
  machine:
    '':
      headers: []
      url: "/riscv-isa-manual/latest/machine.html"
    "#machine":
      headers:
      - Machine-Level ISA, Version 1.12
      url: "/riscv-isa-manual/latest/machine.html#machine"
    "#machine-level-csrs":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      url: "/riscv-isa-manual/latest/machine.html#machine-level-csrs"
    "#sec:misa":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - Machine ISA Register
      url: "/riscv-isa-manual/latest/machine.html#sec:misa"
    "#machine-vendor-id-register-mvendorid":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - Machine Vendor ID Register
      url: "/riscv-isa-manual/latest/machine.html#machine-vendor-id-register-mvendorid"
    "#machine-architecture-id-register-marchid":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - Machine Architecture ID Register
      url: "/riscv-isa-manual/latest/machine.html#machine-architecture-id-register-marchid"
    "#machine-implementation-id-register-mimpid":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - Machine Implementation ID Register
      url: "/riscv-isa-manual/latest/machine.html#machine-implementation-id-register-mimpid"
    "#hart-id-register-mhartid":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - Hart ID Register
      url: "/riscv-isa-manual/latest/machine.html#hart-id-register-mhartid"
    "#machine-status-registers-mstatus-and-mstatush":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/machine.html#machine-status-registers-mstatus-and-mstatush"
    "#privstack":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      - register
      url: "/riscv-isa-manual/latest/machine.html#privstack"
    "#xlen-control":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      - Register
      url: "/riscv-isa-manual/latest/machine.html#xlen-control"
    "#memory-privilege-in-mstatus-register":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      - Register
      url: "/riscv-isa-manual/latest/machine.html#memory-privilege-in-mstatus-register"
    "#endianness-control-in-mstatus-and-mstatush-registers":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      - Registers
      url: "/riscv-isa-manual/latest/machine.html#endianness-control-in-mstatus-and-mstatush-registers"
    "#virt-control":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      - Register
      url: "/riscv-isa-manual/latest/machine.html#virt-control"
    "#extension-context-status-in-mstatus-register":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      - Register
      url: "/riscv-isa-manual/latest/machine.html#extension-context-status-in-mstatus-register"
    "#machine-trap-vector-base-address-register-mtvec":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/machine.html#machine-trap-vector-base-address-register-mtvec"
    "#machine-trap-delegation-registers-medeleg-and-mideleg":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/machine.html#machine-trap-delegation-registers-medeleg-and-mideleg"
    "#machine-interrupt-registers-mip-and-mie":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/machine.html#machine-interrupt-registers-mip-and-mie"
    "#machine-timer-registers-mtime-and-mtimecmp":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/machine.html#machine-timer-registers-mtime-and-mtimecmp"
    "#hardware-performance-monitor":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - Hardware Performance Monitor
      url: "/riscv-isa-manual/latest/machine.html#hardware-performance-monitor"
    "#sec:mcounteren":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/machine.html#sec:mcounteren"
    "#machine-counter-inhibit-csr-mcountinhibit":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/machine.html#machine-counter-inhibit-csr-mcountinhibit"
    "#machine-scratch-register-mscratch":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/machine.html#machine-scratch-register-mscratch"
    "#machine-exception-program-counter-mepc":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/machine.html#machine-exception-program-counter-mepc"
    "#sec:mcause":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ")"
      url: "/riscv-isa-manual/latest/machine.html#sec:mcause"
    "#machine-trap-value-mtval-register":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Level CSRs
      - ") Register"
      url: "/riscv-isa-manual/latest/machine.html#machine-trap-value-mtval-register"
    "#machine-mode-privileged-instructions":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Mode Privileged Instructions
      url: "/riscv-isa-manual/latest/machine.html#machine-mode-privileged-instructions"
    "#environment-call-and-breakpoint":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Mode Privileged Instructions
      - Environment Call and Breakpoint
      url: "/riscv-isa-manual/latest/machine.html#environment-call-and-breakpoint"
    "#otherpriv":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Mode Privileged Instructions
      - Trap-Return Instructions
      url: "/riscv-isa-manual/latest/machine.html#otherpriv"
    "#wfi":
      headers:
      - Machine-Level ISA, Version 1.12
      - Machine-Mode Privileged Instructions
      - Wait for Interrupt
      url: "/riscv-isa-manual/latest/machine.html#wfi"
    "#sec:reset":
      headers:
      - Machine-Level ISA, Version 1.12
      - Reset
      url: "/riscv-isa-manual/latest/machine.html#sec:reset"
    "#sec:nmi":
      headers:
      - Machine-Level ISA, Version 1.12
      - Non-Maskable Interrupts
      url: "/riscv-isa-manual/latest/machine.html#sec:nmi"
    "#sec:pma":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Attributes
      url: "/riscv-isa-manual/latest/machine.html#sec:pma"
    "#main-memory-versus-io-versus-empty-regions":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Attributes
      - Main Memory versus I/O versus Empty Regions
      url: "/riscv-isa-manual/latest/machine.html#main-memory-versus-io-versus-empty-regions"
    "#supported-access-type-pmas":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Attributes
      - Supported Access Type PMAs
      url: "/riscv-isa-manual/latest/machine.html#supported-access-type-pmas"
    "#atomicity-pmas":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Attributes
      - Atomicity PMAs
      url: "/riscv-isa-manual/latest/machine.html#atomicity-pmas"
    "#amo-pma":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Attributes
      - Atomicity PMAs
      - AMO PMA
      url: "/riscv-isa-manual/latest/machine.html#amo-pma"
    "#reservability-pma":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Attributes
      - Atomicity PMAs
      - Reservability PMA
      url: "/riscv-isa-manual/latest/machine.html#reservability-pma"
    "#alignment":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Attributes
      - Atomicity PMAs
      - Alignment
      url: "/riscv-isa-manual/latest/machine.html#alignment"
    "#memory-ordering-pmas":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Attributes
      - Memory-Ordering PMAs
      url: "/riscv-isa-manual/latest/machine.html#memory-ordering-pmas"
    "#coherence-and-cacheability-pmas":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Attributes
      - Coherence and Cacheability PMAs
      url: "/riscv-isa-manual/latest/machine.html#coherence-and-cacheability-pmas"
    "#idempotency-pmas":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Attributes
      - Idempotency PMAs
      url: "/riscv-isa-manual/latest/machine.html#idempotency-pmas"
    "#sec:pmp":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Protection
      url: "/riscv-isa-manual/latest/machine.html#sec:pmp"
    "#physical-memory-protection-csrs":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Protection
      - Physical Memory Protection CSRs
      url: "/riscv-isa-manual/latest/machine.html#physical-memory-protection-csrs"
    "#address-matching":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Protection
      - Physical Memory Protection CSRs
      - Address Matching
      url: "/riscv-isa-manual/latest/machine.html#address-matching"
    "#locking-and-privilege-mode":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Protection
      - Physical Memory Protection CSRs
      - Locking and Privilege Mode
      url: "/riscv-isa-manual/latest/machine.html#locking-and-privilege-mode"
    "#priority-and-matching-logic":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Protection
      - Physical Memory Protection CSRs
      - Priority and Matching Logic
      url: "/riscv-isa-manual/latest/machine.html#priority-and-matching-logic"
    "#pmp-vmem":
      headers:
      - Machine-Level ISA, Version 1.12
      - Physical Memory Protection
      - Physical Memory Protection and Paging
      url: "/riscv-isa-manual/latest/machine.html#pmp-vmem"
  v:
    '':
      headers: []
      url: "/riscv-v-spec/draft/v-spec.html"
    "#_introduction":
      headers:
      - 1. Introduction
      url: "/riscv-v-spec/draft/v-spec.html#_introduction"
    "#_implementation_defined_constant_parameters":
      headers:
      - 2. Implementation-defined Constant Parameters
      url: "/riscv-v-spec/draft/v-spec.html#_implementation_defined_constant_parameters"
    "#_vector_extension_programmer_s_model":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      url: "/riscv-v-spec/draft/v-spec.html#_vector_extension_programmer_s_model"
    "#_vector_registers":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.1. Vector Registers
      url: "/riscv-v-spec/draft/v-spec.html#_vector_registers"
    "#_vector_context_status_in_code_mstatus_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.2. Vector Context Status in
      url: "/riscv-v-spec/draft/v-spec.html#_vector_context_status_in_code_mstatus_code"
    "#_vector_type_register_code_vtype_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.3. Vector type register,
      url: "/riscv-v-spec/draft/v-spec.html#_vector_type_register_code_vtype_code"
    "#_vector_standard_element_width_code_vsew_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.3. Vector type register,
      - 3.3.1. Vector standard element width
      url: "/riscv-v-spec/draft/v-spec.html#_vector_standard_element_width_code_vsew_code"
    "#_vector_register_grouping_code_vlmul_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.3. Vector type register,
      - ")"
      url: "/riscv-v-spec/draft/v-spec.html#_vector_register_grouping_code_vlmul_code"
    "#_vector_type_illegal_code_vill_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.3. Vector type register,
      - 3.3.3. Vector Type Illegal
      url: "/riscv-v-spec/draft/v-spec.html#_vector_type_illegal_code_vill_code"
    "#_vector_length_register_code_vl_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.4. Vector Length Register
      url: "/riscv-v-spec/draft/v-spec.html#_vector_length_register_code_vl_code"
    "#_vector_byte_length_code_vlenb_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.5. Vector Byte Length
      url: "/riscv-v-spec/draft/v-spec.html#_vector_byte_length_code_vlenb_code"
    "#_vector_start_index_csr_code_vstart_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.6. Vector Start Index CSR
      url: "/riscv-v-spec/draft/v-spec.html#_vector_start_index_csr_code_vstart_code"
    "#_vector_fixed_point_rounding_mode_register_code_vxrm_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.7. Vector Fixed-Point Rounding Mode Register
      url: "/riscv-v-spec/draft/v-spec.html#_vector_fixed_point_rounding_mode_register_code_vxrm_code"
    "#_vector_fixed_point_saturation_flag_code_vxsat_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.8. Vector Fixed-Point Saturation Flag
      url: "/riscv-v-spec/draft/v-spec.html#_vector_fixed_point_saturation_flag_code_vxsat_code"
    "#_vector_fixed_point_fields_in_code_fcsr_code":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.9. Vector Fixed-Point Fields in
      url: "/riscv-v-spec/draft/v-spec.html#_vector_fixed_point_fields_in_code_fcsr_code"
    "#_state_of_vector_extension_at_reset":
      headers:
      - 3. Vector Extension Programmer&rsquo;s Model
      - 3.10. State of Vector Extension at Reset
      url: "/riscv-v-spec/draft/v-spec.html#_state_of_vector_extension_at_reset"
    "#_mapping_of_vector_elements_to_vector_register_state":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      url: "/riscv-v-spec/draft/v-spec.html#_mapping_of_vector_elements_to_vector_register_state"
    "#_mapping_with_lmul_1":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      - 4.1. Mapping with LMUL=1
      url: "/riscv-v-spec/draft/v-spec.html#_mapping_with_lmul_1"
    "#_mapping_with_lmul_1_2":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      - 4.2. Mapping with LMUL > 1
      url: "/riscv-v-spec/draft/v-spec.html#_mapping_with_lmul_1_2"
    "#_mapping_across_mixed_width_operations":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      - 4.3. Mapping across Mixed-Width Operations
      url: "/riscv-v-spec/draft/v-spec.html#_mapping_across_mixed_width_operations"
    "#sec-mask-register-layout":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      - 4.4. Mask Register Layout
      url: "/riscv-v-spec/draft/v-spec.html#sec-mask-register-layout"
    "#_vector_instruction_formats":
      headers:
      - 5. Vector Instruction Formats
      url: "/riscv-v-spec/draft/v-spec.html#_vector_instruction_formats"
    "#_scalar_operands":
      headers:
      - 5. Vector Instruction Formats
      - 5.1. Scalar Operands
      url: "/riscv-v-spec/draft/v-spec.html#_scalar_operands"
    "#_vector_operands":
      headers:
      - 5. Vector Instruction Formats
      - 5.2. Vector Operands
      url: "/riscv-v-spec/draft/v-spec.html#_vector_operands"
    "#_vector_masking":
      headers:
      - 5. Vector Instruction Formats
      - 5.3. Vector Masking
      url: "/riscv-v-spec/draft/v-spec.html#_vector_masking"
    "#sec-vector-mask-encoding":
      headers:
      - 5. Vector Instruction Formats
      - 5.3. Vector Masking
      - 5.3.1. Mask Encoding
      url: "/riscv-v-spec/draft/v-spec.html#sec-vector-mask-encoding"
    "#_prestart_active_inactive_body_and_tail_element_definitions":
      headers:
      - 5. Vector Instruction Formats
      - 5.4. Prestart, Active, Inactive, Body, and Tail Element Definitions
      url: "/riscv-v-spec/draft/v-spec.html#_prestart_active_inactive_body_and_tail_element_definitions"
    "#_configuration_setting_instructions":
      headers:
      - 6. Configuration-Setting Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_configuration_setting_instructions"
    "#__code_vsetvli_code_code_vsetvl_code_instructions":
      headers:
      - 6. Configuration-Setting Instructions
      - instructions
      url: "/riscv-v-spec/draft/v-spec.html#__code_vsetvli_code_code_vsetvl_code_instructions"
    "#_constraints_on_setting_code_vl_code":
      headers:
      - 6. Configuration-Setting Instructions
      - 6.2. Constraints on Setting
      url: "/riscv-v-spec/draft/v-spec.html#_constraints_on_setting_code_vl_code"
    "#__code_vsetvl_code_instruction":
      headers:
      - 6. Configuration-Setting Instructions
      - Instruction
      url: "/riscv-v-spec/draft/v-spec.html#__code_vsetvl_code_instruction"
    "#_examples":
      headers:
      - 6. Configuration-Setting Instructions
      - 6.4. Examples
      url: "/riscv-v-spec/draft/v-spec.html#_examples"
    "#_vector_loads_and_stores":
      headers:
      - 7. Vector Loads and Stores
      url: "/riscv-v-spec/draft/v-spec.html#_vector_loads_and_stores"
    "#_vector_load_store_instruction_encoding":
      headers:
      - 7. Vector Loads and Stores
      - 7.1. Vector Load/Store Instruction Encoding
      url: "/riscv-v-spec/draft/v-spec.html#_vector_load_store_instruction_encoding"
    "#_vector_load_store_addressing_modes":
      headers:
      - 7. Vector Loads and Stores
      - 7.2. Vector Load/Store Addressing Modes
      url: "/riscv-v-spec/draft/v-spec.html#_vector_load_store_addressing_modes"
    "#_vector_load_store_width_encoding":
      headers:
      - 7. Vector Loads and Stores
      - 7.3. Vector Load/Store Width Encoding
      url: "/riscv-v-spec/draft/v-spec.html#_vector_load_store_width_encoding"
    "#_vector_unit_stride_instructions":
      headers:
      - 7. Vector Loads and Stores
      - 7.4. Vector Unit-Stride Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_unit_stride_instructions"
    "#_vector_strided_instructions":
      headers:
      - 7. Vector Loads and Stores
      - 7.5. Vector Strided Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_strided_instructions"
    "#_vector_indexed_instructions":
      headers:
      - 7. Vector Loads and Stores
      - 7.6. Vector Indexed Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_indexed_instructions"
    "#_unit_stride_fault_only_first_loads":
      headers:
      - 7. Vector Loads and Stores
      - 7.7. Unit-stride Fault-Only-First Loads
      url: "/riscv-v-spec/draft/v-spec.html#_unit_stride_fault_only_first_loads"
    "#sec-aos":
      headers:
      - 7. Vector Loads and Stores
      - ")"
      url: "/riscv-v-spec/draft/v-spec.html#sec-aos"
    "#_vector_unit_stride_segment_loads_and_stores":
      headers:
      - 7. Vector Loads and Stores
      - ")"
      - 7.8.1. Vector Unit-Stride Segment Loads and Stores
      url: "/riscv-v-spec/draft/v-spec.html#_vector_unit_stride_segment_loads_and_stores"
    "#_vector_strided_segment_loads_and_stores":
      headers:
      - 7. Vector Loads and Stores
      - ")"
      - 7.8.2. Vector Strided Segment Loads and Stores
      url: "/riscv-v-spec/draft/v-spec.html#_vector_strided_segment_loads_and_stores"
    "#_vector_indexed_segment_loads_and_stores":
      headers:
      - 7. Vector Loads and Stores
      - ")"
      - 7.8.3. Vector Indexed Segment Loads and Stores
      url: "/riscv-v-spec/draft/v-spec.html#_vector_indexed_segment_loads_and_stores"
    "#_vector_load_store_whole_register_instructions":
      headers:
      - 7. Vector Loads and Stores
      - 7.9. Vector Load/Store Whole Register Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_load_store_whole_register_instructions"
    "#_vector_amo_operations_code_zvamo_code":
      headers:
      - ")"
      url: "/riscv-v-spec/draft/v-spec.html#_vector_amo_operations_code_zvamo_code"
    "#_vector_memory_alignment_constraints":
      headers:
      - 9. Vector Memory Alignment Constraints
      url: "/riscv-v-spec/draft/v-spec.html#_vector_memory_alignment_constraints"
    "#_vector_memory_consistency_model":
      headers:
      - 10. Vector Memory Consistency Model
      url: "/riscv-v-spec/draft/v-spec.html#_vector_memory_consistency_model"
    "#_vector_arithmetic_instruction_formats":
      headers:
      - 11. Vector Arithmetic Instruction Formats
      url: "/riscv-v-spec/draft/v-spec.html#_vector_arithmetic_instruction_formats"
    "#_vector_arithmetic_instruction_encoding":
      headers:
      - 11. Vector Arithmetic Instruction Formats
      - 11.1. Vector Arithmetic Instruction encoding
      url: "/riscv-v-spec/draft/v-spec.html#_vector_arithmetic_instruction_encoding"
    "#sec-widening":
      headers:
      - 11. Vector Arithmetic Instruction Formats
      - 11.2. Widening Vector Arithmetic Instructions
      url: "/riscv-v-spec/draft/v-spec.html#sec-widening"
    "#sec-narrowing":
      headers:
      - 11. Vector Arithmetic Instruction Formats
      - 11.3. Narrowing Vector Arithmetic Instructions
      url: "/riscv-v-spec/draft/v-spec.html#sec-narrowing"
    "#_vector_integer_arithmetic_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_integer_arithmetic_instructions"
    "#_vector_single_width_integer_add_and_subtract":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.1. Vector Single-Width Integer Add and Subtract
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_integer_add_and_subtract"
    "#_vector_widening_integer_add_subtract":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.2. Vector Widening Integer Add/Subtract
      url: "/riscv-v-spec/draft/v-spec.html#_vector_widening_integer_add_subtract"
    "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.3. Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    "#_vector_bitwise_logical_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.4. Vector Bitwise Logical Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_bitwise_logical_instructions"
    "#_vector_single_width_bit_shift_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.5. Vector Single-Width Bit Shift Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_bit_shift_instructions"
    "#_vector_narrowing_integer_right_shift_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.6. Vector Narrowing Integer Right Shift Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_narrowing_integer_right_shift_instructions"
    "#_vector_integer_comparison_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.7. Vector Integer Comparison Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_integer_comparison_instructions"
    "#_vector_integer_min_max_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.8. Vector Integer Min/Max Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_integer_min_max_instructions"
    "#_vector_single_width_integer_multiply_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.9. Vector Single-Width Integer Multiply Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_integer_multiply_instructions"
    "#_vector_integer_divide_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.10. Vector Integer Divide Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_integer_divide_instructions"
    "#_vector_widening_integer_multiply_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.11. Vector Widening Integer Multiply Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_widening_integer_multiply_instructions"
    "#_vector_single_width_integer_multiply_add_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.12. Vector Single-Width Integer Multiply-Add Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_integer_multiply_add_instructions"
    "#_vector_widening_integer_multiply_add_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.13. Vector Widening Integer Multiply-Add Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_widening_integer_multiply_add_instructions"
    "#_vector_quad_widening_integer_multiply_add_instructions_extension_code_zvqmac_code":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - ")"
      url: "/riscv-v-spec/draft/v-spec.html#_vector_quad_widening_integer_multiply_add_instructions_extension_code_zvqmac_code"
    "#_vector_integer_merge_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.15. Vector Integer Merge Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_integer_merge_instructions"
    "#_vector_integer_move_instructions":
      headers:
      - 12. Vector Integer Arithmetic Instructions
      - 12.16. Vector Integer Move Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_integer_move_instructions"
    "#_vector_fixed_point_arithmetic_instructions":
      headers:
      - 13. Vector Fixed-Point Arithmetic Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_fixed_point_arithmetic_instructions"
    "#_vector_single_width_saturating_add_and_subtract":
      headers:
      - 13. Vector Fixed-Point Arithmetic Instructions
      - 13.1. Vector Single-Width Saturating Add and Subtract
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_saturating_add_and_subtract"
    "#_vector_single_width_averaging_add_and_subtract":
      headers:
      - 13. Vector Fixed-Point Arithmetic Instructions
      - 13.2. Vector Single-Width Averaging Add and Subtract
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_averaging_add_and_subtract"
    "#_vector_single_width_fractional_multiply_with_rounding_and_saturation":
      headers:
      - 13. Vector Fixed-Point Arithmetic Instructions
      - 13.3. Vector Single-Width Fractional Multiply with Rounding and Saturation
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_fractional_multiply_with_rounding_and_saturation"
    "#_vector_single_width_scaling_shift_instructions":
      headers:
      - 13. Vector Fixed-Point Arithmetic Instructions
      - 13.4. Vector Single-Width Scaling Shift Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_scaling_shift_instructions"
    "#_vector_narrowing_fixed_point_clip_instructions":
      headers:
      - 13. Vector Fixed-Point Arithmetic Instructions
      - 13.5. Vector Narrowing Fixed-Point Clip Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_narrowing_fixed_point_clip_instructions"
    "#_vector_floating_point_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_floating_point_instructions"
    "#_vector_floating_point_exception_flags":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.1. Vector Floating-Point Exception Flags
      url: "/riscv-v-spec/draft/v-spec.html#_vector_floating_point_exception_flags"
    "#_vector_single_width_floating_point_add_subtract_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.2. Vector Single-Width Floating-Point Add/Subtract Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_floating_point_add_subtract_instructions"
    "#_vector_widening_floating_point_add_subtract_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.3. Vector Widening Floating-Point Add/Subtract Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_widening_floating_point_add_subtract_instructions"
    "#_vector_single_width_floating_point_multiply_divide_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.4. Vector Single-Width Floating-Point Multiply/Divide Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_floating_point_multiply_divide_instructions"
    "#_vector_widening_floating_point_multiply":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.5. Vector Widening Floating-Point Multiply
      url: "/riscv-v-spec/draft/v-spec.html#_vector_widening_floating_point_multiply"
    "#_vector_single_width_floating_point_fused_multiply_add_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.6. Vector Single-Width Floating-Point Fused Multiply-Add Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_floating_point_fused_multiply_add_instructions"
    "#_vector_widening_floating_point_fused_multiply_add_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.7. Vector Widening Floating-Point Fused Multiply-Add Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_widening_floating_point_fused_multiply_add_instructions"
    "#_vector_floating_point_square_root_instruction":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.8. Vector Floating-Point Square-Root Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_floating_point_square_root_instruction"
    "#_vector_floating_point_min_max_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.9. Vector Floating-Point MIN/MAX Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_floating_point_min_max_instructions"
    "#_vector_floating_point_sign_injection_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.10. Vector Floating-Point Sign-Injection Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_floating_point_sign_injection_instructions"
    "#_vector_floating_point_compare_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.11. Vector Floating-Point Compare Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_floating_point_compare_instructions"
    "#_vector_floating_point_classify_instruction":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.12. Vector Floating-Point Classify Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_floating_point_classify_instruction"
    "#_vector_floating_point_merge_instruction":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.13. Vector Floating-Point Merge Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_floating_point_merge_instruction"
    "#_vector_floating_point_move_instruction":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.14. Vector Floating-Point Move Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_floating_point_move_instruction"
    "#_single_width_floating_point_integer_type_convert_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.15. Single-Width Floating-Point/Integer Type-Convert Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_single_width_floating_point_integer_type_convert_instructions"
    "#_widening_floating_point_integer_type_convert_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.16. Widening Floating-Point/Integer Type-Convert Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_widening_floating_point_integer_type_convert_instructions"
    "#_narrowing_floating_point_integer_type_convert_instructions":
      headers:
      - 14. Vector Floating-Point Instructions
      - 14.17. Narrowing Floating-Point/Integer Type-Convert Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_narrowing_floating_point_integer_type_convert_instructions"
    "#_vector_reduction_operations":
      headers:
      - 15. Vector Reduction Operations
      url: "/riscv-v-spec/draft/v-spec.html#_vector_reduction_operations"
    "#_vector_single_width_integer_reduction_instructions":
      headers:
      - 15. Vector Reduction Operations
      - 15.1. Vector Single-Width Integer Reduction Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_integer_reduction_instructions"
    "#_vector_widening_integer_reduction_instructions":
      headers:
      - 15. Vector Reduction Operations
      - 15.2. Vector Widening Integer Reduction Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_widening_integer_reduction_instructions"
    "#_vector_single_width_floating_point_reduction_instructions":
      headers:
      - 15. Vector Reduction Operations
      - 15.3. Vector Single-Width Floating-Point Reduction Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_floating_point_reduction_instructions"
    "#_vector_ordered_single_width_floating_point_sum_reduction":
      headers:
      - 15. Vector Reduction Operations
      - 15.3. Vector Single-Width Floating-Point Reduction Instructions
      - 15.3.1. Vector Ordered Single-Width Floating-Point Sum Reduction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_ordered_single_width_floating_point_sum_reduction"
    "#_vector_unordered_single_width_floating_point_sum_reduction":
      headers:
      - 15. Vector Reduction Operations
      - 15.3. Vector Single-Width Floating-Point Reduction Instructions
      - 15.3.2. Vector Unordered Single-Width Floating-Point Sum Reduction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_unordered_single_width_floating_point_sum_reduction"
    "#_vector_single_width_floating_max_and_min_reductions":
      headers:
      - 15. Vector Reduction Operations
      - 15.3. Vector Single-Width Floating-Point Reduction Instructions
      - 15.3.3. Vector Single-Width Floating Max and Min Reductions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_single_width_floating_max_and_min_reductions"
    "#_vector_widening_floating_point_reduction_instructions":
      headers:
      - 15. Vector Reduction Operations
      - 15.4. Vector Widening Floating-Point Reduction Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_widening_floating_point_reduction_instructions"
    "#_vector_mask_instructions":
      headers:
      - 16. Vector Mask Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_mask_instructions"
    "#sec-mask-register-logical":
      headers:
      - 16. Vector Mask Instructions
      - 16.1. Vector Mask-Register Logical Instructions
      url: "/riscv-v-spec/draft/v-spec.html#sec-mask-register-logical"
    "#_vector_mask_population_count_code_vpopc_code":
      headers:
      - 16. Vector Mask Instructions
      - 16.2. Vector mask population count
      url: "/riscv-v-spec/draft/v-spec.html#_vector_mask_population_count_code_vpopc_code"
    "#__code_vfirst_code_find_first_set_mask_bit":
      headers:
      - 16. Vector Mask Instructions
      - find-first-set mask bit
      url: "/riscv-v-spec/draft/v-spec.html#__code_vfirst_code_find_first_set_mask_bit"
    "#__code_vmsbf_m_code_set_before_first_mask_bit":
      headers:
      - 16. Vector Mask Instructions
      - set-before-first mask bit
      url: "/riscv-v-spec/draft/v-spec.html#__code_vmsbf_m_code_set_before_first_mask_bit"
    "#__code_vmsif_m_code_set_including_first_mask_bit":
      headers:
      - 16. Vector Mask Instructions
      - set-including-first mask bit
      url: "/riscv-v-spec/draft/v-spec.html#__code_vmsif_m_code_set_including_first_mask_bit"
    "#__code_vmsof_m_code_set_only_first_mask_bit":
      headers:
      - 16. Vector Mask Instructions
      - set-only-first mask bit
      url: "/riscv-v-spec/draft/v-spec.html#__code_vmsof_m_code_set_only_first_mask_bit"
    "#_example_using_vector_mask_instructions":
      headers:
      - 16. Vector Mask Instructions
      - 16.7. Example using vector mask instructions
      url: "/riscv-v-spec/draft/v-spec.html#_example_using_vector_mask_instructions"
    "#_vector_iota_instruction":
      headers:
      - 16. Vector Mask Instructions
      - 16.8. Vector Iota Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_iota_instruction"
    "#_vector_element_index_instruction":
      headers:
      - 16. Vector Mask Instructions
      - 16.9. Vector Element Index Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_element_index_instruction"
    "#_vector_permutation_instructions":
      headers:
      - 17. Vector Permutation Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_permutation_instructions"
    "#_integer_scalar_move_instructions":
      headers:
      - 17. Vector Permutation Instructions
      - 17.1. Integer Scalar Move Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_integer_scalar_move_instructions"
    "#_floating_point_scalar_move_instructions":
      headers:
      - 17. Vector Permutation Instructions
      - 17.2. Floating-Point Scalar Move Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_floating_point_scalar_move_instructions"
    "#_vector_slide_instructions":
      headers:
      - 17. Vector Permutation Instructions
      - 17.3. Vector Slide Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_slide_instructions"
    "#_vector_slideup_instructions":
      headers:
      - 17. Vector Permutation Instructions
      - 17.3. Vector Slide Instructions
      - 17.3.1. Vector Slideup Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_slideup_instructions"
    "#_vector_slidedown_instructions":
      headers:
      - 17. Vector Permutation Instructions
      - 17.3. Vector Slide Instructions
      - 17.3.2. Vector Slidedown Instructions
      url: "/riscv-v-spec/draft/v-spec.html#_vector_slidedown_instructions"
    "#_vector_slide1up":
      headers:
      - 17. Vector Permutation Instructions
      - 17.3. Vector Slide Instructions
      - 17.3.3. Vector Slide1up
      url: "/riscv-v-spec/draft/v-spec.html#_vector_slide1up"
    "#_vector_slide1down_instruction":
      headers:
      - 17. Vector Permutation Instructions
      - 17.3. Vector Slide Instructions
      - 17.3.4. Vector Slide1down Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_slide1down_instruction"
    "#_vector_register_gather_instruction":
      headers:
      - 17. Vector Permutation Instructions
      - 17.4. Vector Register Gather Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_register_gather_instruction"
    "#_vector_compress_instruction":
      headers:
      - 17. Vector Permutation Instructions
      - 17.5. Vector Compress Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_compress_instruction"
    "#_whole_vector_register_move":
      headers:
      - 17. Vector Permutation Instructions
      - 17.6. Whole Vector Register Move
      url: "/riscv-v-spec/draft/v-spec.html#_whole_vector_register_move"
    "#_exception_handling":
      headers:
      - 18. Exception Handling
      url: "/riscv-v-spec/draft/v-spec.html#_exception_handling"
    "#_precise_vector_traps":
      headers:
      - 18. Exception Handling
      - 18.1. Precise vector traps
      url: "/riscv-v-spec/draft/v-spec.html#_precise_vector_traps"
    "#_imprecise_vector_traps":
      headers:
      - 18. Exception Handling
      - 18.2. Imprecise vector traps
      url: "/riscv-v-spec/draft/v-spec.html#_imprecise_vector_traps"
    "#_selectable_precise_imprecise_traps":
      headers:
      - 18. Exception Handling
      - 18.3. Selectable precise/imprecise traps
      url: "/riscv-v-spec/draft/v-spec.html#_selectable_precise_imprecise_traps"
    "#_swappable_traps":
      headers:
      - 18. Exception Handling
      - 18.4. Swappable traps
      url: "/riscv-v-spec/draft/v-spec.html#_swappable_traps"
    "#_divided_element_extension_zvediv":
      headers:
      - 19. Divided Element Extension ('Zvediv')
      url: "/riscv-v-spec/draft/v-spec.html#_divided_element_extension_zvediv"
    "#_instructions_not_affected_by_ediv":
      headers:
      - 19. Divided Element Extension ('Zvediv')
      - 19.1. Instructions not affected by EDIV
      url: "/riscv-v-spec/draft/v-spec.html#_instructions_not_affected_by_ediv"
    "#_instructions_affected_by_ediv":
      headers:
      - 19. Divided Element Extension ('Zvediv')
      - 19.2. Instructions Affected by EDIV
      url: "/riscv-v-spec/draft/v-spec.html#_instructions_affected_by_ediv"
    "#_regular_vector_arithmetic_instructions_under_ediv":
      headers:
      - 19. Divided Element Extension ('Zvediv')
      - 19.2. Instructions Affected by EDIV
      - 19.2.1. Regular Vector Arithmetic Instructions under EDIV
      url: "/riscv-v-spec/draft/v-spec.html#_regular_vector_arithmetic_instructions_under_ediv"
    "#_vector_add_with_carry_subtract_with_borrow_reserved_under_ediv_1":
      headers:
      - 19. Divided Element Extension ('Zvediv')
      - 19.2. Instructions Affected by EDIV
      - 19.2.2. Vector Add with Carry/Subtract with Borrow Reserved under EDIV>1
      url: "/riscv-v-spec/draft/v-spec.html#_vector_add_with_carry_subtract_with_borrow_reserved_under_ediv_1"
    "#_vector_reduction_instructions_under_ediv":
      headers:
      - 19. Divided Element Extension ('Zvediv')
      - 19.2. Instructions Affected by EDIV
      - 19.2.3. Vector Reduction Instructions under EDIV
      url: "/riscv-v-spec/draft/v-spec.html#_vector_reduction_instructions_under_ediv"
    "#_vector_register_gather_instructions_under_ediv":
      headers:
      - 19. Divided Element Extension ('Zvediv')
      - 19.2. Instructions Affected by EDIV
      - 19.2.4. Vector Register Gather Instructions under EDIV
      url: "/riscv-v-spec/draft/v-spec.html#_vector_register_gather_instructions_under_ediv"
    "#_vector_integer_dot_product_instruction":
      headers:
      - 19. Divided Element Extension ('Zvediv')
      - 19.3. Vector Integer Dot-Product Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_integer_dot_product_instruction"
    "#_vector_floating_point_dot_product_instruction":
      headers:
      - 19. Divided Element Extension ('Zvediv')
      - 19.4. Vector Floating-Point Dot Product Instruction
      url: "/riscv-v-spec/draft/v-spec.html#_vector_floating_point_dot_product_instruction"
    "#_vector_instruction_listing":
      headers:
      - 20. Vector Instruction Listing
      url: "/riscv-v-spec/draft/v-spec.html#_vector_instruction_listing"
    "#_vector_assembly_code_examples":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      url: "/riscv-v-spec/draft/v-spec.html#_vector_assembly_code_examples"
    "#_vector_vector_add_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.1. Vector-vector add example
      url: "/riscv-v-spec/draft/v-spec.html#_vector_vector_add_example"
    "#_example_with_mixed_width_mask_and_compute":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.2. Example with mixed-width mask and compute.
      url: "/riscv-v-spec/draft/v-spec.html#_example_with_mixed_width_mask_and_compute"
    "#_memcpy_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.3. Memcpy example
      url: "/riscv-v-spec/draft/v-spec.html#_memcpy_example"
    "#_conditional_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.4. Conditional example
      url: "/riscv-v-spec/draft/v-spec.html#_conditional_example"
    "#_saxpy_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.5. SAXPY example
      url: "/riscv-v-spec/draft/v-spec.html#_saxpy_example"
    "#_sgemm_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.6. SGEMM example
      url: "/riscv-v-spec/draft/v-spec.html#_sgemm_example"
    "#_calling_convention":
      headers:
      - 'Appendix B: Calling Convention'
      url: "/riscv-v-spec/draft/v-spec.html#_calling_convention"
  custom:
    "#":
      headers: []
      url: "/riscv-isa-manual/latest/"
isa:
  rv32:
  - beq
  - blt
  - bge
  - bltu
  - jalr
  - jal
  - lui
  - auipc
  - addi
  - slli
  - slti
  - sltiu
  - xori
  - andi
  - add
  - sub
  - sll
  - slt
  - sltu
  - and
  - lb
  - lh
  - lw
  - lhu
  - sw
  - fence
  - ecall
  - ebreak
  f:
  - xor
  - fadd.s
  - fsub.s
  - fdiv.s
  - fsgnj.s
  - fmin.s
  - fsqrt.s
  - flt.s
  - feq.s
  - fcvt.w.s
  - fcvt.wu.s
  - fcvt.l.s
  - fcvt.lu.s
  - fmv.x.w
  - fclass.s
  - fcvt.s.w
  - fcvt.s.l
  - fmv.w.x
  - flw
  - fsw
  - fmadd.s
  - fmsub.s
  - fnmsub.s
  - fnmadd.s
  hypervisor:
  - or
  - sb
  - mret
  - wfi
  - hfence.gvma
  rv64:
  - addiw
  - slliw
  - addw
  - sllw
  - ld
  - lwu
  - sd
  m:
  - mul
  - mulh
  - mulhsu
  - div
  - divu
  - rem
  - remu
  - mulw
  - divw
  - remw
  a:
  - amoadd.w
  - amoxor.w
  - amoor.w
  - amoand.w
  - amomin.w
  - amomax.w
  - amominu.w
  - amomaxu.w
  - amoswap.w
  - lr.w
  - sc.w
  - amoadd.d
  - amoxor.d
  - amoor.d
  - amoand.d
  - amomin.d
  - amomax.d
  - amominu.d
  - amomaxu.d
  - amoswap.d
  - lr.d
  n:
  - uret
  supervisor:
  - sret
  - sfence.vma
  csr:
  - csrrw
  - csrrs
  - csrrc
  - csrrwi
  - csrrsi
  d:
  - fsgnj.d
  - fcvt.s.d
  - fcvt.w.d
  - fcvt.wu.d
  - fmv.x.d
  - fclass.d
  - fcvt.d.w
  - fcvt.d.l
  - fmv.d.x
  - fld
  - fsd
  - fadd.d
  - fsub.d
  - fdiv.d
  - fmin.d
  - fsqrt.d
  - flt.d
  - feq.d
  - fmadd.d
  - fmsub.d
  - fnmsub.d
  - fnmadd.d
  q:
  - fsgnj.q
  - fcvt.s.q
  - fcvt.d.q
  - fcvt.w.q
  - fcvt.wu.q
  - fclass.q
  - fcvt.q.w
  - fcvt.q.l
  - flq
  - fadd.q
  - fsub.q
  - fdiv.q
  - fmin.q
  - fsqrt.q
  - flt.q
  - feq.q
  - fmadd.q
  - fmsub.q
  - fnmsub.q
  - fnmadd.q
  rv128:
  - fmv.x.q
  c:
  - c.addi4spn
  - c.fld
  - c.lw
  - c.flw
  - c.fsd
  - c.sw
  - c.fsw
  - c.addi
  - c.jal
  - c.li
  - c.lui
  - c.srli
  - c.srai
  - c.andi
  - c.sub
  - c.xor
  - c.or
  - c.and
  - c.subw
  - c.addw
  - c.j
  - c.beqz
  - c.bnez
  - c.slli
  - c.fldsp
  - c.lwsp
  - c.flwsp
  - c.mv
  - c.add
  - c.fsdsp
  - c.swsp
  - c.fswsp
  - "@c.nop"
  - "@c.addi16sp"
  - "@c.jr"
  - "@c.jalr"
  - "@c.ebreak"
  - "@c.ld"
  - "@c.sd"
  - "@c.addiw"
  - "@c.ldsp"
  - "@c.sdsp"
  - "@c.lq"
  - "@c.sq"
  - "@c.lqsp"
  - "@c.sqsp"
  v:
  - vsetvli
  - vsetvl
  - vlb.v
  - vlh.v
  - vlw.v
  - vle.v
  - vlbu.v
  - vlhu.v
  - vlwu.v
  - vsb.v
  - vsh.v
  - vsw.v
  - vse.v
  - vlsb.v
  - vlsh.v
  - vlsw.v
  - vlse.v
  - vlsbu.v
  - vlshu.v
  - vlswu.v
  - vssb.v
  - vssh.v
  - vssw.v
  - vsse.v
  - vlxb.v
  - vlxh.v
  - vlxw.v
  - vlxe.v
  - vlxbu.v
  - vlxhu.v
  - vlxwu.v
  - vsxb.v
  - vsxh.v
  - vsxw.v
  - vsxe.v
  - vsuxb.v
  - vsuxh.v
  - vsuxw.v
  - vsuxe.v
  - vlbff.v
  - vlhff.v
  - vlwff.v
  - vleff.v
  - vlbuff.v
  - vlhuff.v
  - vlwuff.v
  - vfadd.vf
  - vfsub.vf
  - vfmin.vf
  - vfmax.vf
  - vfsgnj.vf
  - vfsgnjn.vf
  - vfsgnjx.vf
  - vfmv.s.f
  - vfmerge.vfm
  - vfmv.v.f
  - vfeq.vf
  - vfle.vf
  - vford.vf
  - vflt.vf
  - vfne.vf
  - vfgt.vf
  - vfge.vf
  - vfdiv.vf
  - vfrdiv.vf
  - vfmul.vf
  - vfmadd.vf
  - vfnmadd.vf
  - vfmsub.vf
  - vfnmsub.vf
  - vfmacc.vf
  - vfnmacc.vf
  - vfmsac.vf
  - vfnmsac.vf
  - vfwadd.vf
  - vfwsub.vf
  - vfwadd.wf
  - vfwsub.wf
  - vfwmul.vf
  - vfwmacc.vf
  - vfwnmacc.vf
  - vfwmsac.vf
  - vfwnmsac.vf
  - vfadd.vv
  - vfredsum.vs
  - vfsub.vv
  - vfredosum.vs
  - vfmin.vv
  - vfredmin.vs
  - vfmax.vv
  - vfredmax.vs
  - vfsgnj.vv
  - vfsgnjn.vv
  - vfsgnjx.vv
  - vfmv.f.s
  - vfeq.vv
  - vfle.vv
  - vford.vv
  - vflt.vv
  - vfne.vv
  - vfdiv.vv
  - vfunary0.vv
  - vfunary1.vv
  - vfmul.vv
  - vfmadd.vv
  - vfnmadd.vv
  - vfmsub.vv
  - vfnmsub.vv
  - vfmacc.vv
  - vfnmacc.vv
  - vfmsac.vv
  - vfnmsac.vv
  - vfwadd.vv
  - vfwredsum.vs
  - vfwsub.vv
  - vfwredosum.vs
  - vfwadd.wv
  - vfwsub.wv
  - vfwmul.vv
  - vfdot.vv
  - vfwmacc.vv
  - vfwnmacc.vv
  - vfwmsac.vv
  - vfwnmsac.vv
  - vadd.vx
  - vsub.vx
  - vrsub.vx
  - vminu.vx
  - vmin.vx
  - vmaxu.vx
  - vmax.vx
  - vand.vx
  - vor.vx
  - vxor.vx
  - vrgather.vx
  - vslideup.vx
  - vslidedown.vx
  - vadc.vxm
  - vmadc.vxm
  - vsbc.vxm
  - vmsbc.vxm
  - vmerge.vxm
  - vmv.v.x
  - vseq.vx
  - vsne.vx
  - vsltu.vx
  - vslt.vx
  - vsleu.vx
  - vsle.vx
  - vsgtu.vx
  - vsgt.vx
  - vsaddu.vx
  - vsadd.vx
  - vssubu.vx
  - vssub.vx
  - vaadd.vx
  - vsll.vx
  - vasub.vx
  - vsmul.vx
  - vsrl.vx
  - vsra.vx
  - vssrl.vx
  - vssra.vx
  - vnsrl.vx
  - vnsra.vx
  - vnclipu.vx
  - vnclip.vx
  - vwsmaccu.vx
  - vwsmacc.vx
  - vwsmaccsu.vx
  - vwsmaccus.vx
  - vadd.vv
  - vsub.vv
  - vminu.vv
  - vmin.vv
  - vmaxu.vv
  - vmax.vv
  - vand.vv
  - vor.vv
  - vxor.vv
  - vrgather.vv
  - vadc.vvm
  - vmadc.vvm
  - vsbc.vvm
  - vmsbc.vvm
  - vmerge.vvm
  - vmv.v.v
  - vseq.vv
  - vsne.vv
  - vsltu.vv
  - vslt.vv
  - vsleu.vv
  - vsle.vv
  - vsaddu.vv
  - vsadd.vv
  - vssubu.vv
  - vssub.vv
  - vaadd.vv
  - vsll.vv
  - vasub.vv
  - vsmul.vv
  - vsrl.vv
  - vsra.vv
  - vssrl.vv
  - vssra.vv
  - vnsrl.vv
  - vnsra.vv
  - vnclipu.vv
  - vnclip.vv
  - vwredsumu.vs
  - vwredsum.vs
  - vdotu.vv
  - vdot.vv
  - vwsmaccu.vv
  - vwsmacc.vv
  - vwsmaccsu.vv
  - vadd.vi
  - vrsub.vi
  - vand.vi
  - vor.vi
  - vxor.vi
  - vrgather.vi
  - vslideup.vi
  - vslidedown.vi
  - vadc.vim
  - vmadc.vim
  - vmerge.vim
  - vmv.v.i
  - vseq.vi
  - vsne.vi
  - vsleu.vi
  - vsle.vi
  - vsgtu.vi
  - vsgt.vi
  - vsaddu.vi
  - vsadd.vi
  - vaadd.vi
  - vsll.vi
  - vsrl.vi
  - vsra.vi
  - vssrl.vi
  - vssra.vi
  - vnsrl.vi
  - vnsra.vi
  - vnclipu.vi
  - vnclip.vi
  - vredsum.vs
  - vredand.vs
  - vredor.vs
  - vredxor.vs
  - vredminu.vs
  - vredmin.vs
  - vredmaxu.vs
  - vredmax.vs
  - vext.x.v
  - vmpopc.m
  - vmfirst.m
  - vcompress.vm
  - vmandnot.mm
  - vmand.mm
  - vmor.mm
  - vmxor.mm
  - vmornot.mm
  - vmnand.mm
  - vmnor.mm
  - vmxnor.mm
  - vmsbf.m
  - vmsof.m
  - vmsif.m
  - viota.m
  - vid.v
  - vdivu.vv
  - vdiv.vv
  - vremu.vv
  - vrem.vv
  - vmulhu.vv
  - vmul.vv
  - vmulhsu.vv
  - vmulh.vv
  - vmadd.vv
  - vnmsub.vv
  - vmacc.vv
  - vnmsac.vv
  - vwaddu.vv
  - vwadd.vv
  - vwsubu.vv
  - vwsub.vv
  - vwaddu.wv
  - vwadd.wv
  - vwsubu.wv
  - vwsub.wv
  - vwmulu.vv
  - vwmulsu.vv
  - vwmul.vv
  - vwmaccu.vv
  - vwmacc.vv
  - vwmaccsu.vv
  - vmv.s.x
  - vslide1up.vx
  - vslide1down.vx
  - vdivu.vx
  - vdiv.vx
  - vremu.vx
  - vrem.vx
  - vmulhu.vx
  - vmul.vx
  - vmulhsu.vx
  - vmulh.vx
  - vmadd.vx
  - vnmsub.vx
  - vmacc.vx
  - vnmsac.vx
  - vwaddu.vx
  - vwadd.vx
  - vwsubu.vx
  - vwsub.vx
  - vwaddu.wx
  - vwadd.wx
  - vwsubu.wx
  - vwsub.wx
  - vwmulu.vx
  - vwmulsu.vx
  - vwmul.vx
  - vwmaccu.vx
  - vwmacc.vx
  - vwmaccsu.vx
  - vwmaccus.vx
  unassigned:
  - bne
  - bgeu
  - srli
  - srai
  - ori
  - srl
  - sra
  - srliw
  - sraiw
  - subw
  - srlw
  - sraw
  - lbu
  - sh
  - fence.i
  - mulhu
  - divuw
  - remuw
  - sc.d
  - dret
  - csrrci
  - hfence.bvma
  - fmul.s
  - fsgnjn.s
  - fsgnjx.s
  - fmax.s
  - fmul.d
  - fsgnjn.d
  - fsgnjx.d
  - fmax.d
  - fcvt.d.s
  - fmul.q
  - fsgnjn.q
  - fsgnjx.q
  - fmax.q
  - fcvt.q.s
  - fcvt.q.d
  - fle.s
  - fle.d
  - fle.q
  - fcvt.l.d
  - fcvt.lu.d
  - fcvt.l.q
  - fcvt.lu.q
  - fcvt.s.wu
  - fcvt.s.lu
  - fcvt.d.wu
  - fcvt.d.lu
  - fcvt.q.wu
  - fcvt.q.lu
  - fmv.q.x
  - fsq
  - "@slli.rv32"
  - "@srli.rv32"
  - "@srai.rv32"
  - "@frflags"
  - "@fsflags"
  - "@fsflagsi"
  - "@frrm"
  - "@fsrm"
  - "@fsrmi"
  - "@fscsr"
  - "@frcsr"
  - "@rdcycle"
  - "@rdtime"
  - "@rdinstret"
  - "@rdcycleh"
  - "@rdtimeh"
  - "@rdinstreth"
  - "@scall"
  - "@sbreak"
  - "@fmv.x.s"
  - "@fmv.s.x"
  - "@fence.tso"
args:
  ? - bimm12hi
    - rs1
    - rs2
    - bimm12lo
  : *1
  ? - rd
    - rs1
    - imm12
  : *3
  ? - rd
    - jimm20
  : *24
  ? - rd
    - imm20
  : *2
  ? - rd
    - rs1
  : *4
  ? - rd
    - rs1
    - rs2
  : *5
  ? - imm12hi
    - rs1
    - rs2
    - imm12lo
  : *6
  ? - rs1
    - rd
  : *25
  ? - imm12
    - rs1
    - rd
  : *26
  ? - rs1
    - rs2
  : *8
  ? - rd
    - rs1
    - rs2
    - rs3
  : *9
  ? - rd
  : *10
  ? - rd
    - zimm
  : *11
  ? - rd=2
  : *27
  ? - "!rs2"
  : *28
  ? - "!rs1"
    - "!rs2=c.jalr"
  : *29
  ? - zimm11
    - rs1
    - rd
  : *30
  ? - rs2
    - rs1
    - rd
  : *31
  ? - rs1
    - vd
  : *12
  ? - rs1
    - vs3
  : *13
  ? - rs2
    - rs1
    - vd
  : *14
  ? - rs2
    - rs1
    - vs3
  : *15
  ? - vs2
    - rs1
    - vd
  : *16
  ? - vs2
    - rs1
    - vs3
  : *17
  ? - vs2
    - vs1
    - vd
  : *18
  ? - vs2
    - rd
  : *32
  ? - vs2
    - simm5
    - vd
  : *19
  ? - simm5
    - vd
  : *33
  ? - vs2
    - vs1
    - rd
  : *20
  ? - vs2
    - vd
  : *21
  *7: *7
